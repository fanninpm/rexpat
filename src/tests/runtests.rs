#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
#![register_tool(c2rust)]
#![feature(
    const_raw_ptr_to_usize_cast,
    const_transmute,
    extern_types,
    label_break_value,
    main,
    ptr_wrapping_offset_from,
    register_tool
)]
pub mod expat_h {
    pub type XML_Parser = *mut ::c2rust_out::expat_h::XML_ParserStruct;

    pub type XML_Bool = libc::c_uchar;
    /* The XML_Status enum gives the possible return values for several
       API functions.  The preprocessor #defines are included so this
       stanza can be added to code that still needs to support older
       versions of Expat 1.95.x:

       #ifndef XML_STATUS_OK
       #define XML_STATUS_OK    1
       #define XML_STATUS_ERROR 0
       #endif

       Otherwise, the #define hackery is quite ugly and would have been
       dropped.
    */

    pub type XML_Status = libc::c_uint;

    pub type XML_Error = libc::c_uint;

    pub type XML_Content_Type = libc::c_uint;

    pub type XML_Content_Quant = libc::c_uint;
    /* If type == XML_CTYPE_EMPTY or XML_CTYPE_ANY, then quant will be
       XML_CQUANT_NONE, and the other fields will be zero or NULL.
       If type == XML_CTYPE_MIXED, then quant will be NONE or REP and
       numchildren will contain number of elements that may be mixed in
       and children point to an array of XML_Content cells that will be
       all of XML_CTYPE_NAME type with no quantification.

       If type == XML_CTYPE_NAME, then the name points to the name, and
       the numchildren field will be zero and children will be NULL. The
       quant fields indicates any quantifiers placed on the name.

       CHOICE and SEQ will have name NULL, the number of children in
       numchildren and children will point, recursively, to an array
       of XML_Content cells.

       The EMPTY, ANY, and MIXED types will only occur at top level.
    */

    pub type XML_Content = ::c2rust_out::expat_h::XML_cp;
    /* This is called for an element declaration. See above for
       description of the model argument. It's the caller's responsibility
       to free model when finished with it.
    */

    pub type XML_ElementDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *mut crate::expat_h::XML_Content,
        ) -> (),
    >;
    /* The Attlist declaration handler is called for *each* attribute. So
       a single Attlist declaration with multiple attributes declared will
       generate multiple calls to this handler. The "default" parameter
       may be NULL in the case of the "#IMPLIED" or "#REQUIRED"
       keyword. The "isrequired" parameter will be true and the default
       value will be NULL in the case of "#REQUIRED". If "isrequired" is
       true and default is non-NULL, then this is a "#FIXED" default.
    */

    pub type XML_AttlistDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
        ) -> (),
    >;
    /* The XML declaration handler is called for *both* XML declarations
       and text declarations. The way to distinguish is that the version
       parameter will be NULL for text declarations. The encoding
       parameter may be NULL for XML declarations. The standalone
       parameter will be -1, 0, or 1 indicating respectively that there
       was no standalone parameter in the declaration, that it was given
       as no, or that it was given as yes.
    */

    pub type XML_XmlDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
        ) -> (),
    >;
    /* atts is array of name/value pairs, terminated by 0;
       names and values are 0 terminated.
    */

    pub type XML_StartElementHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *mut *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;

    pub type XML_EndElementHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;
    /* s is not 0 terminated. */

    pub type XML_CharacterDataHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
        ) -> (),
    >;
    /* target and data are 0 terminated */

    pub type XML_ProcessingInstructionHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;
    /* data is 0 terminated */

    pub type XML_CommentHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;

    pub type XML_StartCdataSectionHandler =
        Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>;

    pub type XML_EndCdataSectionHandler = Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>;
    /* This is called for any characters in the XML document for which
       there is no applicable handler.  This includes both characters that
       are part of markup which is of a kind that is not reported
       (comments, markup declarations), or characters that are part of a
       construct which could be reported but for which no handler has been
       supplied. The characters are passed exactly as they were in the XML
       document except that they will be encoded in UTF-8 or UTF-16.
       Line boundaries are not normalized. Note that a byte order mark
       character is not passed to the default handler. There are no
       guarantees about how characters are divided between calls to the
       default handler: for example, a comment might be split between
       multiple calls.
    */

    pub type XML_DefaultHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
        ) -> (),
    >;
    /* This is called for the start of the DOCTYPE declaration, before
       any DTD or internal subset is parsed.
    */

    pub type XML_StartDoctypeDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
        ) -> (),
    >;
    /* This is called for the start of the DOCTYPE declaration when the
       closing > is encountered, but after processing any external
       subset.
    */

    pub type XML_EndDoctypeDeclHandler = Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>;
    /* This is called for entity declarations. The is_parameter_entity
       argument will be non-zero if the entity is a parameter entity, zero
       otherwise.

       For internal entities (<!ENTITY foo "bar">), value will
       be non-NULL and systemId, publicID, and notationName will be NULL.
       The value string is NOT nul-terminated; the length is provided in
       the value_length argument. Since it is legal to have zero-length
       values, do not use this argument to test for internal entities.

       For external entities, value will be NULL and systemId will be
       non-NULL. The publicId argument will be NULL unless a public
       identifier was provided. The notationName argument will have a
       non-NULL value only for unparsed entity declarations.

       Note that is_parameter_entity can't be changed to XML_Bool, since
       that would break binary compatibility.
    */

    pub type XML_EntityDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;
    /* OBSOLETE -- OBSOLETE -- OBSOLETE
       This handler has been superseded by the EntityDeclHandler above.
       It is provided here for backward compatibility.

       This is called for a declaration of an unparsed (NDATA) entity.
       The base argument is whatever was set by XML_SetBase. The
       entityName, systemId and notationName arguments will never be
       NULL. The other arguments may be.
    */

    pub type XML_UnparsedEntityDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;
    /* This is called for a declaration of notation.  The base argument is
       whatever was set by XML_SetBase. The notationName will never be
       NULL.  The other arguments can be.
    */

    pub type XML_NotationDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;
    /* When namespace processing is enabled, these are called once for
       each namespace declaration. The call to the start and end element
       handlers occur between the calls to the start and end namespace
       declaration handlers. For an xmlns attribute, prefix will be
       NULL.  For an xmlns="" attribute, uri will be NULL.
    */

    pub type XML_StartNamespaceDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;

    pub type XML_EndNamespaceDeclHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
        ) -> (),
    >;
    /* This is called if the document is not standalone, that is, it has an
       external subset or a reference to a parameter entity, but does not
       have standalone="yes". If this handler returns XML_STATUS_ERROR,
       then processing will not continue, and the parser will return a
       XML_ERROR_NOT_STANDALONE error.
       If parameter entity parsing is enabled, then in addition to the
       conditions above this handler will only be called if the referenced
       entity was actually read.
    */

    pub type XML_NotStandaloneHandler =
        Option<unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int>;
    /* This is called for a reference to an external parsed general
       entity.  The referenced entity is not automatically parsed.  The
       application can parse it immediately or later using
       XML_ExternalEntityParserCreate.

       The parser argument is the parser parsing the entity containing the
       reference; it can be passed as the parser argument to
       XML_ExternalEntityParserCreate.  The systemId argument is the
       system identifier as specified in the entity declaration; it will
       not be NULL.

       The base argument is the system identifier that should be used as
       the base for resolving systemId if systemId was relative; this is
       set by XML_SetBase; it may be NULL.

       The publicId argument is the public identifier as specified in the
       entity declaration, or NULL if none was specified; the whitespace
       in the public identifier will have been normalized as required by
       the XML spec.

       The context argument specifies the parsing context in the format
       expected by the context argument to XML_ExternalEntityParserCreate;
       context is valid only until the handler returns, so if the
       referenced entity is to be parsed later, it must be copied.
       context is NULL only when the entity is a parameter entity.

       The handler should return XML_STATUS_ERROR if processing should not
       continue because of a fatal error in the handling of the external
       entity.  In this case the calling parser will return an
       XML_ERROR_EXTERNAL_ENTITY_HANDLING error.

       Note that unlike other handlers the first argument is the parser,
       not userData.
    */

    pub type XML_ExternalEntityRefHandler = Option<
        unsafe extern "C" fn(
            _: crate::expat_h::XML_Parser,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
            _: *const crate::expat_external_h::XML_Char,
        ) -> libc::c_int,
    >;
    pub type XML_SkippedEntityHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: libc::c_int,
        ) -> (),
    >;
    /* This is called for an encoding that is unknown to the parser.

       The encodingHandlerData argument is that which was passed as the
       second argument to XML_SetUnknownEncodingHandler.

       The name argument gives the name of the encoding as specified in
       the encoding declaration.

       If the callback can provide information about the encoding, it must
       fill in the XML_Encoding structure, and return XML_STATUS_OK.
       Otherwise it must return XML_STATUS_ERROR.

       If info does not describe a suitable encoding, then the parser will
       return an XML_UNKNOWN_ENCODING error.
    */

    pub type XML_UnknownEncodingHandler = Option<
        unsafe extern "C" fn(
            _: *mut libc::c_void,
            _: *const crate::expat_external_h::XML_Char,
            _: *mut ::c2rust_out::expat_h::XML_Encoding,
        ) -> libc::c_int,
    >;

    pub type XML_Parsing = libc::c_uint;

    pub type XML_ParamEntityParsing = libc::c_uint;
    /* Added in Expat 1.95.5. */

    pub type XML_FeatureEnum = libc::c_uint;
}
pub mod expat_external_h {
    pub type XML_Char = libc::c_char;

    pub type XML_LChar = libc::c_char;
    /* XML_UNICODE */
    /* Use large integers for file/stream positions. */

    pub type XML_Index = libc::c_long;

    pub type XML_Size = libc::c_ulong;
}
pub mod stddef_h {
    pub type ptrdiff_t = libc::c_long;

    pub type size_t = libc::c_ulong;
}
pub mod minicheck_h {
    pub const CK_SILENT: libc::c_int = 0 as libc::c_int;

    pub const CK_NORMAL: libc::c_int = 1 as libc::c_int;
    /* Workaround for Microsoft's compiler and Tru64 Unix systems where the
    C compiler has a working __func__, but the C++ compiler only has a
    working __FUNCTION__.  This could be fixed in configure.in, but it's
    not worth it right now. */

    pub type tcase_setup_function = Option<unsafe extern "C" fn() -> ()>;

    pub type tcase_teardown_function = Option<unsafe extern "C" fn() -> ()>;

    pub type tcase_test_function = Option<unsafe extern "C" fn() -> ()>;
}
pub mod stdlib {
    extern "C" {
        #[no_mangle]
        pub static mut stderr: *mut crate::stdlib::FILE;
        #[no_mangle]
        pub fn strncmp(
            _: *const libc::c_char,
            _: *const libc::c_char,
            _: libc::c_ulong,
        ) -> libc::c_int;
        pub type _IO_marker;

        pub type _IO_codecvt;

        pub type _IO_wide_data;
    }
    pub type FILE = ::c2rust_out::stdlib::_IO_FILE;
    pub type intptr_t = libc::c_long;
    pub type uint64_t = crate::stdlib::__uint64_t;
    pub type _IO_lock_t = ();
    pub type __uint64_t = libc::c_ulong;

    pub type __off_t = libc::c_long;

    pub type __off64_t = libc::c_long;
}


pub mod siphash_h {

    /* struct sipkey */

    pub unsafe extern "C" fn sip_tokey(
        mut key: *mut ::c2rust_out::siphash_h::sipkey,
        mut src: *const libc::c_void,
    ) -> *mut ::c2rust_out::siphash_h::sipkey {
        (*key).k[0 as libc::c_int as usize] = (*(src as *const libc::c_uchar)
            .offset(0 as libc::c_int as isize)
            as crate::stdlib::uint64_t)
            << 0 as libc::c_int
            | (*(src as *const libc::c_uchar).offset(1 as libc::c_int as isize)
                as crate::stdlib::uint64_t)
                << 8 as libc::c_int
            | (*(src as *const libc::c_uchar).offset(2 as libc::c_int as isize)
                as crate::stdlib::uint64_t)
                << 16 as libc::c_int
            | (*(src as *const libc::c_uchar).offset(3 as libc::c_int as isize)
                as crate::stdlib::uint64_t)
                << 24 as libc::c_int
            | (*(src as *const libc::c_uchar).offset(4 as libc::c_int as isize)
                as crate::stdlib::uint64_t)
                << 32 as libc::c_int
            | (*(src as *const libc::c_uchar).offset(5 as libc::c_int as isize)
                as crate::stdlib::uint64_t)
                << 40 as libc::c_int
            | (*(src as *const libc::c_uchar).offset(6 as libc::c_int as isize)
                as crate::stdlib::uint64_t)
                << 48 as libc::c_int
            | (*(src as *const libc::c_uchar).offset(7 as libc::c_int as isize)
                as crate::stdlib::uint64_t)
                << 56 as libc::c_int;
        (*key).k[1 as libc::c_int as usize] = (*(src as *const libc::c_uchar)
            .offset(8 as libc::c_int as isize)
            .offset(0 as libc::c_int as isize)
            as crate::stdlib::uint64_t)
            << 0 as libc::c_int
            | (*(src as *const libc::c_uchar)
                .offset(8 as libc::c_int as isize)
                .offset(1 as libc::c_int as isize) as crate::stdlib::uint64_t)
                << 8 as libc::c_int
            | (*(src as *const libc::c_uchar)
                .offset(8 as libc::c_int as isize)
                .offset(2 as libc::c_int as isize) as crate::stdlib::uint64_t)
                << 16 as libc::c_int
            | (*(src as *const libc::c_uchar)
                .offset(8 as libc::c_int as isize)
                .offset(3 as libc::c_int as isize) as crate::stdlib::uint64_t)
                << 24 as libc::c_int
            | (*(src as *const libc::c_uchar)
                .offset(8 as libc::c_int as isize)
                .offset(4 as libc::c_int as isize) as crate::stdlib::uint64_t)
                << 32 as libc::c_int
            | (*(src as *const libc::c_uchar)
                .offset(8 as libc::c_int as isize)
                .offset(5 as libc::c_int as isize) as crate::stdlib::uint64_t)
                << 40 as libc::c_int
            | (*(src as *const libc::c_uchar)
                .offset(8 as libc::c_int as isize)
                .offset(6 as libc::c_int as isize) as crate::stdlib::uint64_t)
                << 48 as libc::c_int
            | (*(src as *const libc::c_uchar)
                .offset(8 as libc::c_int as isize)
                .offset(7 as libc::c_int as isize) as crate::stdlib::uint64_t)
                << 56 as libc::c_int;
        return key;
    }
    /* sip_tokey() */
    /* SIPHASH_TOBIN */

    pub unsafe extern "C" fn sip_round(
        mut H: *mut ::c2rust_out::siphash_h::siphash,
        rounds: libc::c_int,
    ) {
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < rounds {
            (*H).v0 = ((*H).v0 as libc::c_ulong).wrapping_add((*H).v1) as crate::stdlib::uint64_t
                as crate::stdlib::uint64_t;
            (*H).v1 =
                (*H).v1 << 13 as libc::c_int | (*H).v1 >> 64 as libc::c_int - 13 as libc::c_int;
            (*H).v1 ^= (*H).v0;
            (*H).v0 =
                (*H).v0 << 32 as libc::c_int | (*H).v0 >> 64 as libc::c_int - 32 as libc::c_int;
            (*H).v2 = ((*H).v2 as libc::c_ulong).wrapping_add((*H).v3) as crate::stdlib::uint64_t
                as crate::stdlib::uint64_t;
            (*H).v3 =
                (*H).v3 << 16 as libc::c_int | (*H).v3 >> 64 as libc::c_int - 16 as libc::c_int;
            (*H).v3 ^= (*H).v2;
            (*H).v0 = ((*H).v0 as libc::c_ulong).wrapping_add((*H).v3) as crate::stdlib::uint64_t
                as crate::stdlib::uint64_t;
            (*H).v3 =
                (*H).v3 << 21 as libc::c_int | (*H).v3 >> 64 as libc::c_int - 21 as libc::c_int;
            (*H).v3 ^= (*H).v0;
            (*H).v2 = ((*H).v2 as libc::c_ulong).wrapping_add((*H).v1) as crate::stdlib::uint64_t
                as crate::stdlib::uint64_t;
            (*H).v1 =
                (*H).v1 << 17 as libc::c_int | (*H).v1 >> 64 as libc::c_int - 17 as libc::c_int;
            (*H).v1 ^= (*H).v2;
            (*H).v2 =
                (*H).v2 << 32 as libc::c_int | (*H).v2 >> 64 as libc::c_int - 32 as libc::c_int;
            i += 1
        }
    }
    /* sip_round() */

    pub unsafe extern "C" fn sip24_init(
        mut H: *mut ::c2rust_out::siphash_h::siphash,
        mut key: *const ::c2rust_out::siphash_h::sipkey,
    ) -> *mut ::c2rust_out::siphash_h::siphash {
        (*H).v0 = ((0x736f6d65 as libc::c_uint as crate::stdlib::uint64_t) << 32 as libc::c_int
            | 0x70736575 as libc::c_uint as libc::c_ulong)
            ^ (*key).k[0 as libc::c_int as usize];
        (*H).v1 = ((0x646f7261 as libc::c_uint as crate::stdlib::uint64_t) << 32 as libc::c_int
            | 0x6e646f6d as libc::c_uint as libc::c_ulong)
            ^ (*key).k[1 as libc::c_int as usize];
        (*H).v2 = ((0x6c796765 as libc::c_uint as crate::stdlib::uint64_t) << 32 as libc::c_int
            | 0x6e657261 as libc::c_uint as libc::c_ulong)
            ^ (*key).k[0 as libc::c_int as usize];
        (*H).v3 = ((0x74656462 as libc::c_uint as crate::stdlib::uint64_t) << 32 as libc::c_int
            | 0x79746573 as libc::c_uint as libc::c_ulong)
            ^ (*key).k[1 as libc::c_int as usize];
        (*H).p = (*H).buf.as_mut_ptr();
        (*H).c = 0 as libc::c_int as crate::stdlib::uint64_t;
        return H;
    }
    /* sip24_init() */

    pub unsafe extern "C" fn sip24_update(
        mut H: *mut ::c2rust_out::siphash_h::siphash,
        mut src: *const libc::c_void,
        mut len: crate::stddef_h::size_t,
    ) -> *mut ::c2rust_out::siphash_h::siphash {
        let mut p: *const libc::c_uchar = src as *const libc::c_uchar;
        let mut pe: *const libc::c_uchar = p.offset(len as isize);
        let mut m: crate::stdlib::uint64_t = 0;
        loop {
            while p < pe
                && (*H).p
                    < &mut *(*H).buf.as_mut_ptr().offset(
                        (::std::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong)
                            .wrapping_div(::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
                            as isize,
                    ) as *mut libc::c_uchar
            {
                let fresh0 = p;
                p = p.offset(1);
                let fresh1 = (*H).p;
                (*H).p = (*H).p.offset(1);
                *fresh1 = *fresh0
            }
            if (*H).p
                < &mut *(*H).buf.as_mut_ptr().offset(
                    (::std::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
                        as isize,
                ) as *mut libc::c_uchar
            {
                break;
            }
            m = ((*H).buf[0 as libc::c_int as usize] as crate::stdlib::uint64_t)
                << 0 as libc::c_int
                | ((*H).buf[1 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 8 as libc::c_int
                | ((*H).buf[2 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 16 as libc::c_int
                | ((*H).buf[3 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 24 as libc::c_int
                | ((*H).buf[4 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 32 as libc::c_int
                | ((*H).buf[5 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 40 as libc::c_int
                | ((*H).buf[6 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 48 as libc::c_int
                | ((*H).buf[7 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 56 as libc::c_int;
            (*H).v3 ^= m;
            sip_round(H, 2 as libc::c_int);
            (*H).v0 ^= m;
            (*H).p = (*H).buf.as_mut_ptr();
            (*H).c = ((*H).c as libc::c_ulong).wrapping_add(8 as libc::c_int as libc::c_ulong)
                as crate::stdlib::uint64_t as crate::stdlib::uint64_t;
            if !(p < pe) {
                break;
            }
        }
        return H;
    }
    /* sip24_update() */

    pub unsafe extern "C" fn sip24_final(
        mut H: *mut ::c2rust_out::siphash_h::siphash,
    ) -> crate::stdlib::uint64_t {
        let left: libc::c_char =
            (*H).p.wrapping_offset_from((*H).buf.as_mut_ptr()) as libc::c_long as libc::c_char;
        let mut b: crate::stdlib::uint64_t =
            (*H).c.wrapping_add(left as libc::c_ulong) << 56 as libc::c_int;
        let mut current_block_6: u64;
        match left as libc::c_int {
            7 => {
                b |= ((*H).buf[6 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 48 as libc::c_int;
                current_block_6 = 13145881433301908673;
            }
            6 => {
                current_block_6 = 13145881433301908673;
            }
            5 => {
                current_block_6 = 588075840077989673;
            }
            4 => {
                current_block_6 = 9865490829578899964;
            }
            3 => {
                current_block_6 = 610692000009365401;
            }
            2 => {
                current_block_6 = 5204012310284484386;
            }
            1 => {
                current_block_6 = 34749046854646975;
            }
            0 | _ => {
                current_block_6 = 17965632435239708295;
            }
        }
        match current_block_6 {
            13145881433301908673 =>
            /* fall through */
            {
                b |= ((*H).buf[5 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 40 as libc::c_int;
                current_block_6 = 588075840077989673;
            }
            _ => {}
        }
        match current_block_6 {
            588075840077989673 =>
            /* fall through */
            {
                b |= ((*H).buf[4 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 32 as libc::c_int;
                current_block_6 = 9865490829578899964;
            }
            _ => {}
        }
        match current_block_6 {
            9865490829578899964 =>
            /* fall through */
            {
                b |= ((*H).buf[3 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 24 as libc::c_int;
                current_block_6 = 610692000009365401;
            }
            _ => {}
        }
        match current_block_6 {
            610692000009365401 =>
            /* fall through */
            {
                b |= ((*H).buf[2 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 16 as libc::c_int;
                current_block_6 = 5204012310284484386;
            }
            _ => {}
        }
        match current_block_6 {
            5204012310284484386 =>
            /* fall through */
            {
                b |= ((*H).buf[1 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 8 as libc::c_int;
                current_block_6 = 34749046854646975;
            }
            _ => {}
        }
        match current_block_6 {
            34749046854646975 =>
            /* fall through */
            {
                b |= ((*H).buf[0 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 0 as libc::c_int
            }
            _ => {}
        }
        (*H).v3 ^= b;
        sip_round(H, 2 as libc::c_int);
        (*H).v0 ^= b;
        (*H).v2 ^= 0xff as libc::c_int as libc::c_ulong;
        sip_round(H, 4 as libc::c_int);
        return (*H).v0 ^ (*H).v1 ^ (*H).v2 ^ (*H).v3;
    }
    /* sip24_final() */

    pub unsafe extern "C" fn siphash24(
        mut src: *const libc::c_void,
        mut len: crate::stddef_h::size_t,
        mut key: *const ::c2rust_out::siphash_h::sipkey,
    ) -> crate::stdlib::uint64_t {
        let mut state: ::c2rust_out::siphash_h::siphash = {
            let mut init = ::c2rust_out::siphash_h::siphash {
                v0: 0 as libc::c_int as crate::stdlib::uint64_t,
                v1: 0 as libc::c_int as crate::stdlib::uint64_t,
                v2: 0 as libc::c_int as crate::stdlib::uint64_t,
                v3: 0 as libc::c_int as crate::stdlib::uint64_t,
                buf: [0 as libc::c_int as libc::c_uchar, 0, 0, 0, 0, 0, 0, 0],
                p: 0 as *mut libc::c_uchar,
                c: 0 as libc::c_int as crate::stdlib::uint64_t,
            };
            init
        };
        return sip24_final(sip24_update(sip24_init(&mut state, key), src, len));
    }
    /* siphash24() */
    /*
     * SipHash-2-4 output with
     * k = 00 01 02 ...
     * and
     * in = (empty string)
     * in = 00 (1 byte)
     * in = 00 01 (2 bytes)
     * in = 00 01 02 (3 bytes)
     * ...
     * in = 00 01 02 ... 3e (63 bytes)
     */

    pub unsafe extern "C" fn sip24_valid() -> libc::c_int {
        /* clang-format off */
        pub static mut vectors: [[libc::c_uchar; 8]; 64] = [
            [
                0x31 as libc::c_int as libc::c_uchar,
                0xe as libc::c_int as libc::c_uchar,
                0xe as libc::c_int as libc::c_uchar,
                0xdd as libc::c_int as libc::c_uchar,
                0x47 as libc::c_int as libc::c_uchar,
                0xdb as libc::c_int as libc::c_uchar,
                0x6f as libc::c_int as libc::c_uchar,
                0x72 as libc::c_int as libc::c_uchar,
            ],
            [
                0xfd as libc::c_int as libc::c_uchar,
                0x67 as libc::c_int as libc::c_uchar,
                0xdc as libc::c_int as libc::c_uchar,
                0x93 as libc::c_int as libc::c_uchar,
                0xc5 as libc::c_int as libc::c_uchar,
                0x39 as libc::c_int as libc::c_uchar,
                0xf8 as libc::c_int as libc::c_uchar,
                0x74 as libc::c_int as libc::c_uchar,
            ],
            [
                0x5a as libc::c_int as libc::c_uchar,
                0x4f as libc::c_int as libc::c_uchar,
                0xa9 as libc::c_int as libc::c_uchar,
                0xd9 as libc::c_int as libc::c_uchar,
                0x9 as libc::c_int as libc::c_uchar,
                0x80 as libc::c_int as libc::c_uchar,
                0x6c as libc::c_int as libc::c_uchar,
                0xd as libc::c_int as libc::c_uchar,
            ],
            [
                0x2d as libc::c_int as libc::c_uchar,
                0x7e as libc::c_int as libc::c_uchar,
                0xfb as libc::c_int as libc::c_uchar,
                0xd7 as libc::c_int as libc::c_uchar,
                0x96 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
                0x67 as libc::c_int as libc::c_uchar,
                0x85 as libc::c_int as libc::c_uchar,
            ],
            [
                0xb7 as libc::c_int as libc::c_uchar,
                0x87 as libc::c_int as libc::c_uchar,
                0x71 as libc::c_int as libc::c_uchar,
                0x27 as libc::c_int as libc::c_uchar,
                0xe0 as libc::c_int as libc::c_uchar,
                0x94 as libc::c_int as libc::c_uchar,
                0x27 as libc::c_int as libc::c_uchar,
                0xcf as libc::c_int as libc::c_uchar,
            ],
            [
                0x8d as libc::c_int as libc::c_uchar,
                0xa6 as libc::c_int as libc::c_uchar,
                0x99 as libc::c_int as libc::c_uchar,
                0xcd as libc::c_int as libc::c_uchar,
                0x64 as libc::c_int as libc::c_uchar,
                0x55 as libc::c_int as libc::c_uchar,
                0x76 as libc::c_int as libc::c_uchar,
                0x18 as libc::c_int as libc::c_uchar,
            ],
            [
                0xce as libc::c_int as libc::c_uchar,
                0xe3 as libc::c_int as libc::c_uchar,
                0xfe as libc::c_int as libc::c_uchar,
                0x58 as libc::c_int as libc::c_uchar,
                0x6e as libc::c_int as libc::c_uchar,
                0x46 as libc::c_int as libc::c_uchar,
                0xc9 as libc::c_int as libc::c_uchar,
                0xcb as libc::c_int as libc::c_uchar,
            ],
            [
                0x37 as libc::c_int as libc::c_uchar,
                0xd1 as libc::c_int as libc::c_uchar,
                0x1 as libc::c_int as libc::c_uchar,
                0x8b as libc::c_int as libc::c_uchar,
                0xf5 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0x2 as libc::c_int as libc::c_uchar,
                0xab as libc::c_int as libc::c_uchar,
            ],
            [
                0x62 as libc::c_int as libc::c_uchar,
                0x24 as libc::c_int as libc::c_uchar,
                0x93 as libc::c_int as libc::c_uchar,
                0x9a as libc::c_int as libc::c_uchar,
                0x79 as libc::c_int as libc::c_uchar,
                0xf5 as libc::c_int as libc::c_uchar,
                0xf5 as libc::c_int as libc::c_uchar,
                0x93 as libc::c_int as libc::c_uchar,
            ],
            [
                0xb0 as libc::c_int as libc::c_uchar,
                0xe4 as libc::c_int as libc::c_uchar,
                0xa9 as libc::c_int as libc::c_uchar,
                0xb as libc::c_int as libc::c_uchar,
                0xdf as libc::c_int as libc::c_uchar,
                0x82 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0x9e as libc::c_int as libc::c_uchar,
            ],
            [
                0xf3 as libc::c_int as libc::c_uchar,
                0xb9 as libc::c_int as libc::c_uchar,
                0xdd as libc::c_int as libc::c_uchar,
                0x94 as libc::c_int as libc::c_uchar,
                0xc5 as libc::c_int as libc::c_uchar,
                0xbb as libc::c_int as libc::c_uchar,
                0x5d as libc::c_int as libc::c_uchar,
                0x7a as libc::c_int as libc::c_uchar,
            ],
            [
                0xa7 as libc::c_int as libc::c_uchar,
                0xad as libc::c_int as libc::c_uchar,
                0x6b as libc::c_int as libc::c_uchar,
                0x22 as libc::c_int as libc::c_uchar,
                0x46 as libc::c_int as libc::c_uchar,
                0x2f as libc::c_int as libc::c_uchar,
                0xb3 as libc::c_int as libc::c_uchar,
                0xf4 as libc::c_int as libc::c_uchar,
            ],
            [
                0xfb as libc::c_int as libc::c_uchar,
                0xe5 as libc::c_int as libc::c_uchar,
                0xe as libc::c_int as libc::c_uchar,
                0x86 as libc::c_int as libc::c_uchar,
                0xbc as libc::c_int as libc::c_uchar,
                0x8f as libc::c_int as libc::c_uchar,
                0x1e as libc::c_int as libc::c_uchar,
                0x75 as libc::c_int as libc::c_uchar,
            ],
            [
                0x90 as libc::c_int as libc::c_uchar,
                0x3d as libc::c_int as libc::c_uchar,
                0x84 as libc::c_int as libc::c_uchar,
                0xc0 as libc::c_int as libc::c_uchar,
                0x27 as libc::c_int as libc::c_uchar,
                0x56 as libc::c_int as libc::c_uchar,
                0xea as libc::c_int as libc::c_uchar,
                0x14 as libc::c_int as libc::c_uchar,
            ],
            [
                0xee as libc::c_int as libc::c_uchar,
                0xf2 as libc::c_int as libc::c_uchar,
                0x7a as libc::c_int as libc::c_uchar,
                0x8e as libc::c_int as libc::c_uchar,
                0x90 as libc::c_int as libc::c_uchar,
                0xca as libc::c_int as libc::c_uchar,
                0x23 as libc::c_int as libc::c_uchar,
                0xf7 as libc::c_int as libc::c_uchar,
            ],
            [
                0xe5 as libc::c_int as libc::c_uchar,
                0x45 as libc::c_int as libc::c_uchar,
                0xbe as libc::c_int as libc::c_uchar,
                0x49 as libc::c_int as libc::c_uchar,
                0x61 as libc::c_int as libc::c_uchar,
                0xca as libc::c_int as libc::c_uchar,
                0x29 as libc::c_int as libc::c_uchar,
                0xa1 as libc::c_int as libc::c_uchar,
            ],
            [
                0xdb as libc::c_int as libc::c_uchar,
                0x9b as libc::c_int as libc::c_uchar,
                0xc2 as libc::c_int as libc::c_uchar,
                0x57 as libc::c_int as libc::c_uchar,
                0x7f as libc::c_int as libc::c_uchar,
                0xcc as libc::c_int as libc::c_uchar,
                0x2a as libc::c_int as libc::c_uchar,
                0x3f as libc::c_int as libc::c_uchar,
            ],
            [
                0x94 as libc::c_int as libc::c_uchar,
                0x47 as libc::c_int as libc::c_uchar,
                0xbe as libc::c_int as libc::c_uchar,
                0x2c as libc::c_int as libc::c_uchar,
                0xf5 as libc::c_int as libc::c_uchar,
                0xe9 as libc::c_int as libc::c_uchar,
                0x9a as libc::c_int as libc::c_uchar,
                0x69 as libc::c_int as libc::c_uchar,
            ],
            [
                0x9c as libc::c_int as libc::c_uchar,
                0xd3 as libc::c_int as libc::c_uchar,
                0x8d as libc::c_int as libc::c_uchar,
                0x96 as libc::c_int as libc::c_uchar,
                0xf0 as libc::c_int as libc::c_uchar,
                0xb3 as libc::c_int as libc::c_uchar,
                0xc1 as libc::c_int as libc::c_uchar,
                0x4b as libc::c_int as libc::c_uchar,
            ],
            [
                0xbd as libc::c_int as libc::c_uchar,
                0x61 as libc::c_int as libc::c_uchar,
                0x79 as libc::c_int as libc::c_uchar,
                0xa7 as libc::c_int as libc::c_uchar,
                0x1d as libc::c_int as libc::c_uchar,
                0xc9 as libc::c_int as libc::c_uchar,
                0x6d as libc::c_int as libc::c_uchar,
                0xbb as libc::c_int as libc::c_uchar,
            ],
            [
                0x98 as libc::c_int as libc::c_uchar,
                0xee as libc::c_int as libc::c_uchar,
                0xa2 as libc::c_int as libc::c_uchar,
                0x1a as libc::c_int as libc::c_uchar,
                0xf2 as libc::c_int as libc::c_uchar,
                0x5c as libc::c_int as libc::c_uchar,
                0xd6 as libc::c_int as libc::c_uchar,
                0xbe as libc::c_int as libc::c_uchar,
            ],
            [
                0xc7 as libc::c_int as libc::c_uchar,
                0x67 as libc::c_int as libc::c_uchar,
                0x3b as libc::c_int as libc::c_uchar,
                0x2e as libc::c_int as libc::c_uchar,
                0xb0 as libc::c_int as libc::c_uchar,
                0xcb as libc::c_int as libc::c_uchar,
                0xf2 as libc::c_int as libc::c_uchar,
                0xd0 as libc::c_int as libc::c_uchar,
            ],
            [
                0x88 as libc::c_int as libc::c_uchar,
                0x3e as libc::c_int as libc::c_uchar,
                0xa3 as libc::c_int as libc::c_uchar,
                0xe3 as libc::c_int as libc::c_uchar,
                0x95 as libc::c_int as libc::c_uchar,
                0x67 as libc::c_int as libc::c_uchar,
                0x53 as libc::c_int as libc::c_uchar,
                0x93 as libc::c_int as libc::c_uchar,
            ],
            [
                0xc8 as libc::c_int as libc::c_uchar,
                0xce as libc::c_int as libc::c_uchar,
                0x5c as libc::c_int as libc::c_uchar,
                0xcd as libc::c_int as libc::c_uchar,
                0x8c as libc::c_int as libc::c_uchar,
                0x3 as libc::c_int as libc::c_uchar,
                0xc as libc::c_int as libc::c_uchar,
                0xa8 as libc::c_int as libc::c_uchar,
            ],
            [
                0x94 as libc::c_int as libc::c_uchar,
                0xaf as libc::c_int as libc::c_uchar,
                0x49 as libc::c_int as libc::c_uchar,
                0xf6 as libc::c_int as libc::c_uchar,
                0xc6 as libc::c_int as libc::c_uchar,
                0x50 as libc::c_int as libc::c_uchar,
                0xad as libc::c_int as libc::c_uchar,
                0xb8 as libc::c_int as libc::c_uchar,
            ],
            [
                0xea as libc::c_int as libc::c_uchar,
                0xb8 as libc::c_int as libc::c_uchar,
                0x85 as libc::c_int as libc::c_uchar,
                0x8a as libc::c_int as libc::c_uchar,
                0xde as libc::c_int as libc::c_uchar,
                0x92 as libc::c_int as libc::c_uchar,
                0xe1 as libc::c_int as libc::c_uchar,
                0xbc as libc::c_int as libc::c_uchar,
            ],
            [
                0xf3 as libc::c_int as libc::c_uchar,
                0x15 as libc::c_int as libc::c_uchar,
                0xbb as libc::c_int as libc::c_uchar,
                0x5b as libc::c_int as libc::c_uchar,
                0xb8 as libc::c_int as libc::c_uchar,
                0x35 as libc::c_int as libc::c_uchar,
                0xd8 as libc::c_int as libc::c_uchar,
                0x17 as libc::c_int as libc::c_uchar,
            ],
            [
                0xad as libc::c_int as libc::c_uchar,
                0xcf as libc::c_int as libc::c_uchar,
                0x6b as libc::c_int as libc::c_uchar,
                0x7 as libc::c_int as libc::c_uchar,
                0x63 as libc::c_int as libc::c_uchar,
                0x61 as libc::c_int as libc::c_uchar,
                0x2e as libc::c_int as libc::c_uchar,
                0x2f as libc::c_int as libc::c_uchar,
            ],
            [
                0xa5 as libc::c_int as libc::c_uchar,
                0xc9 as libc::c_int as libc::c_uchar,
                0x1d as libc::c_int as libc::c_uchar,
                0xa7 as libc::c_int as libc::c_uchar,
                0xac as libc::c_int as libc::c_uchar,
                0xaa as libc::c_int as libc::c_uchar,
                0x4d as libc::c_int as libc::c_uchar,
                0xde as libc::c_int as libc::c_uchar,
            ],
            [
                0x71 as libc::c_int as libc::c_uchar,
                0x65 as libc::c_int as libc::c_uchar,
                0x95 as libc::c_int as libc::c_uchar,
                0x87 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
                0x50 as libc::c_int as libc::c_uchar,
                0xa2 as libc::c_int as libc::c_uchar,
                0xa6 as libc::c_int as libc::c_uchar,
            ],
            [
                0x28 as libc::c_int as libc::c_uchar,
                0xef as libc::c_int as libc::c_uchar,
                0x49 as libc::c_int as libc::c_uchar,
                0x5c as libc::c_int as libc::c_uchar,
                0x53 as libc::c_int as libc::c_uchar,
                0xa3 as libc::c_int as libc::c_uchar,
                0x87 as libc::c_int as libc::c_uchar,
                0xad as libc::c_int as libc::c_uchar,
            ],
            [
                0x42 as libc::c_int as libc::c_uchar,
                0xc3 as libc::c_int as libc::c_uchar,
                0x41 as libc::c_int as libc::c_uchar,
                0xd8 as libc::c_int as libc::c_uchar,
                0xfa as libc::c_int as libc::c_uchar,
                0x92 as libc::c_int as libc::c_uchar,
                0xd8 as libc::c_int as libc::c_uchar,
                0x32 as libc::c_int as libc::c_uchar,
            ],
            [
                0xce as libc::c_int as libc::c_uchar,
                0x7c as libc::c_int as libc::c_uchar,
                0xf2 as libc::c_int as libc::c_uchar,
                0x72 as libc::c_int as libc::c_uchar,
                0x2f as libc::c_int as libc::c_uchar,
                0x51 as libc::c_int as libc::c_uchar,
                0x27 as libc::c_int as libc::c_uchar,
                0x71 as libc::c_int as libc::c_uchar,
            ],
            [
                0xe3 as libc::c_int as libc::c_uchar,
                0x78 as libc::c_int as libc::c_uchar,
                0x59 as libc::c_int as libc::c_uchar,
                0xf9 as libc::c_int as libc::c_uchar,
                0x46 as libc::c_int as libc::c_uchar,
                0x23 as libc::c_int as libc::c_uchar,
                0xf3 as libc::c_int as libc::c_uchar,
                0xa7 as libc::c_int as libc::c_uchar,
            ],
            [
                0x38 as libc::c_int as libc::c_uchar,
                0x12 as libc::c_int as libc::c_uchar,
                0x5 as libc::c_int as libc::c_uchar,
                0xbb as libc::c_int as libc::c_uchar,
                0x1a as libc::c_int as libc::c_uchar,
                0xb0 as libc::c_int as libc::c_uchar,
                0xe0 as libc::c_int as libc::c_uchar,
                0x12 as libc::c_int as libc::c_uchar,
            ],
            [
                0xae as libc::c_int as libc::c_uchar,
                0x97 as libc::c_int as libc::c_uchar,
                0xa1 as libc::c_int as libc::c_uchar,
                0xf as libc::c_int as libc::c_uchar,
                0xd4 as libc::c_int as libc::c_uchar,
                0x34 as libc::c_int as libc::c_uchar,
                0xe0 as libc::c_int as libc::c_uchar,
                0x15 as libc::c_int as libc::c_uchar,
            ],
            [
                0xb4 as libc::c_int as libc::c_uchar,
                0xa3 as libc::c_int as libc::c_uchar,
                0x15 as libc::c_int as libc::c_uchar,
                0x8 as libc::c_int as libc::c_uchar,
                0xbe as libc::c_int as libc::c_uchar,
                0xff as libc::c_int as libc::c_uchar,
                0x4d as libc::c_int as libc::c_uchar,
                0x31 as libc::c_int as libc::c_uchar,
            ],
            [
                0x81 as libc::c_int as libc::c_uchar,
                0x39 as libc::c_int as libc::c_uchar,
                0x62 as libc::c_int as libc::c_uchar,
                0x29 as libc::c_int as libc::c_uchar,
                0xf0 as libc::c_int as libc::c_uchar,
                0x90 as libc::c_int as libc::c_uchar,
                0x79 as libc::c_int as libc::c_uchar,
                0x2 as libc::c_int as libc::c_uchar,
            ],
            [
                0x4d as libc::c_int as libc::c_uchar,
                0xc as libc::c_int as libc::c_uchar,
                0xf4 as libc::c_int as libc::c_uchar,
                0x9e as libc::c_int as libc::c_uchar,
                0xe5 as libc::c_int as libc::c_uchar,
                0xd4 as libc::c_int as libc::c_uchar,
                0xdc as libc::c_int as libc::c_uchar,
                0xca as libc::c_int as libc::c_uchar,
            ],
            [
                0x5c as libc::c_int as libc::c_uchar,
                0x73 as libc::c_int as libc::c_uchar,
                0x33 as libc::c_int as libc::c_uchar,
                0x6a as libc::c_int as libc::c_uchar,
                0x76 as libc::c_int as libc::c_uchar,
                0xd8 as libc::c_int as libc::c_uchar,
                0xbf as libc::c_int as libc::c_uchar,
                0x9a as libc::c_int as libc::c_uchar,
            ],
            [
                0xd0 as libc::c_int as libc::c_uchar,
                0xa7 as libc::c_int as libc::c_uchar,
                0x4 as libc::c_int as libc::c_uchar,
                0x53 as libc::c_int as libc::c_uchar,
                0x6b as libc::c_int as libc::c_uchar,
                0xa9 as libc::c_int as libc::c_uchar,
                0x3e as libc::c_int as libc::c_uchar,
                0xe as libc::c_int as libc::c_uchar,
            ],
            [
                0x92 as libc::c_int as libc::c_uchar,
                0x59 as libc::c_int as libc::c_uchar,
                0x58 as libc::c_int as libc::c_uchar,
                0xfc as libc::c_int as libc::c_uchar,
                0xd6 as libc::c_int as libc::c_uchar,
                0x42 as libc::c_int as libc::c_uchar,
                0xc as libc::c_int as libc::c_uchar,
                0xad as libc::c_int as libc::c_uchar,
            ],
            [
                0xa9 as libc::c_int as libc::c_uchar,
                0x15 as libc::c_int as libc::c_uchar,
                0xc2 as libc::c_int as libc::c_uchar,
                0x9b as libc::c_int as libc::c_uchar,
                0xc8 as libc::c_int as libc::c_uchar,
                0x6 as libc::c_int as libc::c_uchar,
                0x73 as libc::c_int as libc::c_uchar,
                0x18 as libc::c_int as libc::c_uchar,
            ],
            [
                0x95 as libc::c_int as libc::c_uchar,
                0x2b as libc::c_int as libc::c_uchar,
                0x79 as libc::c_int as libc::c_uchar,
                0xf3 as libc::c_int as libc::c_uchar,
                0xbc as libc::c_int as libc::c_uchar,
                0xa as libc::c_int as libc::c_uchar,
                0xa6 as libc::c_int as libc::c_uchar,
                0xd4 as libc::c_int as libc::c_uchar,
            ],
            [
                0xf2 as libc::c_int as libc::c_uchar,
                0x1d as libc::c_int as libc::c_uchar,
                0xf2 as libc::c_int as libc::c_uchar,
                0xe4 as libc::c_int as libc::c_uchar,
                0x1d as libc::c_int as libc::c_uchar,
                0x45 as libc::c_int as libc::c_uchar,
                0x35 as libc::c_int as libc::c_uchar,
                0xf9 as libc::c_int as libc::c_uchar,
            ],
            [
                0x87 as libc::c_int as libc::c_uchar,
                0x57 as libc::c_int as libc::c_uchar,
                0x75 as libc::c_int as libc::c_uchar,
                0x19 as libc::c_int as libc::c_uchar,
                0x4 as libc::c_int as libc::c_uchar,
                0x8f as libc::c_int as libc::c_uchar,
                0x53 as libc::c_int as libc::c_uchar,
                0xa9 as libc::c_int as libc::c_uchar,
            ],
            [
                0x10 as libc::c_int as libc::c_uchar,
                0xa5 as libc::c_int as libc::c_uchar,
                0x6c as libc::c_int as libc::c_uchar,
                0xf5 as libc::c_int as libc::c_uchar,
                0xdf as libc::c_int as libc::c_uchar,
                0xcd as libc::c_int as libc::c_uchar,
                0x9a as libc::c_int as libc::c_uchar,
                0xdb as libc::c_int as libc::c_uchar,
            ],
            [
                0xeb as libc::c_int as libc::c_uchar,
                0x75 as libc::c_int as libc::c_uchar,
                0x9 as libc::c_int as libc::c_uchar,
                0x5c as libc::c_int as libc::c_uchar,
                0xcd as libc::c_int as libc::c_uchar,
                0x98 as libc::c_int as libc::c_uchar,
                0x6c as libc::c_int as libc::c_uchar,
                0xd0 as libc::c_int as libc::c_uchar,
            ],
            [
                0x51 as libc::c_int as libc::c_uchar,
                0xa9 as libc::c_int as libc::c_uchar,
                0xcb as libc::c_int as libc::c_uchar,
                0x9e as libc::c_int as libc::c_uchar,
                0xcb as libc::c_int as libc::c_uchar,
                0xa3 as libc::c_int as libc::c_uchar,
                0x12 as libc::c_int as libc::c_uchar,
                0xe6 as libc::c_int as libc::c_uchar,
            ],
            [
                0x96 as libc::c_int as libc::c_uchar,
                0xaf as libc::c_int as libc::c_uchar,
                0xad as libc::c_int as libc::c_uchar,
                0xfc as libc::c_int as libc::c_uchar,
                0x2c as libc::c_int as libc::c_uchar,
                0xe6 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
                0xc7 as libc::c_int as libc::c_uchar,
            ],
            [
                0x72 as libc::c_int as libc::c_uchar,
                0xfe as libc::c_int as libc::c_uchar,
                0x52 as libc::c_int as libc::c_uchar,
                0x97 as libc::c_int as libc::c_uchar,
                0x5a as libc::c_int as libc::c_uchar,
                0x43 as libc::c_int as libc::c_uchar,
                0x64 as libc::c_int as libc::c_uchar,
                0xee as libc::c_int as libc::c_uchar,
            ],
            [
                0x5a as libc::c_int as libc::c_uchar,
                0x16 as libc::c_int as libc::c_uchar,
                0x45 as libc::c_int as libc::c_uchar,
                0xb2 as libc::c_int as libc::c_uchar,
                0x76 as libc::c_int as libc::c_uchar,
                0xd5 as libc::c_int as libc::c_uchar,
                0x92 as libc::c_int as libc::c_uchar,
                0xa1 as libc::c_int as libc::c_uchar,
            ],
            [
                0xb2 as libc::c_int as libc::c_uchar,
                0x74 as libc::c_int as libc::c_uchar,
                0xcb as libc::c_int as libc::c_uchar,
                0x8e as libc::c_int as libc::c_uchar,
                0xbf as libc::c_int as libc::c_uchar,
                0x87 as libc::c_int as libc::c_uchar,
                0x87 as libc::c_int as libc::c_uchar,
                0xa as libc::c_int as libc::c_uchar,
            ],
            [
                0x6f as libc::c_int as libc::c_uchar,
                0x9b as libc::c_int as libc::c_uchar,
                0xb4 as libc::c_int as libc::c_uchar,
                0x20 as libc::c_int as libc::c_uchar,
                0x3d as libc::c_int as libc::c_uchar,
                0xe7 as libc::c_int as libc::c_uchar,
                0xb3 as libc::c_int as libc::c_uchar,
                0x81 as libc::c_int as libc::c_uchar,
            ],
            [
                0xea as libc::c_int as libc::c_uchar,
                0xec as libc::c_int as libc::c_uchar,
                0xb2 as libc::c_int as libc::c_uchar,
                0xa3 as libc::c_int as libc::c_uchar,
                0xb as libc::c_int as libc::c_uchar,
                0x22 as libc::c_int as libc::c_uchar,
                0xa8 as libc::c_int as libc::c_uchar,
                0x7f as libc::c_int as libc::c_uchar,
            ],
            [
                0x99 as libc::c_int as libc::c_uchar,
                0x24 as libc::c_int as libc::c_uchar,
                0xa4 as libc::c_int as libc::c_uchar,
                0x3c as libc::c_int as libc::c_uchar,
                0xc1 as libc::c_int as libc::c_uchar,
                0x31 as libc::c_int as libc::c_uchar,
                0x57 as libc::c_int as libc::c_uchar,
                0x24 as libc::c_int as libc::c_uchar,
            ],
            [
                0xbd as libc::c_int as libc::c_uchar,
                0x83 as libc::c_int as libc::c_uchar,
                0x8d as libc::c_int as libc::c_uchar,
                0x3a as libc::c_int as libc::c_uchar,
                0xaf as libc::c_int as libc::c_uchar,
                0xbf as libc::c_int as libc::c_uchar,
                0x8d as libc::c_int as libc::c_uchar,
                0xb7 as libc::c_int as libc::c_uchar,
            ],
            [
                0xb as libc::c_int as libc::c_uchar,
                0x1a as libc::c_int as libc::c_uchar,
                0x2a as libc::c_int as libc::c_uchar,
                0x32 as libc::c_int as libc::c_uchar,
                0x65 as libc::c_int as libc::c_uchar,
                0xd5 as libc::c_int as libc::c_uchar,
                0x1a as libc::c_int as libc::c_uchar,
                0xea as libc::c_int as libc::c_uchar,
            ],
            [
                0x13 as libc::c_int as libc::c_uchar,
                0x50 as libc::c_int as libc::c_uchar,
                0x79 as libc::c_int as libc::c_uchar,
                0xa3 as libc::c_int as libc::c_uchar,
                0x23 as libc::c_int as libc::c_uchar,
                0x1c as libc::c_int as libc::c_uchar,
                0xe6 as libc::c_int as libc::c_uchar,
                0x60 as libc::c_int as libc::c_uchar,
            ],
            [
                0x93 as libc::c_int as libc::c_uchar,
                0x2b as libc::c_int as libc::c_uchar,
                0x28 as libc::c_int as libc::c_uchar,
                0x46 as libc::c_int as libc::c_uchar,
                0xe4 as libc::c_int as libc::c_uchar,
                0xd7 as libc::c_int as libc::c_uchar,
                0x6 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
            ],
            [
                0xe1 as libc::c_int as libc::c_uchar,
                0x91 as libc::c_int as libc::c_uchar,
                0x5f as libc::c_int as libc::c_uchar,
                0x5c as libc::c_int as libc::c_uchar,
                0xb1 as libc::c_int as libc::c_uchar,
                0xec as libc::c_int as libc::c_uchar,
                0xa4 as libc::c_int as libc::c_uchar,
                0x6c as libc::c_int as libc::c_uchar,
            ],
            [
                0xf3 as libc::c_int as libc::c_uchar,
                0x25 as libc::c_int as libc::c_uchar,
                0x96 as libc::c_int as libc::c_uchar,
                0x5c as libc::c_int as libc::c_uchar,
                0xa1 as libc::c_int as libc::c_uchar,
                0x6d as libc::c_int as libc::c_uchar,
                0x62 as libc::c_int as libc::c_uchar,
                0x9f as libc::c_int as libc::c_uchar,
            ],
            [
                0x57 as libc::c_int as libc::c_uchar,
                0x5f as libc::c_int as libc::c_uchar,
                0xf2 as libc::c_int as libc::c_uchar,
                0x8e as libc::c_int as libc::c_uchar,
                0x60 as libc::c_int as libc::c_uchar,
                0x38 as libc::c_int as libc::c_uchar,
                0x1b as libc::c_int as libc::c_uchar,
                0xe5 as libc::c_int as libc::c_uchar,
            ],
            [
                0x72 as libc::c_int as libc::c_uchar,
                0x45 as libc::c_int as libc::c_uchar,
                0x6 as libc::c_int as libc::c_uchar,
                0xeb as libc::c_int as libc::c_uchar,
                0x4c as libc::c_int as libc::c_uchar,
                0x32 as libc::c_int as libc::c_uchar,
                0x8a as libc::c_int as libc::c_uchar,
                0x95 as libc::c_int as libc::c_uchar,
            ],
        ];
        /* clang-format on */
        let mut in_0: [libc::c_uchar; 64] = [0; 64];
        let mut k: ::c2rust_out::siphash_h::sipkey = ::c2rust_out::siphash_h::sipkey { k: [0; 2] };
        let mut i: crate::stddef_h::size_t = 0;
        sip_tokey(
            &mut k,
            b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x00" as *const u8
                as *const libc::c_char as *const libc::c_void,
        );
        i = 0 as libc::c_int as crate::stddef_h::size_t;
        while i < ::std::mem::size_of::<[libc::c_uchar; 64]>() as libc::c_ulong {
            in_0[i as usize] = i as libc::c_uchar;
            if siphash24(in_0.as_mut_ptr() as *const libc::c_void, i, &mut k)
                != (vectors[i as usize][0 as libc::c_int as usize] as crate::stdlib::uint64_t)
                    << 0 as libc::c_int
                    | (vectors[i as usize][1 as libc::c_int as usize] as crate::stdlib::uint64_t)
                        << 8 as libc::c_int
                    | (vectors[i as usize][2 as libc::c_int as usize] as crate::stdlib::uint64_t)
                        << 16 as libc::c_int
                    | (vectors[i as usize][3 as libc::c_int as usize] as crate::stdlib::uint64_t)
                        << 24 as libc::c_int
                    | (vectors[i as usize][4 as libc::c_int as usize] as crate::stdlib::uint64_t)
                        << 32 as libc::c_int
                    | (vectors[i as usize][5 as libc::c_int as usize] as crate::stdlib::uint64_t)
                        << 40 as libc::c_int
                    | (vectors[i as usize][6 as libc::c_int as usize] as crate::stdlib::uint64_t)
                        << 48 as libc::c_int
                    | (vectors[i as usize][7 as libc::c_int as usize] as crate::stdlib::uint64_t)
                        << 56 as libc::c_int
            {
                return 0 as libc::c_int;
            }
            i = i.wrapping_add(1)
        }
        return 1 as libc::c_int;
    }

    
    
    /* SIPHASH_H */
    /* SIPHASH_MAIN */
    /* sip24_valid() */
}

pub use crate::expat_external_h::{XML_Char, XML_Index, XML_LChar, XML_Size};
pub use crate::expat_h::{
    XML_AttlistDeclHandler, XML_Bool, XML_CharacterDataHandler, XML_CommentHandler, XML_Content,
    XML_Content_Quant, XML_Content_Type, XML_DefaultHandler, XML_ElementDeclHandler,
    XML_EndCdataSectionHandler, XML_EndDoctypeDeclHandler, XML_EndElementHandler,
    XML_EndNamespaceDeclHandler, XML_EntityDeclHandler, XML_Error, XML_ExternalEntityRefHandler,
    XML_FeatureEnum, XML_NotStandaloneHandler, XML_NotationDeclHandler, XML_ParamEntityParsing,
    XML_Parser, XML_Parsing, XML_ProcessingInstructionHandler, XML_SkippedEntityHandler,
    XML_StartCdataSectionHandler, XML_StartDoctypeDeclHandler, XML_StartElementHandler,
    XML_StartNamespaceDeclHandler, XML_Status, XML_UnknownEncodingHandler,
    XML_UnparsedEntityDeclHandler, XML_XmlDeclHandler,
};
pub use crate::minicheck_h::{
    tcase_setup_function, tcase_teardown_function, tcase_test_function, CK_NORMAL, CK_SILENT,
};
pub use crate::siphash_h::{
    sip24_final, sip24_init, sip24_update, sip24_valid, sip_round, sip_tokey, siphash24,
};
pub use crate::stddef_h::{ptrdiff_t, size_t};
pub use crate::stdlib::{
    _IO_codecvt, _IO_lock_t, _IO_marker, _IO_wide_data, __off64_t, __off_t, __uint64_t, intptr_t,
    uint64_t, FILE,
};

/* Test attribute counts, indexing, etc */

pub type AttrInfo = attrInfo;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct attrInfo {
    pub name: *const crate::expat_external_h::XML_Char,
    pub value: *const crate::expat_external_h::XML_Char,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtOption {
    pub system_id: *const crate::expat_external_h::XML_Char,
    pub parse_text: *const libc::c_char,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtTest {
    pub parse_text: *const libc::c_char,
    pub encoding: *const crate::expat_external_h::XML_Char,
    pub storage: *mut ::c2rust_out::src::tests::chardata::CharData,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct TestCase {
    pub expectedMovementInChars: crate::stddef_h::ptrdiff_t,
    pub input: *const libc::c_char,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ext_faults {
    pub parse_text: *const libc::c_char,
    pub fail_text: *const libc::c_char,
    pub encoding: *const crate::expat_external_h::XML_Char,
    pub error: crate::expat_h::XML_Error,
}
/* Test that bad encodings are faulted */

pub type ExtFaults = ext_faults;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttTest {
    pub definition: *const libc::c_char,
    pub element_name: *const crate::expat_external_h::XML_Char,
    pub attr_name: *const crate::expat_external_h::XML_Char,
    pub attr_type: *const crate::expat_external_h::XML_Char,
    pub default_value: *const crate::expat_external_h::XML_Char,
    pub is_required: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CaseData {
    pub text: *const libc::c_char,
    pub expectedError: crate::expat_h::XML_Error,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CaseData_0 {
    pub text_bytes: crate::stddef_h::size_t,
    pub text: *const libc::c_char,
    pub expected_error: crate::expat_h::XML_Error,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct elementInfo {
    pub name: *const crate::expat_external_h::XML_Char,
    pub attr_count: libc::c_int,
    pub id_name: *const crate::expat_external_h::XML_Char,
    pub attributes: *mut AttrInfo,
}

pub type ElementInfo = elementInfo;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ByteTestData {
    pub start_element_len: libc::c_int,
    pub cdata_len: libc::c_int,
    pub total_string_len: libc::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ext_hdlr_data {
    pub parse_text: *const libc::c_char,
    pub handler: crate::expat_h::XML_ExternalEntityRefHandler,
}
/* Test a different form of unknown external entity */

pub type ExtHdlrData = ext_hdlr_data;
/* Test an external entity parser set to use latin-1 detects UTF-16
 * BOMs correctly.
 */

pub type ee_parse_flags = libc::c_uint;

pub const EE_PARSE_FULL_BUFFER: ee_parse_flags = 1;

pub const EE_PARSE_NONE: ee_parse_flags = 0;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtTest2 {
    pub parse_text: *const libc::c_char,
    pub parse_len: libc::c_int,
    pub encoding: *const crate::expat_external_h::XML_Char,
    pub storage: *mut ::c2rust_out::src::tests::chardata::CharData,
    pub flags: ee_parse_flags,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtFaults2 {
    pub parse_text: *const libc::c_char,
    pub parse_len: libc::c_int,
    pub fail_text: *const libc::c_char,
    pub encoding: *const crate::expat_external_h::XML_Char,
    pub error: crate::expat_h::XML_Error,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct default_check {
    pub expected: *const crate::expat_external_h::XML_Char,
    pub expectedLen: libc::c_int,
    pub seen: crate::expat_h::XML_Bool,
}
/* Test for issue #11, wrongly suppressed default handler */

pub type DefaultCheck = default_check;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct DataIssue240 {
    pub parser: crate::expat_h::XML_Parser,
    pub deep: libc::c_int,
}
/* Run the Expat test suite
                            __  __            _
                         ___\ \/ /_ __   __ _| |_
                        / _ \\  /| '_ \ / _` | __|
                       |  __//  \| |_) | (_| | |_
                        \___/_/\_\ .__/ \__,_|\__|
                                 |_| XML parser

   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
   Copyright (c) 2000-2017 Expat development team
   Licensed under the MIT license:

   Permission is  hereby granted,  free of charge,  to any  person obtaining
   a  copy  of  this  software   and  associated  documentation  files  (the
   "Software"),  to  deal in  the  Software  without restriction,  including
   without  limitation the  rights  to use,  copy,  modify, merge,  publish,
   distribute, sublicense, and/or sell copies of the Software, and to permit
   persons  to whom  the Software  is  furnished to  do so,  subject to  the
   following conditions:

   The above copyright  notice and this permission notice  shall be included
   in all copies or substantial portions of the Software.

   THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/* ptrdiff_t */
/* intptr_t uint64_t */
/* XML_UNICODE */
/* XML_UNICODE_WCHAR_T */

static mut g_parser: crate::expat_h::XML_Parser =
    ::c2rust_out::stddef_h::NULL as crate::expat_h::XML_Parser;

unsafe extern "C" fn basic_setup() {
    g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate(
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if g_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            115 as libc::c_int,
            b"Parser not created.\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn basic_teardown() {
    if !g_parser.is_null() {
        ::c2rust_out::src::lib::xmlparse::XML_ParserFree(g_parser);
        g_parser = ::c2rust_out::stddef_h::NULL as crate::expat_h::XML_Parser
    };
}
/* Generate a failure using the parser state to create an error message;
   this should be used when the parser reports an error we weren't
   expecting.
*/

unsafe extern "C" fn _xml_failure(
    mut parser: crate::expat_h::XML_Parser,
    mut file: *const libc::c_char,
    mut line: libc::c_int,
) {
    let mut buffer: [libc::c_char; 1024] = [0; 1024]; /* to help out-of-bounds detection */
    let mut err: crate::expat_h::XML_Error =
        ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(parser);
    ::libc::sprintf(
        buffer.as_mut_ptr(),
        b"    %d: %s (line %lu, offset %lu)\n    reported from %s, line %d\n\x00" as *const u8
            as *const libc::c_char,
        err as libc::c_uint,
        ::c2rust_out::src::lib::xmlparse::XML_ErrorString(err),
        ::c2rust_out::src::lib::xmlparse::XML_GetCurrentLineNumber(parser),
        ::c2rust_out::src::lib::xmlparse::XML_GetCurrentColumnNumber(parser),
        file,
        line,
    );
    ::c2rust_out::src::tests::minicheck::_fail_unless(
        0 as libc::c_int,
        file,
        line,
        buffer.as_mut_ptr(),
    );
}

unsafe extern "C" fn _XML_Parse_SINGLE_BYTES(
    mut parser: crate::expat_h::XML_Parser,
    mut s: *const libc::c_char,
    mut len: libc::c_int,
    mut isFinal: libc::c_int,
) -> crate::expat_h::XML_Status {
    let mut res: crate::expat_h::XML_Status =
        ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as crate::expat_h::XML_Status;
    let mut offset: libc::c_int = 0 as libc::c_int;
    if len == 0 as libc::c_int {
        return ::c2rust_out::src::lib::xmlparse::XML_Parse(parser, s, len, isFinal);
    }
    while offset < len {
        let innerIsFinal: libc::c_int =
            (offset == len - 1 as libc::c_int && isFinal != 0) as libc::c_int;
        let c: libc::c_char = *s.offset(offset as isize);
        res = ::c2rust_out::src::lib::xmlparse::XML_Parse(
            parser,
            &c,
            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong as libc::c_int,
            innerIsFinal,
        );
        if res as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint {
            return res;
        }
        offset += 1
    }
    return res;
}

unsafe extern "C" fn _expect_failure(
    mut text: *const libc::c_char,
    mut errorCode: crate::expat_h::XML_Error,
    mut errorMessage: *const libc::c_char,
    mut file: *const libc::c_char,
    mut lineno: libc::c_int,
) {
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        /* Hackish use of _fail_unless() macro, but let's us report
        the right filename and line number. */
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            file,
            lineno,
            errorMessage,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != errorCode as libc::c_uint
    {
        _xml_failure(g_parser, file, lineno);
    };
}
/* Dummy handlers for when we need to set a handler to tickle a bug,
   but it doesn't need to do anything.
*/

static mut dummy_handler_flags: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;

pub const DUMMY_START_DOCTYPE_HANDLER_FLAG: libc::c_ulong =
    (1 as libc::c_ulong) << 0 as libc::c_int;

pub const DUMMY_END_DOCTYPE_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 1 as libc::c_int;

pub const DUMMY_ENTITY_DECL_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 2 as libc::c_int;

pub const DUMMY_NOTATION_DECL_HANDLER_FLAG: libc::c_ulong =
    (1 as libc::c_ulong) << 3 as libc::c_int;

pub const DUMMY_ELEMENT_DECL_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 4 as libc::c_int;

pub const DUMMY_ATTLIST_DECL_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 5 as libc::c_int;

pub const DUMMY_COMMENT_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 6 as libc::c_int;

pub const DUMMY_PI_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 7 as libc::c_int;

pub const DUMMY_START_ELEMENT_HANDLER_FLAG: libc::c_ulong =
    (1 as libc::c_ulong) << 8 as libc::c_int;

pub const DUMMY_START_CDATA_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 9 as libc::c_int;

pub const DUMMY_END_CDATA_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 10 as libc::c_int;

pub const DUMMY_UNPARSED_ENTITY_DECL_HANDLER_FLAG: libc::c_ulong =
    (1 as libc::c_ulong) << 11 as libc::c_int;

pub const DUMMY_START_NS_DECL_HANDLER_FLAG: libc::c_ulong =
    (1 as libc::c_ulong) << 12 as libc::c_int;

pub const DUMMY_END_NS_DECL_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 13 as libc::c_int;

pub const DUMMY_START_DOCTYPE_DECL_HANDLER_FLAG: libc::c_ulong =
    (1 as libc::c_ulong) << 14 as libc::c_int;

pub const DUMMY_END_DOCTYPE_DECL_HANDLER_FLAG: libc::c_ulong =
    (1 as libc::c_ulong) << 15 as libc::c_int;

pub const DUMMY_SKIP_HANDLER_FLAG: libc::c_ulong = (1 as libc::c_ulong) << 16 as libc::c_int;

unsafe extern "C" fn dummy_xdecl_handler(
    mut _userData: *mut libc::c_void,
    mut _version: *const crate::expat_external_h::XML_Char,
    mut _encoding: *const crate::expat_external_h::XML_Char,
    mut _standalone: libc::c_int,
) {
}

unsafe extern "C" fn dummy_start_doctype_handler(
    mut _userData: *mut libc::c_void,
    mut _doctypeName: *const crate::expat_external_h::XML_Char,
    mut _sysid: *const crate::expat_external_h::XML_Char,
    mut _pubid: *const crate::expat_external_h::XML_Char,
    mut _has_internal_subset: libc::c_int,
) {
    dummy_handler_flags |= DUMMY_START_DOCTYPE_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_end_doctype_handler(mut _userData: *mut libc::c_void) {
    dummy_handler_flags |= DUMMY_END_DOCTYPE_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_entity_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _entityName: *const crate::expat_external_h::XML_Char,
    mut _is_parameter_entity: libc::c_int,
    mut _value: *const crate::expat_external_h::XML_Char,
    mut _value_length: libc::c_int,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
    mut _notationName: *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_ENTITY_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_notation_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _notationName: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_NOTATION_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_element_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut model: *mut crate::expat_h::XML_Content,
) {
    /* The content model must be freed by the handler.  Unfortunately
     * we cannot pass the parser as the userData because this is used
     * with other handlers that require other userData.
     */
    ::c2rust_out::src::lib::xmlparse::XML_FreeContentModel(
        g_parser,
        model as *mut ::c2rust_out::expat_h::XML_cp,
    );
    dummy_handler_flags |= DUMMY_ELEMENT_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_attlist_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _elname: *const crate::expat_external_h::XML_Char,
    mut _attname: *const crate::expat_external_h::XML_Char,
    mut _att_type: *const crate::expat_external_h::XML_Char,
    mut _dflt: *const crate::expat_external_h::XML_Char,
    mut _isrequired: libc::c_int,
) {
    dummy_handler_flags |= DUMMY_ATTLIST_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_comment_handler(
    mut _userData: *mut libc::c_void,
    mut _data: *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_COMMENT_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_pi_handler(
    mut _userData: *mut libc::c_void,
    mut _target: *const crate::expat_external_h::XML_Char,
    mut _data: *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_PI_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_start_element(
    mut _userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut _atts: *mut *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_START_ELEMENT_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_end_element(
    mut _userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
) {
}

unsafe extern "C" fn dummy_start_cdata_handler(mut _userData: *mut libc::c_void) {
    dummy_handler_flags |= DUMMY_START_CDATA_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_end_cdata_handler(mut _userData: *mut libc::c_void) {
    dummy_handler_flags |= DUMMY_END_CDATA_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_cdata_handler(
    mut _userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut _len: libc::c_int,
) {
}

unsafe extern "C" fn dummy_start_namespace_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _prefix: *const crate::expat_external_h::XML_Char,
    mut _uri: *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_START_NS_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_end_namespace_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _prefix: *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_END_NS_DECL_HANDLER_FLAG;
}
/* This handler is obsolete, but while the code exists we should
 * ensure that dealing with the handler is covered by tests.
 */

unsafe extern "C" fn dummy_unparsed_entity_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _entityName: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
    mut _notationName: *const crate::expat_external_h::XML_Char,
) {
    dummy_handler_flags |= DUMMY_UNPARSED_ENTITY_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_default_handler(
    mut _userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut _len: libc::c_int,
) {
}

unsafe extern "C" fn dummy_start_doctype_decl_handler(
    mut _userData: *mut libc::c_void,
    mut _doctypeName: *const crate::expat_external_h::XML_Char,
    mut _sysid: *const crate::expat_external_h::XML_Char,
    mut _pubid: *const crate::expat_external_h::XML_Char,
    mut _has_internal_subset: libc::c_int,
) {
    dummy_handler_flags |= DUMMY_START_DOCTYPE_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_end_doctype_decl_handler(mut _userData: *mut libc::c_void) {
    dummy_handler_flags |= DUMMY_END_DOCTYPE_DECL_HANDLER_FLAG;
}

unsafe extern "C" fn dummy_skip_handler(
    mut _userData: *mut libc::c_void,
    mut _entityName: *const crate::expat_external_h::XML_Char,
    mut _is_parameter_entity: libc::c_int,
) {
    dummy_handler_flags |= DUMMY_SKIP_HANDLER_FLAG;
}

unsafe extern "C" fn external_entity_optioner(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut options: *mut ExtOption = *(parser as *mut *mut libc::c_void) as *mut ExtOption;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    while !(*options).parse_text.is_null() {
        if ::libc::strcmp(systemId, (*options).system_id) == 0 {
            let mut rc: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
            ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
                parser,
                context,
                ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            );
            if ext_parser.is_null() {
                return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
            }
            rc = _XML_Parse_SINGLE_BYTES(
                ext_parser,
                (*options).parse_text,
                ::c2rust_out::stdlib::strlen((*options).parse_text) as libc::c_int,
                ::c2rust_out::expat_h::XML_TRUE,
            );
            ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
            return rc as libc::c_int;
        }
        options = options.offset(1)
    }
    ::c2rust_out::src::tests::minicheck::_fail_unless(
        0 as libc::c_int,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        432 as libc::c_int,
        b"No suitable option found\x00" as *const u8 as *const libc::c_char,
    );
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}
/*
 * Parameter entity evaluation support.
 */

pub const ENTITY_MATCH_FAIL: libc::c_int = -(1 as libc::c_int);

pub const ENTITY_MATCH_NOT_FOUND: libc::c_int = 0 as libc::c_int;

pub const ENTITY_MATCH_SUCCESS: libc::c_int = 1 as libc::c_int;

static mut entity_name_to_match: *const crate::expat_external_h::XML_Char =
    ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char;

static mut entity_value_to_match: *const crate::expat_external_h::XML_Char =
    ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char;

static mut entity_match_flag: libc::c_int = ENTITY_MATCH_NOT_FOUND;

unsafe extern "C" fn param_entity_match_handler(
    mut _userData: *mut libc::c_void,
    mut entityName: *const crate::expat_external_h::XML_Char,
    mut is_parameter_entity: libc::c_int,
    mut value: *const crate::expat_external_h::XML_Char,
    mut value_length: libc::c_int,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
    mut _notationName: *const crate::expat_external_h::XML_Char,
) {
    if is_parameter_entity == 0 || entity_name_to_match.is_null() || entity_value_to_match.is_null()
    {
        return;
    }
    if ::libc::strcmp(entityName, entity_name_to_match) == 0 {
        /* The cast here is safe because we control the horizontal and
         * the vertical, and we therefore know our strings are never
         * going to overflow an int.
         */
        if value_length != ::c2rust_out::stdlib::strlen(entity_value_to_match) as libc::c_int
            || crate::stdlib::strncmp(value, entity_value_to_match, value_length as libc::c_ulong)
                != 0
        {
            entity_match_flag = ENTITY_MATCH_FAIL
        } else {
            entity_match_flag = ENTITY_MATCH_SUCCESS
        }
    };
    /* Else leave the match flag alone */
}
/*
 * Character & encoding tests.
 */

unsafe extern "C" fn test_nul_byte() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"test_nul_byte\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        480 as libc::c_int,
    );
    let mut text: [libc::c_char; 13] =
        *::std::mem::transmute::<&[u8; 13], &mut [libc::c_char; 13]>(b"<doc>\x00</doc>\x00");
    /* test that a NUL byte (in US-ASCII data) is an error */
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_mut_ptr(),
        (::std::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            486 as libc::c_int,
            b"Parser did not report error on NUL-byte.\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            488 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_u0000_char() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"test_u0000_char\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        492 as libc::c_int,
    );
    /* test that a NUL byte (in US-ASCII data) is an error */
    _expect_failure(
        b"<doc>&#0;</doc>\x00" as *const u8 as *const libc::c_char,
        ::c2rust_out::expat_h::XML_ERROR_BAD_CHAR_REF,
        b"Parser did not report error on NUL-byte.\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        495 as libc::c_int,
    );
}

unsafe extern "C" fn test_siphash_self() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_siphash_self\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        499 as libc::c_int,
    );
    if sip24_valid() == 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            501 as libc::c_int,
            b"SipHash self-test failed\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_siphash_spec() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_siphash_spec\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        505 as libc::c_int,
    );
    /* https://131002.net/siphash/siphash.pdf (page 19, "Test values") */
    let message: [libc::c_char; 16] = *::std::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(
        b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x00",
    );
    let len: crate::stddef_h::size_t = (::std::mem::size_of::<[libc::c_char; 16]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong);
    let expected: crate::stdlib::uint64_t = (0xa129ca61 as libc::c_uint as crate::stdlib::uint64_t)
        << 32 as libc::c_int
        | 0x49be45e5 as libc::c_uint as libc::c_ulong;
    let mut state: ::c2rust_out::siphash_h::siphash = ::c2rust_out::siphash_h::siphash {
        v0: 0,
        v1: 0,
        v2: 0,
        v3: 0,
        buf: [0; 8],
        p: 0 as *mut libc::c_uchar,
        c: 0,
    };
    let mut key: ::c2rust_out::siphash_h::sipkey = ::c2rust_out::siphash_h::sipkey { k: [0; 2] };
    sip_tokey(
        &mut key,
        b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x00" as *const u8
            as *const libc::c_char as *const libc::c_void,
    );
    sip24_init(&mut state, &mut key);
    /* Cover spread across calls */
    sip24_update(
        &mut state,
        message.as_ptr() as *const libc::c_void,
        4 as libc::c_int as crate::stddef_h::size_t,
    );
    sip24_update(
        &mut state,
        message.as_ptr().offset(4 as libc::c_int as isize) as *const libc::c_void,
        len.wrapping_sub(4 as libc::c_int as libc::c_ulong),
    );
    /* Cover null length */
    sip24_update(
        &mut state,
        message.as_ptr() as *const libc::c_void,
        0 as libc::c_int as crate::stddef_h::size_t,
    );
    if sip24_final(&mut state) != expected {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            526 as libc::c_int,
            b"sip24_final failed spec test\n\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Cover wrapper */
    if siphash24(message.as_ptr() as *const libc::c_void, len, &mut key) != expected {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            530 as libc::c_int,
            b"siphash24 failed spec test\n\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_bom_utf8() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"test_bom_utf8\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        534 as libc::c_int,
    );
    /* This test is really just making sure we don't core on a UTF-8 BOM. */
    let mut text: *const libc::c_char = b"\xef\xbb\xbf<e/>\x00" as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            540 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_bom_utf16_be() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_bom_utf16_be\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        544 as libc::c_int,
    );
    let mut text: [libc::c_char; 11] = *::std::mem::transmute::<&[u8; 11], &mut [libc::c_char; 11]>(
        b"\xfe\xff\x00<\x00e\x00/\x00>\x00",
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_mut_ptr(),
        (::std::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            549 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_bom_utf16_le() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_bom_utf16_le\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        553 as libc::c_int,
    );
    let mut text: [libc::c_char; 11] = *::std::mem::transmute::<&[u8; 11], &mut [libc::c_char; 11]>(
        b"\xff\xfe<\x00e\x00/\x00>\x00\x00",
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_mut_ptr(),
        (::std::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            558 as libc::c_int,
        );
    };
}
/* Parse whole buffer at once to exercise a different code path */

unsafe extern "C" fn test_nobom_utf16_le() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_nobom_utf16_le\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        563 as libc::c_int,
    );
    let mut text: [libc::c_char; 11] = *::std::mem::transmute::<&[u8; 11], &mut [libc::c_char; 11]>(
        b" \x00<\x00e\x00/\x00>\x00\x00",
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text.as_mut_ptr(),
        (::std::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            567 as libc::c_int,
        );
    };
}

unsafe extern "C" fn accumulate_characters(
    mut userData: *mut libc::c_void,
    mut s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        userData as *mut ::c2rust_out::src::tests::chardata::CharData
            as *mut ::c2rust_out::src::tests::chardata::CharData,
        s,
        len,
    );
}

unsafe extern "C" fn accumulate_attribute(
    mut userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut atts: *mut *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    /* Check there are attributes to deal with */
    if atts.is_null() {
        return;
    }
    while (*storage).count < 0 as libc::c_int
        && !(*atts.offset(0 as libc::c_int as isize)).is_null()
    {
        /* "accumulate" the value of the first attribute we see */
        ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
            storage as *mut ::c2rust_out::src::tests::chardata::CharData,
            *atts.offset(1 as libc::c_int as isize),
            -(1 as libc::c_int),
        );
        atts = atts.offset(2 as libc::c_int as isize)
    }
}

unsafe extern "C" fn _run_character_check(
    mut text: *const libc::c_char,
    mut expected: *const crate::expat_external_h::XML_Char,
    mut file: *const libc::c_char,
    mut line: libc::c_int,
) {
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(g_parser, file, line);
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn _run_attribute_check(
    mut text: *const libc::c_char,
    mut expected: *const crate::expat_external_h::XML_Char,
    mut file: *const libc::c_char,
    mut line: libc::c_int,
) {
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            accumulate_attribute
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(g_parser, file, line);
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn ext_accumulate_characters(
    mut userData: *mut libc::c_void,
    mut s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    let mut test_data: *mut ExtTest = userData as *mut ExtTest;
    accumulate_characters((*test_data).storage as *mut libc::c_void, s, len);
}

unsafe extern "C" fn _run_ext_character_check(
    mut text: *const libc::c_char,
    mut test_data: *mut ExtTest,
    mut expected: *const crate::expat_external_h::XML_Char,
    mut file: *const libc::c_char,
    mut line: libc::c_int,
) {
    let storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::stdlib::malloc(::std::mem::size_of::<
            ::c2rust_out::src::tests::chardata::CharData,
        >() as libc::c_ulong) as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_Init(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    (*test_data).storage = storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(g_parser, test_data as *mut libc::c_void);
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(g_parser, file, line);
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
    ::libc::free(storage as *mut libc::c_void);
}
/* Regression test for SF bug #491986. */

unsafe extern "C" fn test_danish_latin1() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_danish_latin1\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        659 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?>\n<e>J\xf8rgen \xe6\xf8\xe5\xc6\xd8\xc5</e>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"J\xc3\xb8rgen \xc3\xa6\xc3\xb8\xc3\xa5\xc3\x86\xc3\x98\xc3\x85\x00" as *const u8
            as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        669 as libc::c_int,
    );
}
/* Regression test for SF bug #514281. */

unsafe extern "C" fn test_french_charref_hexidecimal() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_french_charref_hexidecimal\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        674 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?>\n<doc>&#xE9;&#xE8;&#xE0;&#xE7;&#xEA;&#xC8;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa9\xc3\xa8\xc3\xa0\xc3\xa7\xc3\xaa\xc3\x88\x00" as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        683 as libc::c_int,
    );
}

unsafe extern "C" fn test_french_charref_decimal() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_french_charref_decimal\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        687 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?>\n<doc>&#233;&#232;&#224;&#231;&#234;&#200;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa9\xc3\xa8\xc3\xa0\xc3\xa7\xc3\xaa\xc3\x88\x00" as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        696 as libc::c_int,
    );
}

unsafe extern "C" fn test_french_latin1() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_french_latin1\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        700 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?>\n<doc>\xe9\xe8\xe0\xe7\xea\xc8</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa9\xc3\xa8\xc3\xa0\xc3\xa7\xc3\xaa\xc3\x88\x00" as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        709 as libc::c_int,
    );
}

unsafe extern "C" fn test_french_utf8() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"test_french_utf8\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        713 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<doc>\xc3\xa9</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa9\x00" as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        721 as libc::c_int,
    );
}
/* Regression test for SF bug #600479.
   XXX There should be a test that exercises all legal XML Unicode
   characters as PCDATA and attribute value content, and XML Name
   characters as part of element and attribute names.
*/

unsafe extern "C" fn test_utf8_false_rejection() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_utf8_false_rejection\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        730 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc>\xef\xba\xbf</doc>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xef\xba\xbf\x00" as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        737 as libc::c_int,
    );
}
/* Regression test for SF bug #477667.
   This test assures that any 8-bit character followed by a 7-bit
   character will not be mistakenly interpreted as a valid UTF-8
   sequence.
*/

unsafe extern "C" fn test_illegal_utf8() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_illegal_utf8\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        746 as libc::c_int,
    );
    let mut text: [libc::c_char; 100] = [0; 100];
    let mut i: libc::c_int = 0;
    i = 128 as libc::c_int;
    while i <= 255 as libc::c_int {
        ::libc::sprintf(
            text.as_mut_ptr(),
            b"<e>%ccd</e>\x00" as *const u8 as *const libc::c_char,
            i,
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text.as_mut_ptr(),
            ::c2rust_out::stdlib::strlen(text.as_mut_ptr()) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
        {
            ::libc::sprintf(
                text.as_mut_ptr(),
                b"expected token error for \'%c\' (ordinal %d) in UTF-8 text\x00" as *const u8
                    as *const libc::c_char,
                i,
                i,
            );
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                756 as libc::c_int,
                text.as_mut_ptr(),
            );
        } else if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN as libc::c_int as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                758 as libc::c_int,
            );
        }
        /* Reset the parser since we use the same parser repeatedly. */
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        i += 1
    }
}
/* Examples, not masks: */

pub const UTF8_LEAD_1: [libc::c_char; 2] =
    unsafe { *::std::mem::transmute::<&[u8; 2], &[libc::c_char; 2]>(b"\x7f\x00") };
/* 0b01111111 */

pub const UTF8_LEAD_2: [libc::c_char; 2] =
    unsafe { *::std::mem::transmute::<&[u8; 2], &[libc::c_char; 2]>(b"\xdf\x00") };
/* 0b11011111 */

pub const UTF8_LEAD_3: [libc::c_char; 2] =
    unsafe { *::std::mem::transmute::<&[u8; 2], &[libc::c_char; 2]>(b"\xef\x00") };
/* 0b11101111 */

pub const UTF8_LEAD_4: [libc::c_char; 2] =
    unsafe { *::std::mem::transmute::<&[u8; 2], &[libc::c_char; 2]>(b"\xf7\x00") };
/* 0b11110111 */
/* 0b10111111 */

unsafe extern "C" fn test_utf8_auto_align() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_utf8_auto_align\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        772 as libc::c_int,
    );
    let mut cases: [TestCase; 11] = [
        {
            let mut init = TestCase {
                expectedMovementInChars: 0 as libc::c_int as crate::stddef_h::ptrdiff_t,
                input: b"\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: 0 as libc::c_int as crate::stddef_h::ptrdiff_t,
                input: UTF8_LEAD_1.as_ptr(),
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: -(1 as libc::c_int) as crate::stddef_h::ptrdiff_t,
                input: UTF8_LEAD_2.as_ptr(),
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: 0 as libc::c_int as crate::stddef_h::ptrdiff_t,
                input: b"\xdf\xbf\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: -(1 as libc::c_int) as crate::stddef_h::ptrdiff_t,
                input: UTF8_LEAD_3.as_ptr(),
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: -(2 as libc::c_int) as crate::stddef_h::ptrdiff_t,
                input: b"\xef\xbf\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: 0 as libc::c_int as crate::stddef_h::ptrdiff_t,
                input: b"\xef\xbf\xbf\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: -(1 as libc::c_int) as crate::stddef_h::ptrdiff_t,
                input: UTF8_LEAD_4.as_ptr(),
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: -(2 as libc::c_int) as crate::stddef_h::ptrdiff_t,
                input: b"\xf7\xbf\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: -(3 as libc::c_int) as crate::stddef_h::ptrdiff_t,
                input: b"\xf7\xbf\xbf\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = TestCase {
                expectedMovementInChars: 0 as libc::c_int as crate::stddef_h::ptrdiff_t,
                input: b"\xf7\xbf\xbf\xbf\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: crate::stddef_h::size_t = 0 as libc::c_int as crate::stddef_h::size_t;
    let mut success: bool = ::c2rust_out::stdbool_h::true_0 != 0;
    while i
        < (::std::mem::size_of::<[TestCase; 11]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<TestCase>() as libc::c_ulong)
    {
        let mut fromLim: *const libc::c_char = cases[i as usize]
            .input
            .offset(::c2rust_out::stdlib::strlen(cases[i as usize].input) as isize);
        let fromLimInitially: *const libc::c_char = fromLim;
        let mut actualMovementInChars: crate::stddef_h::ptrdiff_t = 0;
        ::c2rust_out::src::lib::xmltok::_INTERNAL_trim_to_complete_utf8_characters(
            cases[i as usize].input,
            &mut fromLim,
        );
        actualMovementInChars = fromLim.wrapping_offset_from(fromLimInitially) as libc::c_long;
        if actualMovementInChars != cases[i as usize].expectedMovementInChars {
            let mut j: crate::stddef_h::size_t = 0 as libc::c_int as crate::stddef_h::size_t;
            success = ::c2rust_out::stdbool_h::false_0 != 0;
            ::libc::printf(b"[-] UTF-8 case %2u: Expected movement by %2d chars, actually moved by %2d chars: \"\x00"
                       as *const u8 as *const libc::c_char,
                   i.wrapping_add(1 as libc::c_int as libc::c_ulong) as
                       libc::c_uint,
                   cases[i as usize].expectedMovementInChars as libc::c_int,
                   actualMovementInChars as libc::c_int);
            while j < ::c2rust_out::stdlib::strlen(cases[i as usize].input) {
                ::libc::printf(
                    b"\\x%02x\x00" as *const u8 as *const libc::c_char,
                    *cases[i as usize].input.offset(j as isize) as libc::c_uchar as libc::c_int,
                );
                j = j.wrapping_add(1)
            }
            ::libc::printf(b"\"\n\x00" as *const u8 as *const libc::c_char);
        }
        i = i.wrapping_add(1)
    }
    if !success {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            821 as libc::c_int,
            b"UTF-8 auto-alignment is not bullet-proof\n\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"test_utf16\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        826 as libc::c_int,
    );
    /* <?xml version="1.0" encoding="UTF-16"?>
     *  <doc a='123'>some {A} text</doc>
     *
     * where {A} is U+FF21, FULLWIDTH LATIN CAPITAL LETTER A
     */
    let mut text: [libc::c_char; 141] =
        *::std::mem::transmute::<&[u8; 141],
                                 &mut [libc::c_char; 141]>(b"\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00\'\x00U\x00T\x00F\x00-\x001\x006\x00\'\x00?\x00>\x00\n\x00<\x00d\x00o\x00c\x00 \x00a\x00=\x00\'\x001\x002\x003\x00\'\x00>\x00s\x00o\x00m\x00e\x00 \xff!\x00 \x00t\x00e\x00x\x00t\x00<\x00/\x00d\x00o\x00c\x00>\x00"); /* epilog */
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"some \xef\xbc\xa1 text\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_mut_ptr(),
        (::std::mem::size_of::<[libc::c_char; 141]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            852 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_utf16_le_epilog_newline() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_utf16_le_epilog_newline\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        857 as libc::c_int,
    );
    let mut first_chunk_bytes: libc::c_uint = 17 as libc::c_int as libc::c_uint;
    let mut text: [libc::c_char; 19] = *::std::mem::transmute::<&[u8; 19], &mut [libc::c_char; 19]>(
        b"\xff\xfe<\x00e\x00/\x00>\x00\r\x00\n\x00\r\x00\n\x00\x00",
    );
    if first_chunk_bytes as libc::c_ulong
        >= (::std::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            864 as libc::c_int,
            b"bad value of first_chunk_bytes\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_mut_ptr(),
        first_chunk_bytes as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            867 as libc::c_int,
        );
    } else {
        let mut rc: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
        rc = _XML_Parse_SINGLE_BYTES(
            g_parser,
            text.as_mut_ptr().offset(first_chunk_bytes as isize),
            (::std::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong)
                .wrapping_sub(first_chunk_bytes as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        );
        if rc as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                874 as libc::c_int,
            );
        }
    };
}
/* Test that an outright lie in the encoding is faulted */

unsafe extern "C" fn test_not_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"test_not_utf16\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        880 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-16\'?><doc>Hi</doc>\x00" as *const u8
            as *const libc::c_char;
    /* Use a handler to provoke the appropriate code paths */
    ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
        g_parser,
        Some(
            dummy_xdecl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INCORRECT_ENCODING,
        b"UTF-16 declared in UTF-8 not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        887 as libc::c_int,
    );
}
/* Test that an unknown encoding is rejected */

unsafe extern "C" fn test_bad_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_bad_encoding\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        892 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc>Hi</doc>\x00" as *const u8 as *const libc::c_char;
    if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(
        g_parser,
        b"unknown-encoding\x00" as *const u8 as *const libc::c_char,
    ) as u64
        == 0
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            896 as libc::c_int,
            b"XML_SetEncoding failed\x00" as *const u8 as *const libc::c_char,
        );
    }
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        b"Unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        898 as libc::c_int,
    );
}
/* Regression test for SF bug #481609, #774028. */

unsafe extern "C" fn test_latin1_umlauts() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_latin1_umlauts\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        903 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?>\n<e a=\'\xe4 \xf6 \xfc &#228; &#246; &#252; &#x00E4; &#x0F6; &#xFC; >\'\n  >\xe4 \xf6 \xfc &#228; &#246; &#252; &#x00E4; &#x0F6; &#xFC; ></e>\x00"
            as *const u8 as *const libc::c_char;
    /* Expected results in UTF-8 */
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa4 \xc3\xb6 \xc3\xbc \xc3\xa4 \xc3\xb6 \xc3\xbc \xc3\xa4 \xc3\xb6 \xc3\xbc >\x00"
            as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        918 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    _run_attribute_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        920 as libc::c_int,
    );
    /* Repeat with a default handler */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            dummy_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        924 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            dummy_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    _run_attribute_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        927 as libc::c_int,
    );
}
/* Test that an element name with a 4-byte UTF-8 character is rejected */

unsafe extern "C" fn test_long_utf8_character() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_long_utf8_character\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        932 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<do\xf0\x90\x80\x80/>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"4-byte UTF-8 character in element name not faulted\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        938 as libc::c_int,
    );
}
/* Test that a long latin-1 attribute (too long to convert in one go)
 * is correctly converted
 */

unsafe extern "C" fn test_long_latin1_attribute() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_long_latin1_attribute\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        945 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?>\n<doc att=\'ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO\xe4\'>\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO\xc3\xa4\x00"
            as *const u8 as *const libc::c_char;
    _run_attribute_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        995 as libc::c_int,
    );
}
/* Test that a long ASCII attribute (too long to convert in one go)
 * is correctly converted
 */

unsafe extern "C" fn test_long_ascii_attribute() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_long_ascii_attribute\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1002 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<doc att=\'ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP01234\'>\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP01234\x00"
            as *const u8 as *const libc::c_char;
    /* clang-format on */
    _run_attribute_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1046 as libc::c_int,
    );
}
/* Regression test #1 for SF bug #653180. */

unsafe extern "C" fn test_line_number_after_parse() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_line_number_after_parse\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1051 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<tag>\n\n\n</tag>\x00" as *const u8 as *const libc::c_char;
    let mut lineno: crate::expat_external_h::XML_Size = 0;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1059 as libc::c_int,
        );
    }
    lineno = ::c2rust_out::src::lib::xmlparse::XML_GetCurrentLineNumber(g_parser);
    if lineno != 4 as libc::c_int as libc::c_ulong {
        let mut buffer: [libc::c_char; 100] = [0; 100];
        ::libc::sprintf(
            buffer.as_mut_ptr(),
            b"expected 4 lines, saw %lu\x00" as *const u8 as *const libc::c_char,
            lineno,
        );
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1064 as libc::c_int,
            buffer.as_mut_ptr(),
        );
    };
}
/* Regression test #2 for SF bug #653180. */

unsafe extern "C" fn test_column_number_after_parse() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_column_number_after_parse\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1070 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<tag></tag>\x00" as *const u8 as *const libc::c_char;
    let mut colno: crate::expat_external_h::XML_Size = 0;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1076 as libc::c_int,
        );
    }
    colno = ::c2rust_out::src::lib::xmlparse::XML_GetCurrentColumnNumber(g_parser);
    if colno != 11 as libc::c_int as libc::c_ulong {
        let mut buffer: [libc::c_char; 100] = [0; 100];
        ::libc::sprintf(
            buffer.as_mut_ptr(),
            b"expected 11 columns, saw %lu\x00" as *const u8 as *const libc::c_char,
            colno,
        );
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1081 as libc::c_int,
            buffer.as_mut_ptr(),
        );
    };
}

pub const STRUCT_START_TAG: libc::c_int = 0 as libc::c_int;

pub const STRUCT_END_TAG: libc::c_int = 1 as libc::c_int;

unsafe extern "C" fn start_element_event_handler2(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
    mut _attr: *mut *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::structdata::StructData =
        userData as *mut ::c2rust_out::src::tests::structdata::StructData;
    ::c2rust_out::src::tests::structdata::StructData_AddItem(
        storage as *mut ::c2rust_out::src::tests::structdata::StructData,
        name,
        ::c2rust_out::src::lib::xmlparse::XML_GetCurrentColumnNumber(g_parser) as libc::c_int,
        ::c2rust_out::src::lib::xmlparse::XML_GetCurrentLineNumber(g_parser) as libc::c_int,
        STRUCT_START_TAG,
    );
}

unsafe extern "C" fn end_element_event_handler2(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::structdata::StructData =
        userData as *mut ::c2rust_out::src::tests::structdata::StructData;
    ::c2rust_out::src::tests::structdata::StructData_AddItem(
        storage as *mut ::c2rust_out::src::tests::structdata::StructData,
        name,
        ::c2rust_out::src::lib::xmlparse::XML_GetCurrentColumnNumber(g_parser) as libc::c_int,
        ::c2rust_out::src::lib::xmlparse::XML_GetCurrentLineNumber(g_parser) as libc::c_int,
        STRUCT_END_TAG,
    );
}
/* Regression test #3 for SF bug #653180. */

unsafe extern "C" fn test_line_and_column_numbers_inside_handlers() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 45], &[libc::c_char; 45]>(
            b"test_line_and_column_numbers_inside_handlers\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1105 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<a>\n  <b>\r\n    <c/>\r  </b>\n  <d>\n    <f/>\n  </d>\n</a>\x00" as *const u8
            as *const libc::c_char;
    let expected: [::c2rust_out::src::tests::structdata::StructDataEntry; 10] = [
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"a\x00" as *const u8 as *const libc::c_char,
                data0: 0 as libc::c_int,
                data1: 1 as libc::c_int,
                data2: STRUCT_START_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"b\x00" as *const u8 as *const libc::c_char,
                data0: 2 as libc::c_int,
                data1: 2 as libc::c_int,
                data2: STRUCT_START_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"c\x00" as *const u8 as *const libc::c_char,
                data0: 4 as libc::c_int,
                data1: 3 as libc::c_int,
                data2: STRUCT_START_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"c\x00" as *const u8 as *const libc::c_char,
                data0: 8 as libc::c_int,
                data1: 3 as libc::c_int,
                data2: STRUCT_END_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"b\x00" as *const u8 as *const libc::c_char,
                data0: 2 as libc::c_int,
                data1: 4 as libc::c_int,
                data2: STRUCT_END_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"d\x00" as *const u8 as *const libc::c_char,
                data0: 2 as libc::c_int,
                data1: 5 as libc::c_int,
                data2: STRUCT_START_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"f\x00" as *const u8 as *const libc::c_char,
                data0: 4 as libc::c_int,
                data1: 6 as libc::c_int,
                data2: STRUCT_START_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"f\x00" as *const u8 as *const libc::c_char,
                data0: 8 as libc::c_int,
                data1: 6 as libc::c_int,
                data2: STRUCT_END_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"d\x00" as *const u8 as *const libc::c_char,
                data0: 2 as libc::c_int,
                data1: 7 as libc::c_int,
                data2: STRUCT_END_TAG,
            };
            init
        },
        {
            let mut init = ::c2rust_out::src::tests::structdata::StructDataEntry {
                str_0: b"a\x00" as *const u8 as *const libc::c_char,
                data0: 0 as libc::c_int,
                data1: 8 as libc::c_int,
                data2: STRUCT_END_TAG,
            };
            init
        },
    ];
    let expected_count: libc::c_int = (::std::mem::size_of::<
        [::c2rust_out::src::tests::structdata::StructDataEntry; 10],
    >() as libc::c_ulong)
        .wrapping_div(
            ::std::mem::size_of::<::c2rust_out::src::tests::structdata::StructDataEntry>()
                as libc::c_ulong,
        ) as libc::c_int;
    let mut storage: ::c2rust_out::src::tests::structdata::StructData =
        ::c2rust_out::src::tests::structdata::StructData {
            count: 0,
            max_count: 0,
            entries: 0 as *mut ::c2rust_out::src::tests::structdata::StructDataEntry,
        };
    ::c2rust_out::src::tests::structdata::StructData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::structdata::StructData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::structdata::StructData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            start_element_event_handler2
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndElementHandler(
        g_parser,
        Some(
            end_element_event_handler2
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1129 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::structdata::StructData_CheckItems(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::structdata::StructData,
        expected.as_ptr() as *const ::c2rust_out::src::tests::structdata::StructDataEntry,
        expected_count,
    );
    ::c2rust_out::src::tests::structdata::StructData_Dispose(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::structdata::StructData,
    );
}
/* Regression test #4 for SF bug #653180. */

unsafe extern "C" fn test_line_number_after_error() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_line_number_after_error\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1137 as libc::c_int,
    ); /* missing </b> */
    let mut text: *const libc::c_char =
        b"<a>\n  <b>\n  </a>\x00" as *const u8 as *const libc::c_char;
    let mut lineno: crate::expat_external_h::XML_Size = 0;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1144 as libc::c_int,
            b"Expected a parse error\x00" as *const u8 as *const libc::c_char,
        );
    }
    lineno = ::c2rust_out::src::lib::xmlparse::XML_GetCurrentLineNumber(g_parser);
    if lineno != 3 as libc::c_int as libc::c_ulong {
        let mut buffer: [libc::c_char; 100] = [0; 100];
        ::libc::sprintf(
            buffer.as_mut_ptr(),
            b"expected 3 lines, saw %lu\x00" as *const u8 as *const libc::c_char,
            lineno,
        );
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1150 as libc::c_int,
            buffer.as_mut_ptr(),
        );
    };
}
/* Regression test #5 for SF bug #653180. */

unsafe extern "C" fn test_column_number_after_error() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_column_number_after_error\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1156 as libc::c_int,
    ); /* missing </b> */
    let mut text: *const libc::c_char =
        b"<a>\n  <b>\n  </a>\x00" as *const u8 as *const libc::c_char;
    let mut colno: crate::expat_external_h::XML_Size = 0;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1163 as libc::c_int,
            b"Expected a parse error\x00" as *const u8 as *const libc::c_char,
        );
    }
    colno = ::c2rust_out::src::lib::xmlparse::XML_GetCurrentColumnNumber(g_parser);
    if colno != 4 as libc::c_int as libc::c_ulong {
        let mut buffer: [libc::c_char; 100] = [0; 100];
        ::libc::sprintf(
            buffer.as_mut_ptr(),
            b"expected 4 columns, saw %lu\x00" as *const u8 as *const libc::c_char,
            colno,
        );
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1169 as libc::c_int,
            buffer.as_mut_ptr(),
        );
    };
}
/* Regression test for SF bug #478332. */

unsafe extern "C" fn test_really_long_lines() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_really_long_lines\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1175 as libc::c_int,
    );
    /* This parses an input line longer than INIT_DATA_BUF_SIZE
       characters long (defined to be 1024 in xmlparse.c).  We take a
       really cheesy approach to building the input buffer, because
       this avoids writing bugs in buffer-filling code.
    */
    let mut text: *const libc::c_char =
        b"<e>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+</e>\x00"
            as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1205 as libc::c_int,
        );
    };
}
/* Test cdata processing across a buffer boundary */

unsafe extern "C" fn test_really_long_encoded_lines() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_really_long_encoded_lines\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1210 as libc::c_int,
    );
    /* As above, except that we want to provoke an output buffer
     * overflow with a non-trivial encoding.  For this we need to pass
     * the whole cdata in one go, not byte-by-byte.
     */
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?><e>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+</e>\x00"
            as *const u8 as *const libc::c_char;
    let mut parse_len: libc::c_int = ::c2rust_out::stdlib::strlen(text) as libc::c_int;
    /* Need a cdata handler to provoke the code path we want to test */
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            dummy_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(g_parser, parse_len);
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1245 as libc::c_int,
            b"Could not allocate parse buffer\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !buffer.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"buffer != NULL\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1246 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 42], &[libc::c_char; 42]>(
                b"void test_really_long_encoded_lines(void)\x00",
            ))
            .as_ptr(),
        );
    }
    ::c2rust_out::stdlib::memcpy(
        buffer,
        text as *const libc::c_void,
        parse_len as libc::c_ulong,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        parse_len,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1249 as libc::c_int,
        );
    };
}
/*
 * Element event tests.
 */

unsafe extern "C" fn start_element_event_handler(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
    mut _atts: *mut *const crate::expat_external_h::XML_Char,
) {
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        userData as *mut ::c2rust_out::src::tests::chardata::CharData
            as *mut ::c2rust_out::src::tests::chardata::CharData,
        name,
        -(1 as libc::c_int),
    );
}

unsafe extern "C" fn end_element_event_handler(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"/\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        name,
        -(1 as libc::c_int),
    );
}

unsafe extern "C" fn test_end_element_events() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_end_element_events\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1271 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<a><b><c/></b><d><f/></d></a>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"/c/b/f/d/a\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndElementHandler(
        g_parser,
        Some(
            end_element_event_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1281 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/*
 * Attribute tests.
 */
/* Helpers used by the following test; this checks any "attr" and "refs"
   attributes to make sure whitespace has been normalized.

   Return true if whitespace has been normalized in a string, using
   the rules for attribute value normalization.  The 'is_cdata' flag
   is needed since CDATA attributes don't need to have multiple
   whitespace characters collapsed to a single space, while other
   attribute data types do.  (Section 3.3.3 of the recommendation.)
*/

unsafe extern "C" fn is_whitespace_normalized(
    mut s: *const crate::expat_external_h::XML_Char,
    mut is_cdata: libc::c_int,
) -> libc::c_int {
    let mut blanks: libc::c_int = 0 as libc::c_int;
    let mut at_start: libc::c_int = 1 as libc::c_int;
    while *s != 0 {
        if *s as libc::c_int == ' ' as i32 {
            blanks += 1
        } else if *s as libc::c_int == '\t' as i32
            || *s as libc::c_int == '\n' as i32
            || *s as libc::c_int == '\r' as i32
        {
            return 0 as libc::c_int;
        } else {
            if at_start != 0 {
                at_start = 0 as libc::c_int;
                if blanks != 0 && is_cdata == 0 {
                    /* illegal leading blanks */
                    return 0 as libc::c_int;
                }
            } else if blanks > 1 as libc::c_int && is_cdata == 0 {
                return 0 as libc::c_int;
            }
            blanks = 0 as libc::c_int
        }
        s = s.offset(1)
    }
    if blanks != 0 && is_cdata == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
/* Check the attribute whitespace checker: */

unsafe extern "C" fn testhelper_is_whitespace_normalized() {
    if is_whitespace_normalized(
        b"abc\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\"abc\"), 0)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1328 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\"abc\"), 1)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1329 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc def ghi\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\"abc def ghi\"), 0)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1330 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc def ghi\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\"abc def ghi\"), 1)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1331 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b" abc def ghi\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\" abc def ghi\"), 0)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1332 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b" abc def ghi\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\" abc def ghi\"), 1)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1333 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc  def ghi\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"abc  def ghi\"), 0)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1334 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc  def ghi\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\"abc  def ghi\"), 1)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1335 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc def ghi \x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"abc def ghi \"), 0)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1336 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc def ghi \x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\"abc def ghi \"), 1)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1337 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b" \x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\" \"), 0)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1338 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b" \x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) != 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"is_whitespace_normalized(XCS(\" \"), 1)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1339 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"\t\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"\\t\"), 0)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1340 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"\t\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"\\t\"), 1)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1341 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"\n\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"\\n\"), 0)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1342 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"\n\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"\\n\"), 1)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1343 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"\r\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"\\r\"), 0)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1344 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"\r\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"\\r\"), 1)\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1345 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if is_whitespace_normalized(
        b"abc\t def\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ) == 0
    {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"! is_whitespace_normalized(XCS(\"abc\\t def\"), 1)\x00" as *const u8
                as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1346 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 47], &[libc::c_char; 47]>(
                b"void testhelper_is_whitespace_normalized(void)\x00",
            ))
            .as_ptr(),
        );
    };
}

unsafe extern "C" fn check_attr_contains_normalized_whitespace(
    mut _userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut atts: *mut *const crate::expat_external_h::XML_Char,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !(*atts.offset(i as isize)).is_null() {
        let mut attrname: *const crate::expat_external_h::XML_Char = *atts.offset(i as isize);
        let mut value: *const crate::expat_external_h::XML_Char =
            *atts.offset((i + 1 as libc::c_int) as isize);
        if ::libc::strcmp(b"attr\x00" as *const u8 as *const libc::c_char, attrname)
            == 0 as libc::c_int
            || ::libc::strcmp(b"ents\x00" as *const u8 as *const libc::c_char, attrname)
                == 0 as libc::c_int
            || ::libc::strcmp(b"refs\x00" as *const u8 as *const libc::c_char, attrname)
                == 0 as libc::c_int
        {
            if is_whitespace_normalized(value, 0 as libc::c_int) == 0 {
                let mut buffer: [libc::c_char; 256] = [0; 256];
                ::libc::sprintf(
                    buffer.as_mut_ptr(),
                    b"attribute value not normalized: %s=\'%s\'\x00" as *const u8
                        as *const libc::c_char,
                    attrname,
                    value,
                );
                ::c2rust_out::src::tests::minicheck::_fail_unless(
                    0 as libc::c_int,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    1367 as libc::c_int,
                    buffer.as_mut_ptr(),
                );
            }
        }
        i += 2 as libc::c_int
    }
}

unsafe extern "C" fn test_attr_whitespace_normalization() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_attr_whitespace_normalization\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1373 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ATTLIST doc\n            attr NMTOKENS #REQUIRED\n            ents ENTITIES #REQUIRED\n            refs IDREFS   #REQUIRED>\n]>\n<doc attr=\'    a  b c\t\td\te\t\' refs=\' id-1   \t  id-2\t\t\'  \n     ents=\' ent-1   \t\r\n            ent-2  \' >\n  <e id=\'id-1\'/>\n  <e id=\'id-2\'/>\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            check_attr_contains_normalized_whitespace
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1392 as libc::c_int,
        );
    };
}
/*
 * XML declaration tests.
 */

unsafe extern "C" fn test_xmldecl_misplaced() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_xmldecl_misplaced\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1400 as libc::c_int,
    );
    _expect_failure(
        b"\n<?xml version=\'1.0\'?>\n<a/>\x00" as *const u8 as *const libc::c_char,
        ::c2rust_out::expat_h::XML_ERROR_MISPLACED_XML_PI,
        b"failed to report misplaced XML declaration\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1405 as libc::c_int,
    );
}

unsafe extern "C" fn test_xmldecl_invalid() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_xmldecl_invalid\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1409 as libc::c_int,
    );
    _expect_failure(
        b"<?xml version=\'1.0\' \xc3\xa7?>\n<doc/>\x00" as *const u8 as *const libc::c_char,
        ::c2rust_out::expat_h::XML_ERROR_XML_DECL,
        b"Failed to report invalid XML declaration\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1411 as libc::c_int,
    );
}

unsafe extern "C" fn test_xmldecl_missing_attr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_xmldecl_missing_attr\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1415 as libc::c_int,
    );
    _expect_failure(
        b"<?xml =\'1.0\'?>\n<doc/>\n\x00" as *const u8 as *const libc::c_char,
        ::c2rust_out::expat_h::XML_ERROR_XML_DECL,
        b"Failed to report missing XML declaration attribute\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1417 as libc::c_int,
    );
}

unsafe extern "C" fn test_xmldecl_missing_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_xmldecl_missing_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1421 as libc::c_int,
    );
    _expect_failure(
        b"<?xml version=\'1.0\' encoding=\'us-ascii\' standalone?>\n<doc/>\x00" as *const u8
            as *const libc::c_char,
        ::c2rust_out::expat_h::XML_ERROR_XML_DECL,
        b"Failed to report missing attribute value\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1425 as libc::c_int,
    );
}
/* Regression test for SF bug #584832. */

unsafe extern "C" fn UnknownEncodingHandler(
    mut _data: *mut libc::c_void,
    mut encoding: *const crate::expat_external_h::XML_Char,
    mut info: *mut ::c2rust_out::expat_h::XML_Encoding,
) -> libc::c_int {
    if ::libc::strcmp(
        encoding,
        b"unsupported-encoding\x00" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int
    {
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < 256 as libc::c_int {
            (*info).map[i as usize] = i;
            i += 1
        }
        (*info).data = ::c2rust_out::stddef_h::NULL as *mut libc::c_void;
        (*info).convert = ::std::mem::transmute::<
            libc::intptr_t,
            Option<
                unsafe extern "C" fn(_: *mut libc::c_void, _: *const libc::c_char) -> libc::c_int,
            >,
        >(::c2rust_out::stddef_h::NULL as libc::intptr_t);
        (*info).release = ::std::mem::transmute::<
            libc::intptr_t,
            Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
        >(::c2rust_out::stddef_h::NULL as libc::intptr_t);
        return ::c2rust_out::expat_h::XML_STATUS_OK_0;
    }
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}

unsafe extern "C" fn test_unknown_encoding_internal_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 38], &[libc::c_char; 38]>(
            b"test_unknown_encoding_internal_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1446 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'unsupported-encoding\'?>\n<!DOCTYPE test [<!ENTITY foo \'bar\'>]>\n<test a=\'&foo;\'/>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            UnknownEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1454 as libc::c_int,
        );
    };
}
/* Test unrecognised encoding handler */

unsafe extern "C" fn dummy_release(mut _data: *mut libc::c_void) {}

unsafe extern "C" fn UnrecognisedEncodingHandler(
    mut _data: *mut libc::c_void,
    mut _encoding: *const crate::expat_external_h::XML_Char,
    mut info: *mut ::c2rust_out::expat_h::XML_Encoding,
) -> libc::c_int {
    (*info).data = ::c2rust_out::stddef_h::NULL as *mut libc::c_void;
    (*info).convert = ::std::mem::transmute::<
        libc::intptr_t,
        Option<unsafe extern "C" fn(_: *mut libc::c_void, _: *const libc::c_char) -> libc::c_int>,
    >(::c2rust_out::stddef_h::NULL as libc::intptr_t);
    (*info).release = Some(dummy_release as unsafe extern "C" fn(_: *mut libc::c_void) -> ());
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}

unsafe extern "C" fn test_unrecognised_encoding_internal_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 43], &[libc::c_char; 43]>(
            b"test_unrecognised_encoding_internal_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1475 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'unsupported-encoding\'?>\n<!DOCTYPE test [<!ENTITY foo \'bar\'>]>\n<test a=\'&foo;\'/>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            UnrecognisedEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1483 as libc::c_int,
            b"Unrecognised encoding not rejected\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Regression test for SF bug #620106. */

unsafe extern "C" fn external_entity_loader(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut test_data: *mut ExtTest = *(parser as *mut *mut libc::c_void) as *mut ExtTest;
    let mut extparser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    extparser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if extparser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1500 as libc::c_int,
            b"Could not create external entity parser.\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !(*test_data).encoding.is_null() {
        if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(extparser, (*test_data).encoding)
            as u64
            == 0
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                1503 as libc::c_int,
                b"XML_SetEncoding() ignored for external entity\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if _XML_Parse_SINGLE_BYTES(
        extparser,
        (*test_data).parse_text,
        ::c2rust_out::stdlib::strlen((*test_data).parse_text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            extparser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1508 as libc::c_int,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(extparser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ext_entity_set_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_ext_entity_set_encoding\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1515 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<?xml encoding=\'iso-8859-3\'?>\xc3\xa9\x00" as *const u8
                as *const libc::c_char,
            encoding: b"utf-8\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa9\x00" as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _run_ext_character_check(
        text,
        &mut test_data,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1532 as libc::c_int,
    );
}
/* Test external entities with no handler */

unsafe extern "C" fn test_ext_entity_no_handler() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_ext_entity_no_handler\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1537 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            dummy_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    _run_character_check(
        text,
        b"\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1544 as libc::c_int,
    );
}
/* Test UTF-8 BOM is accepted */

unsafe extern "C" fn test_ext_entity_set_bom() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_ext_entity_set_bom\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1549 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"\xef\xbb\xbf<?xml encoding=\'iso-8859-3\'?>\xc3\xa9\x00" as *const u8
                as *const libc::c_char,
            encoding: b"utf-8\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa9\x00" as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _run_ext_character_check(
        text,
        &mut test_data,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1565 as libc::c_int,
    );
}

unsafe extern "C" fn external_entity_faulter(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut fault: *mut ExtFaults = *(parser as *mut *mut libc::c_void) as *mut ExtFaults;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1589 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !(*fault).encoding.is_null() {
        if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(ext_parser, (*fault).encoding) as u64
            == 0
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                1592 as libc::c_int,
                b"XML_SetEncoding failed\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        (*fault).parse_text,
        ::c2rust_out::stdlib::strlen((*fault).parse_text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1597 as libc::c_int,
            (*fault).fail_text,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
        != (*fault).error as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1599 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}

unsafe extern "C" fn test_ext_entity_bad_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_ext_entity_bad_encoding\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1605 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut fault: ExtFaults = {
        let mut init = ext_faults {
            parse_text: b"<?xml encoding=\'iso-8859-3\'?>u\x00" as *const u8 as *const libc::c_char,
            fail_text: b"Unsupported encoding not faulted\x00" as *const u8 as *const libc::c_char,
            encoding: b"unknown\x00" as *const u8 as *const libc::c_char,
            error: ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_faulter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut fault as *mut ExtFaults as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Bad encoding should not have been accepted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1617 as libc::c_int,
    );
}
/* Try handing an invalid encoding to an external entity parser */

unsafe extern "C" fn test_ext_entity_bad_encoding_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_ext_entity_bad_encoding_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1622 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut fault: ExtFaults = {
        let mut init = ext_faults {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            fail_text: b"Unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
            encoding: b"unknown-encoding\x00" as *const u8 as *const libc::c_char,
            error: ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_faulter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut fault as *mut ExtFaults as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Bad encoding not faulted in external entity handler\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1634 as libc::c_int,
    );
}
/* Test that no error is reported for unknown entities if we don't
   read an external subset.  This was fixed in Expat 1.95.5.
*/

unsafe extern "C" fn test_wfc_undeclared_entity_unread_external_subset() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 50], &[libc::c_char; 50]>(
            b"test_wfc_undeclared_entity_unread_external_subset\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1641 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
        as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1647 as libc::c_int,
        );
    };
}
/* Test that an error is reported for unknown entities if we don't
   have an external subset.
*/

unsafe extern "C" fn test_wfc_undeclared_entity_no_external_subset() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 46], &[libc::c_char; 46]>(
            b"test_wfc_undeclared_entity_no_external_subset\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1654 as libc::c_int,
    );
    _expect_failure(
        b"<doc>&entity;</doc>\x00" as *const u8 as *const libc::c_char,
        ::c2rust_out::expat_h::XML_ERROR_UNDEFINED_ENTITY,
        b"Parser did not report undefined entity w/out a DTD.\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1656 as libc::c_int,
    );
}
/* Test that an error is reported for unknown entities if we don't
   read an external subset, but have been declared standalone.
*/

unsafe extern "C" fn test_wfc_undeclared_entity_standalone() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 38], &[libc::c_char; 38]>(
            b"test_wfc_undeclared_entity_standalone\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1663 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\' standalone=\'yes\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNDEFINED_ENTITY,
        b"Parser did not report undefined entity (standalone).\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1670 as libc::c_int,
    );
}
/* Test that an error is reported for unknown entities if we have read
   an external subset, and standalone is true.
*/

unsafe extern "C" fn test_wfc_undeclared_entity_with_external_subset_standalone() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 59], &[libc::c_char; 59]>(
            b"test_wfc_undeclared_entity_with_external_subset_standalone\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1677 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\' standalone=\'yes\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNDEFINED_ENTITY,
        b"Parser did not report undefined entity (external DTD).\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1688 as libc::c_int,
    );
}
/* Test that external entity handling is not done if the parsing flag
 * is set to UNLESS_STANDALONE
 */

unsafe extern "C" fn test_entity_with_external_subset_unless_standalone() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 51], &[libc::c_char; 51]>(
            b"test_entity_with_external_subset_unless_standalone\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1695 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\' standalone=\'yes\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ENTITY entity \'bar\'>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNDEFINED_ENTITY,
        b"Parser did not report undefined entity\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1707 as libc::c_int,
    );
}
/* Test that no error is reported for unknown entities if we have read
   an external subset, and standalone is false.
*/

unsafe extern "C" fn test_wfc_undeclared_entity_with_external_subset() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 48], &[libc::c_char; 48]>(
            b"test_wfc_undeclared_entity_with_external_subset\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1714 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _run_ext_character_check(
        text,
        &mut test_data,
        b"\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1722 as libc::c_int,
    );
}
/* Test that an error is reported if our NotStandalone handler fails */

unsafe extern "C" fn reject_not_standalone_handler(mut _userData: *mut libc::c_void) -> libc::c_int {
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}

unsafe extern "C" fn test_not_standalone_handler_reject() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_not_standalone_handler_reject\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1733 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetNotStandaloneHandler(
        g_parser,
        Some(
            reject_not_standalone_handler
                as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int,
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_NOT_STANDALONE,
        b"NotStandalone handler failed to reject\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1744 as libc::c_int,
    );
    /* Try again but without external entity handling */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetNotStandaloneHandler(
        g_parser,
        Some(
            reject_not_standalone_handler
                as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int,
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_NOT_STANDALONE,
        b"NotStandalone handler failed to reject\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1750 as libc::c_int,
    );
}
/* Test that no error is reported if our NotStandalone handler succeeds */

unsafe extern "C" fn accept_not_standalone_handler(mut _userData: *mut libc::c_void) -> libc::c_int {
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_not_standalone_handler_accept() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_not_standalone_handler_accept\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1761 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetNotStandaloneHandler(
        g_parser,
        Some(
            accept_not_standalone_handler
                as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int,
        ),
    );
    _run_ext_character_check(
        text,
        &mut test_data,
        b"\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1770 as libc::c_int,
    );
    /* Repeat wtihout the external entity handler */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetNotStandaloneHandler(
        g_parser,
        Some(
            accept_not_standalone_handler
                as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int,
        ),
    );
    _run_character_check(
        text,
        b"\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1775 as libc::c_int,
    );
}

unsafe extern "C" fn test_wfc_no_recursive_entity_refs() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_wfc_no_recursive_entity_refs\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1779 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY entity \'&#38;entity;\'>\n]>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_RECURSIVE_ENTITY_REF,
        b"Parser did not report recursive entity reference.\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1786 as libc::c_int,
    );
}
/* Test incomplete external entities are faulted */

unsafe extern "C" fn test_ext_entity_invalid_parse() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_ext_entity_invalid_parse\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1791 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let faults: [ExtFaults; 4] = [
        {
            let mut init = ext_faults {
                parse_text: b"<\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Incomplete element declaration not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<\xe2\x82\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Incomplete character not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<tag>\xe2\x82\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Incomplete character in CDATA not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                fail_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_NONE,
            };
            init
        },
    ];
    let mut fault: *const ExtFaults = faults.as_ptr();
    while !(*fault).parse_text.is_null() {
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_faulter
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(g_parser, fault as *mut libc::c_void);
        _expect_failure(
            text,
            ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
            b"Parser did not report external entity error\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1811 as libc::c_int,
        );
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        fault = fault.offset(1)
    }
}
/* Regression test for SF bug #483514. */

unsafe extern "C" fn test_dtd_default_handling() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_dtd_default_handling\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1818 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY e SYSTEM \'http://example.org/e\'>\n<!NOTATION n SYSTEM \'http://example.org/n\'>\n<!ELEMENT doc EMPTY>\n<!ATTLIST doc a CDATA #IMPLIED>\n<?pi in dtd?>\n<!--comment in dtd-->\n]><doc/>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartDoctypeDeclHandler(
        g_parser,
        Some(
            dummy_start_doctype_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndDoctypeDeclHandler(
        g_parser,
        Some(dummy_end_doctype_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
        g_parser,
        Some(
            dummy_entity_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetNotationDeclHandler(
        g_parser,
        Some(
            dummy_notation_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            dummy_element_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
        g_parser,
        Some(
            dummy_attlist_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
        g_parser,
        Some(
            dummy_pi_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
        g_parser,
        Some(
            dummy_comment_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartCdataSectionHandler(
        g_parser,
        Some(dummy_start_cdata_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndCdataSectionHandler(
        g_parser,
        Some(dummy_end_cdata_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    _run_character_check(
        text,
        b"\n\n\n\n\n\n\n<doc/>\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1839 as libc::c_int,
    );
}

unsafe extern "C" fn verify_attlist_decl_handler(
    mut userData: *mut libc::c_void,
    mut element_name: *const crate::expat_external_h::XML_Char,
    mut attr_name: *const crate::expat_external_h::XML_Char,
    mut attr_type: *const crate::expat_external_h::XML_Char,
    mut default_value: *const crate::expat_external_h::XML_Char,
    mut is_required: libc::c_int,
) {
    let mut at: *mut AttTest = userData as *mut AttTest;
    if ::libc::strcmp(element_name, (*at).element_name) != 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1861 as libc::c_int,
            b"Unexpected element name in attribute declaration\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if ::libc::strcmp(attr_name, (*at).attr_name) != 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1863 as libc::c_int,
            b"Unexpected attribute name in attribute declaration\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if ::libc::strcmp(attr_type, (*at).attr_type) != 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1865 as libc::c_int,
            b"Unexpected attribute type in attribute declaration\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if default_value.is_null() && !(*at).default_value.is_null()
        || !default_value.is_null() && (*at).default_value.is_null()
        || !default_value.is_null() && ::libc::strcmp(default_value, (*at).default_value) != 0
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1869 as libc::c_int,
            b"Unexpected default value in attribute declaration\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if is_required != (*at).is_required {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1871 as libc::c_int,
            b"Requirement mismatch in attribute declaration\x00" as *const u8
                as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_dtd_attr_handling() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_dtd_attr_handling\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1874 as libc::c_int,
    );
    let mut prolog: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc EMPTY>\n\x00" as *const u8 as *const libc::c_char;
    let mut attr_data: [AttTest; 5] = [
        {
            let mut init = AttTest {
                definition:
                    b"<!ATTLIST doc a ( one | two | three ) #REQUIRED>\n]><doc a=\'two\'/>\x00"
                        as *const u8 as *const libc::c_char,
                element_name: b"doc\x00" as *const u8 as *const libc::c_char,
                attr_name: b"a\x00" as *const u8 as *const libc::c_char,
                attr_type: b"(one|two|three)\x00" as *const u8 as *const libc::c_char,
                default_value: ::c2rust_out::stddef_h::NULL
                    as *const crate::expat_external_h::XML_Char,
                is_required: ::c2rust_out::expat_h::XML_TRUE,
            };
            init
        },
        {
            let mut init =
                 AttTest{definition:
                             b"<!NOTATION foo SYSTEM \'http://example.org/foo\'>\n<!ATTLIST doc a NOTATION (foo) #IMPLIED>\n]><doc/>\x00"
                                 as *const u8 as *const libc::c_char,
                         element_name:
                             b"doc\x00" as *const u8 as *const libc::c_char,
                         attr_name:
                             b"a\x00" as *const u8 as *const libc::c_char,
                         attr_type:
                             b"NOTATION(foo)\x00" as *const u8 as
                                 *const libc::c_char,
                         default_value: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                         is_required: ::c2rust_out::expat_h::XML_FALSE,};
            init
        },
        {
            let mut init = AttTest {
                definition: b"<!ATTLIST doc a NOTATION (foo) \'bar\'>\n]><doc/>\x00" as *const u8
                    as *const libc::c_char,
                element_name: b"doc\x00" as *const u8 as *const libc::c_char,
                attr_name: b"a\x00" as *const u8 as *const libc::c_char,
                attr_type: b"NOTATION(foo)\x00" as *const u8 as *const libc::c_char,
                default_value: b"bar\x00" as *const u8 as *const libc::c_char,
                is_required: ::c2rust_out::expat_h::XML_FALSE,
            };
            init
        },
        {
            let mut init = AttTest {
                definition: b"<!ATTLIST doc a CDATA \'\xdb\xb2\'>\n]><doc/>\x00" as *const u8
                    as *const libc::c_char,
                element_name: b"doc\x00" as *const u8 as *const libc::c_char,
                attr_name: b"a\x00" as *const u8 as *const libc::c_char,
                attr_type: b"CDATA\x00" as *const u8 as *const libc::c_char,
                default_value: b"\xdb\xb2\x00" as *const u8 as *const libc::c_char,
                is_required: ::c2rust_out::expat_h::XML_FALSE,
            };
            init
        },
        {
            let mut init = AttTest {
                definition: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                element_name: ::c2rust_out::stddef_h::NULL
                    as *const crate::expat_external_h::XML_Char,
                attr_name: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                attr_type: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                default_value: ::c2rust_out::stddef_h::NULL
                    as *const crate::expat_external_h::XML_Char,
                is_required: ::c2rust_out::expat_h::XML_FALSE,
            };
            init
        },
    ];
    let mut test: *mut AttTest = 0 as *mut AttTest;
    test = attr_data.as_mut_ptr();
    while !(*test).definition.is_null() {
        ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
            g_parser,
            Some(
                verify_attlist_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(g_parser, test as *mut libc::c_void);
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            prolog,
            ::c2rust_out::stdlib::strlen(prolog) as libc::c_int,
            ::c2rust_out::expat_h::XML_FALSE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                1912 as libc::c_int,
            );
        }
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            (*test).definition,
            ::c2rust_out::stdlib::strlen((*test).definition) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                1916 as libc::c_int,
            );
        }
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        test = test.offset(1)
    }
}
/* See related SF bug #673791.
   When namespace processing is enabled, setting the namespace URI for
   a prefix is not allowed; this test ensures that it *is* allowed
   when namespace processing is not enabled.
   (See Namespaces in XML, section 2.)
*/

unsafe extern "C" fn test_empty_ns_without_namespaces() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_empty_ns_without_namespaces\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1928 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc xmlns:prefix=\'http://example.org/\'>\n  <e xmlns:prefix=\'\'/>\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1935 as libc::c_int,
        );
    };
}
/* Regression test for SF bug #824420.
   Checks that an xmlns:prefix attribute set in an attribute's default
   value isn't misinterpreted.
*/

unsafe extern "C" fn test_ns_in_attribute_default_without_namespaces() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 48], &[libc::c_char; 48]>(
            b"test_ns_in_attribute_default_without_namespaces\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1943 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE e:element [\n  <!ATTLIST e:element\n    xmlns:e CDATA \'http://example.org/\'>\n      ]>\n<e:element/>\x00"
            as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            1952 as libc::c_int,
        );
    };
}

static mut long_character_data_text: *const libc::c_char =
    b"<?xml version=\'1.0\' encoding=\'iso-8859-1\'?><s>012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789</s>\x00"
        as *const u8 as *const libc::c_char;

static mut resumable: crate::expat_h::XML_Bool =
    ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;

unsafe extern "C" fn clearing_aborting_character_handler(
    mut _userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut _len: libc::c_int,
) {
    ::c2rust_out::src::lib::xmlparse::XML_StopParser(g_parser, resumable);
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_CharacterDataHandler>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        ),
    );
}
/* Regression test for SF bug #1515266: missing check of stopped
parser in doContext() 'for' loop. */

unsafe extern "C" fn test_stop_parser_between_char_data_calls() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
            b"test_stop_parser_between_char_data_calls\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        1994 as libc::c_int,
    );
    /* The sample data must be big enough that there are two calls to
       the character data handler from within the inner "for" loop of
       the XML_TOK_DATA_CHARS case in doContent(), and the character
       handler must stop the parser and clear the character data
       handler.
    */
    let mut text: *const libc::c_char = long_character_data_text;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2007 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_ABORTED as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2009 as libc::c_int,
        );
    };
}
/* Regression test for SF bug #1515266: missing check of stopped
parser in doContext() 'for' loop. */

unsafe extern "C" fn test_suspend_parser_between_char_data_calls() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 44], &[libc::c_char; 44]>(
            b"test_suspend_parser_between_char_data_calls\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2015 as libc::c_int,
    );
    /* The sample data must be big enough that there are two calls to
       the character data handler from within the inner "for" loop of
       the XML_TOK_DATA_CHARS case in doContent(), and the character
       handler must stop the parser and clear the character data
       handler.
    */
    let mut text: *const libc::c_char = long_character_data_text;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2028 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2030 as libc::c_int,
        );
    }
    /* Try parsing directly */
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2034 as libc::c_int,
            b"Attempt to continue parse while suspended not faulted\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_SUSPENDED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2036 as libc::c_int,
            b"Suspended parse not faulted with correct error\x00" as *const u8
                as *const libc::c_char,
        );
    };
}

static mut abortable: crate::expat_h::XML_Bool =
    ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;

unsafe extern "C" fn parser_stop_character_handler(
    mut _userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut _len: libc::c_int,
) {
    ::c2rust_out::src::lib::xmlparse::XML_StopParser(g_parser, resumable);
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_CharacterDataHandler>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        ),
    );
    if resumable == 0 {
        /* Check that aborting an aborted parser is faulted */
        if ::c2rust_out::src::lib::xmlparse::XML_StopParser(
            g_parser,
            ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2052 as libc::c_int,
                b"Aborting aborted parser not faulted\x00" as *const u8 as *const libc::c_char,
            );
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_FINISHED as libc::c_int as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2054 as libc::c_int,
            );
        }
    } else if abortable != 0 {
        /* Check that aborting a suspended parser works */
        if ::c2rust_out::src::lib::xmlparse::XML_StopParser(
            g_parser,
            ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2058 as libc::c_int,
            );
        }
    } else {
        /* Check that suspending a suspended parser works */
        if ::c2rust_out::src::lib::xmlparse::XML_StopParser(
            g_parser,
            ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2062 as libc::c_int,
                b"Suspending suspended parser not faulted\x00" as *const u8 as *const libc::c_char,
            );
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_SUSPENDED as libc::c_int as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2064 as libc::c_int,
            );
        }
    };
}
/* Test repeated calls to XML_StopParser are handled correctly */

unsafe extern "C" fn test_repeated_stop_parser_between_char_data_calls() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 50], &[libc::c_char; 50]>(
            b"test_repeated_stop_parser_between_char_data_calls\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2069 as libc::c_int,
    );
    let mut text: *const libc::c_char = long_character_data_text;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            parser_stop_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    abortable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2077 as libc::c_int,
            b"Failed to double-stop parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            parser_stop_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    abortable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2085 as libc::c_int,
            b"Failed to double-suspend parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            parser_stop_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    abortable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2093 as libc::c_int,
            b"Failed to suspend-abort parser\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_good_cdata_ascii() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_good_cdata_ascii\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2097 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<a><![CDATA[<greeting>Hello, world!</greeting>]]></a>\x00"
        as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<greeting>Hello, world!</greeting>\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    /* Add start and end handlers for coverage */
    ::c2rust_out::src::lib::xmlparse::XML_SetStartCdataSectionHandler(
        g_parser,
        Some(dummy_start_cdata_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndCdataSectionHandler(
        g_parser,
        Some(dummy_end_cdata_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2111 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
    /* Try again, this time with a default handler */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            dummy_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2123 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_good_cdata_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_good_cdata_utf16\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2128 as libc::c_int,
    );
    /* Test data is:
     *   <?xml version='1.0' encoding='utf-16'?>
     *   <a><![CDATA[hello]]></a>
     */
    let text: [libc::c_char; 129] =
        *::std::mem::transmute::<&[u8; 129],
                                 &[libc::c_char; 129]>(b"\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00\'\x00u\x00t\x00f\x00-\x001\x006\x00\'\x00?\x00>\x00\n\x00<\x00a\x00>\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00h\x00e\x00l\x00l\x00o\x00]\x00]\x00>\x00<\x00/\x00a\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"hello\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 129]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2150 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_good_cdata_utf16_le() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_good_cdata_utf16_le\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2155 as libc::c_int,
    );
    /* Test data is:
     *   <?xml version='1.0' encoding='utf-16'?>
     *   <a><![CDATA[hello]]></a>
     */
    let text: [libc::c_char; 129] =
        *::std::mem::transmute::<&[u8; 129],
                                 &[libc::c_char; 129]>(b"<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00\'\x00u\x00t\x00f\x00-\x001\x006\x00\'\x00?\x00>\x00\n\x00<\x00a\x00>\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00h\x00e\x00l\x00l\x00o\x00]\x00]\x00>\x00<\x00/\x00a\x00>\x00\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"hello\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 129]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2177 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test UTF16 conversion of a long cdata string */
/* 16 characters: handy macro to reduce visual clutter */

unsafe extern "C" fn test_long_cdata_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_long_cdata_utf16\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2187 as libc::c_int,
    );
    /* Test data is:
     * <?xlm version='1.0' encoding='utf-16'?>
     * <a><![CDATA[
     * ABCDEFGHIJKLMNOP
     * ]]></a>
     */
    let text: [libc::c_char; 2197] =
        *::std::mem::transmute::<&[u8; 2197],
                                 &[libc::c_char; 2197]>(b"\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00\'\x00u\x00t\x00f\x00-\x001\x006\x00\'\x00?\x00>\x00<\x00a\x00>\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00A\x00B\x00C\x00D\x00E\x00F\x00G\x00H\x00I\x00J\x00K\x00L\x00M\x00N\x00O\x00P\x00]\x00]\x00>\x00<\x00/\x00a\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\x00"
            as *const u8 as *const libc::c_char;
    /* clang-format on */
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(
        g_parser,
        (::std::mem::size_of::<[libc::c_char; 2197]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    );
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2248 as libc::c_int,
            b"Could not allocate parse buffer\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !buffer.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"buffer != NULL\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2249 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                b"void test_long_cdata_utf16(void)\x00",
            ))
            .as_ptr(),
        );
    }
    ::c2rust_out::stdlib::memcpy(
        buffer,
        text.as_ptr() as *const libc::c_void,
        (::std::mem::size_of::<[libc::c_char; 2197]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        (::std::mem::size_of::<[libc::c_char; 2197]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2252 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test handling of multiple unit UTF-16 characters */

unsafe extern "C" fn test_multichar_cdata_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_multichar_cdata_utf16\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2258 as libc::c_int,
    );
    /* Test data is:
     *   <?xml version='1.0' encoding='utf-16'?>
     *   <a><![CDATA[{MINIM}{CROTCHET}]]></a>
     *
     * where {MINIM} is U+1d15e (a minim or half-note)
     *   UTF-16: 0xd834 0xdd5e
     *   UTF-8:  0xf0 0x9d 0x85 0x9e
     * and {CROTCHET} is U+1d15f (a crotchet or quarter-note)
     *   UTF-16: 0xd834 0xdd5f
     *   UTF-8:  0xf0 0x9d 0x85 0x9f
     */
    let text: [libc::c_char; 127] =
        *::std::mem::transmute::<&[u8; 127],
                                 &[libc::c_char; 127]>(b"\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00\'\x00u\x00t\x00f\x00-\x001\x006\x00\'\x00?\x00>\x00\n\x00<\x00a\x00>\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\xd84\xdd^\xd84\xdd_\x00]\x00]\x00>\x00<\x00/\x00a\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xf0\x9d\x85\x9e\xf0\x9d\x85\x9f\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 127]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2292 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test that an element name with a UTF-16 surrogate pair is rejected */

unsafe extern "C" fn test_utf16_bad_surrogate_pair() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_utf16_bad_surrogate_pair\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2298 as libc::c_int,
    );
    /* Test data is:
     *   <?xml version='1.0' encoding='utf-16'?>
     *   <a><![CDATA[{BADLINB}]]></a>
     *
     * where {BADLINB} is U+10000 (the first Linear B character)
     * with the UTF-16 surrogate pair in the wrong order, i.e.
     *   0xdc00 0xd800
     */
    let text: [libc::c_char; 123] =
        *::std::mem::transmute::<&[u8; 123],
                                 &[libc::c_char; 123]>(b"\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00\'\x00u\x00t\x00f\x00-\x001\x006\x00\'\x00?\x00>\x00\n\x00<\x00a\x00>\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\xdc\x00\xd8\x00\x00]\x00]\x00>\x00<\x00/\x00a\x00>\x00");
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 123]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2319 as libc::c_int,
            b"Reversed UTF-16 surrogate pair not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2321 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_bad_cdata() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"test_bad_cdata\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2325 as libc::c_int,
    );
    let mut cases: [CaseData; 21] = [
        {
            let mut init = CaseData {
                text: b"<a><\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><!\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![C\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CD\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDA\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDAT\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA[\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA[]\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA[]]\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><!<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![C<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CD<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDA<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDAT<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA[<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA[]<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData {
                text: b"<a><![CDATA[]]<a/>\x00" as *const u8 as *const libc::c_char,
                expectedError: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
    ];
    let mut i: crate::stddef_h::size_t = 0 as libc::c_int as crate::stddef_h::size_t;
    while i
        < (::std::mem::size_of::<[CaseData; 21]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<CaseData>() as libc::c_ulong)
    {
        let actualStatus: crate::expat_h::XML_Status = _XML_Parse_SINGLE_BYTES(
            g_parser,
            cases[i as usize].text,
            ::c2rust_out::stdlib::strlen(cases[i as usize].text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        );
        let actualError: crate::expat_h::XML_Error =
            ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser);
        if actualStatus as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR as libc::c_int as libc::c_uint
        {
        } else {
            ::c2rust_out::stdlib::__assert_fail(
                b"actualStatus == XML_STATUS_ERROR\x00" as *const u8 as *const libc::c_char,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2363 as libc::c_int as libc::c_uint,
                (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
                    b"void test_bad_cdata(void)\x00",
                ))
                .as_ptr(),
            );
        }
        if actualError as libc::c_uint != cases[i as usize].expectedError as libc::c_uint {
            let mut message: [libc::c_char; 100] = [0; 100];
            ::libc::sprintf(
                message.as_mut_ptr(),
                b"Expected error %d but got error %d for case %u: \"%s\"\n\x00" as *const u8
                    as *const libc::c_char,
                cases[i as usize].expectedError as libc::c_uint,
                actualError as libc::c_uint,
                (i as libc::c_uint).wrapping_add(1 as libc::c_int as libc::c_uint),
                cases[i as usize].text,
            );
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2371 as libc::c_int,
                message.as_mut_ptr(),
            );
        }
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        i = i.wrapping_add(1)
    }
}
/* Test failures in UTF-16 CDATA */

unsafe extern "C" fn test_bad_cdata_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_bad_cdata_utf16\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2380 as libc::c_int,
    );
    let prolog: [libc::c_char; 87] =
        *::std::mem::transmute::<&[u8; 87],
                                 &[libc::c_char; 87]>(b"\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=\x00\'\x00u\x00t\x00f\x00-\x001\x006\x00\'\x00?\x00>\x00\n\x00<\x00a\x00>\x00");
    let mut cases: [CaseData_0; 24] = [
        {
            let mut init = CaseData_0 {
                text_bytes: 1 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 2 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 3 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 4 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 5 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 6 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 7 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 8 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 9 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 10 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 11 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 12 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 13 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00\x00" as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 14 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 15 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 16 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 17 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 18 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 19 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 20 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00Z\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 21 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00Z\xd8\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 22 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00Z\xd84\x00" as *const u8
                    as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 23 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00Z\xd84\xdd\x00"
                    as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = CaseData_0 {
                text_bytes: 24 as libc::c_int as crate::stddef_h::size_t,
                text: b"\x00<\x00!\x00[\x00C\x00D\x00A\x00T\x00A\x00[\x00Z\xd84\xdd^\x00"
                    as *const u8 as *const libc::c_char,
                expected_error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_CDATA_SECTION,
            };
            init
        },
    ];
    let mut i: crate::stddef_h::size_t = 0;
    i = 0 as libc::c_int as crate::stddef_h::size_t;
    while i
        < (::std::mem::size_of::<[CaseData_0; 24]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<CaseData_0>() as libc::c_ulong)
    {
        let mut actual_status: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
        let mut actual_error: crate::expat_h::XML_Error = ::c2rust_out::expat_h::XML_ERROR_NONE;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            prolog.as_ptr(),
            ::std::mem::size_of::<[libc::c_char; 87]>() as libc::c_ulong as libc::c_int
                - 1 as libc::c_int,
            ::c2rust_out::expat_h::XML_FALSE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2432 as libc::c_int,
            );
        }
        actual_status = _XML_Parse_SINGLE_BYTES(
            g_parser,
            cases[i as usize].text,
            cases[i as usize].text_bytes as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        );
        if actual_status as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR as libc::c_int as libc::c_uint
        {
        } else {
            ::c2rust_out::stdlib::__assert_fail(
                b"actual_status == XML_STATUS_ERROR\x00" as *const u8 as *const libc::c_char,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2435 as libc::c_int as libc::c_uint,
                (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
                    b"void test_bad_cdata_utf16(void)\x00",
                ))
                .as_ptr(),
            );
        }
        actual_error = ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser);
        if actual_error as libc::c_uint != cases[i as usize].expected_error as libc::c_uint {
            let mut message: [libc::c_char; 1024] = [0; 1024];
            ::libc::sprintf(
                message.as_mut_ptr(),
                b"Expected error %d (%s), got %d (%s) for case %lu\n\x00" as *const u8
                    as *const libc::c_char,
                cases[i as usize].expected_error as libc::c_uint,
                ::c2rust_out::src::lib::xmlparse::XML_ErrorString(cases[i as usize].expected_error),
                actual_error as libc::c_uint,
                ::c2rust_out::src::lib::xmlparse::XML_ErrorString(actual_error),
                i.wrapping_add(1 as libc::c_int as libc::c_ulong),
            );
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2446 as libc::c_int,
                message.as_mut_ptr(),
            );
        }
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        i = i.wrapping_add(1)
    }
}

static mut long_cdata_text: *const libc::c_char =
    b"<s><![CDATA[012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789]]></s>\x00"
        as *const u8 as *const libc::c_char;
/* Test stopping the parser in cdata handler */

unsafe extern "C" fn test_stop_parser_between_cdata_calls() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_stop_parser_between_cdata_calls\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2478 as libc::c_int,
    );
    let mut text: *const libc::c_char = long_cdata_text;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_ABORTED,
        b"Parse not aborted in CDATA handler\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2483 as libc::c_int,
    );
}
/* Test suspending the parser in cdata handler */

unsafe extern "C" fn test_suspend_parser_between_cdata_calls() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
            b"test_suspend_parser_between_cdata_calls\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2488 as libc::c_int,
    );
    let mut text: *const libc::c_char = long_cdata_text;
    let mut result: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    result = _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    if result as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint {
        if result as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2497 as libc::c_int,
            );
        }
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2498 as libc::c_int,
            b"Parse not suspended in CDATA handler\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2501 as libc::c_int,
        );
    };
}
/* Test memory allocation functions */

unsafe extern "C" fn test_memory_allocation() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_memory_allocation\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2506 as libc::c_int,
    );
    let mut buffer: *mut libc::c_char = ::c2rust_out::src::lib::xmlparse::XML_MemMalloc(
        g_parser,
        256 as libc::c_int as crate::stddef_h::size_t,
    ) as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2511 as libc::c_int,
            b"Allocation failed\x00" as *const u8 as *const libc::c_char,
        );
    } else {
        /* Try writing to memory; some OSes try to cheat! */
        *buffer.offset(0 as libc::c_int as isize) = 'T' as i32 as libc::c_char;
        *buffer.offset(1 as libc::c_int as isize) = 'E' as i32 as libc::c_char;
        *buffer.offset(2 as libc::c_int as isize) = 'S' as i32 as libc::c_char;
        *buffer.offset(3 as libc::c_int as isize) = 'T' as i32 as libc::c_char;
        *buffer.offset(4 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
        if ::libc::strcmp(buffer, b"TEST\x00" as *const u8 as *const libc::c_char)
            != 0 as libc::c_int
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2520 as libc::c_int,
                b"Memory not writable\x00" as *const u8 as *const libc::c_char,
            );
        } else {
            p = ::c2rust_out::src::lib::xmlparse::XML_MemRealloc(
                g_parser,
                buffer as *mut libc::c_void,
                512 as libc::c_int as crate::stddef_h::size_t,
            ) as *mut libc::c_char;
            if p.is_null() {
                ::c2rust_out::src::tests::minicheck::_fail_unless(
                    0 as libc::c_int,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    2524 as libc::c_int,
                    b"Reallocation failed\x00" as *const u8 as *const libc::c_char,
                );
            } else {
                /* Write again, just to be sure */
                buffer = p;
                *buffer.offset(0 as libc::c_int as isize) = 'V' as i32 as libc::c_char;
                if ::libc::strcmp(buffer, b"VEST\x00" as *const u8 as *const libc::c_char)
                    != 0 as libc::c_int
                {
                    ::c2rust_out::src::tests::minicheck::_fail_unless(0 as libc::c_int,
                                 b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                                     as *const u8 as *const libc::c_char,
                                 2530 as libc::c_int,
                                 b"Reallocated memory not writable\x00" as
                                     *const u8 as *const libc::c_char);
                }
            }
        }
        ::c2rust_out::src::lib::xmlparse::XML_MemFree(g_parser, buffer as *mut libc::c_void);
    };
}

unsafe extern "C" fn record_default_handler(
    mut userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut _len: libc::c_int,
) {
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        userData as *mut ::c2rust_out::src::tests::chardata::CharData
            as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"D\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
}

unsafe extern "C" fn record_cdata_handler(
    mut userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut _len: libc::c_int,
) {
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        userData as *mut ::c2rust_out::src::tests::chardata::CharData
            as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"C\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_DefaultCurrent(g_parser);
}

unsafe extern "C" fn record_cdata_nodefault_handler(
    mut userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut _len: libc::c_int,
) {
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        userData as *mut ::c2rust_out::src::tests::chardata::CharData
            as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"c\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
}

unsafe extern "C" fn record_skip_handler(
    mut userData: *mut libc::c_void,
    mut _entityName: *const crate::expat_external_h::XML_Char,
    mut is_parameter_entity: libc::c_int,
) {
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        userData as *mut ::c2rust_out::src::tests::chardata::CharData
            as *mut ::c2rust_out::src::tests::chardata::CharData,
        if is_parameter_entity != 0 {
            b"E\x00" as *const u8 as *const libc::c_char
        } else {
            b"e\x00" as *const u8 as *const libc::c_char
        },
        1 as libc::c_int,
    );
}
/* Test XML_DefaultCurrent() passes handling on correctly */

unsafe extern "C" fn test_default_current() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_default_current\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2570 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc>hell]</doc>\x00" as *const u8 as *const libc::c_char;
    let mut entity_text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY entity \'&#37;\'>\n]>\n<doc>&entity;</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            record_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            record_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2584 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"DCDCDCDCDCDD\x00" as *const u8 as *const libc::c_char,
    );
    /* Again, without the defaulting */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            record_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            record_cdata_nodefault_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2595 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"DcccccD\x00" as *const u8 as *const libc::c_char,
    );
    /* Now with an internal entity to complicate matters */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            record_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            record_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        entity_text,
        ::c2rust_out::stdlib::strlen(entity_text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2607 as libc::c_int,
        );
    }
    /* The default handler suppresses the entity */
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"DDDDDDDDDDDDDDDDDDD\x00" as *const u8 as *const libc::c_char,
    );
    /* Again, with a skip handler */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            record_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            record_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetSkippedEntityHandler(
        g_parser,
        Some(
            record_skip_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        entity_text,
        ::c2rust_out::stdlib::strlen(entity_text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2621 as libc::c_int,
        );
    }
    /* The default handler suppresses the entity */
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"DDDDDDDDDDDDDDDDDeD\x00" as *const u8 as *const libc::c_char,
    );
    /* This time, allow the entity through */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandlerExpand(
        g_parser,
        Some(
            record_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            record_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        entity_text,
        ::c2rust_out::stdlib::strlen(entity_text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2634 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"DDDDDDDDDDDDDDDDDCDD\x00" as *const u8 as *const libc::c_char,
    );
    /* Finally, without passing the cdata to the default handler */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandlerExpand(
        g_parser,
        Some(
            record_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            record_cdata_nodefault_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        entity_text,
        ::c2rust_out::stdlib::strlen(entity_text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2646 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"DDDDDDDDDDDDDDDDDcD\x00" as *const u8 as *const libc::c_char,
    );
}
/* Test DTD element parsing code paths */

unsafe extern "C" fn test_dtd_elements() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_dtd_elements\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2652 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (chapter)>\n<!ELEMENT chapter (#PCDATA)>\n]>\n<doc><chapter>Wombats are go</chapter></doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            dummy_element_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2662 as libc::c_int,
        );
    };
}
/* Test foreign DTD handling */

unsafe extern "C" fn test_set_foreign_dtd() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_set_foreign_dtd\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2667 as libc::c_int,
    );
    let mut text1: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n\x00" as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<doc>&entity;</doc>\x00" as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    /* Check hash salt is passed through too */
    ::c2rust_out::src::lib::xmlparse::XML_SetHashSalt(
        g_parser,
        0x12345678 as libc::c_int as libc::c_ulong,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    /* Add a default handler to exercise more code paths */
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            dummy_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2680 as libc::c_int,
            b"Could not set foreign DTD\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text1,
        ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2683 as libc::c_int,
        );
    }
    /* Ensure that trying to set the DTD after parsing has started
     * is faulted, even if it's the same setting.
     */
    if ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING as libc::c_int
            as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2690 as libc::c_int,
            b"Failed to reject late foreign DTD setting\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Ditto for the hash salt */
    if ::c2rust_out::src::lib::xmlparse::XML_SetHashSalt(
        g_parser,
        0x23456789 as libc::c_int as libc::c_ulong,
    ) != 0
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2693 as libc::c_int,
            b"Failed to reject late hash salt change\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Now finish the parse */
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text2,
        ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2698 as libc::c_int,
        );
    };
}
/* Test foreign DTD handling with a failing NotStandalone handler */

unsafe extern "C" fn test_foreign_dtd_not_standalone() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_foreign_dtd_not_standalone\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2703 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<doc>&entity;</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetNotStandaloneHandler(
        g_parser,
        Some(
            reject_not_standalone_handler
                as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int,
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2713 as libc::c_int,
            b"Could not set foreign DTD\x00" as *const u8 as *const libc::c_char,
        );
    }
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_NOT_STANDALONE,
        b"NotStandalonehandler failed to reject\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2715 as libc::c_int,
    );
}
/* Test invalid character in a foreign DTD is faulted */

unsafe extern "C" fn test_invalid_foreign_dtd() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_invalid_foreign_dtd\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2720 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<doc>&entity;</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut test_data: ExtFaults = {
        let mut init = ext_faults {
            parse_text: b"$\x00" as *const u8 as *const libc::c_char,
            fail_text: b"Dollar not faulted\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            error: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtFaults as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_faulter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Bad DTD should not have been accepted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2731 as libc::c_int,
    );
}
/* Test foreign DTD use with a doctype */

unsafe extern "C" fn test_foreign_dtd_with_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_foreign_dtd_with_doctype\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2736 as libc::c_int,
    );
    let mut text1: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc [<!ENTITY entity \'hello world\'>]>\n\x00"
            as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<doc>&entity;</doc>\x00" as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    /* Check hash salt is passed through too */
    ::c2rust_out::src::lib::xmlparse::XML_SetHashSalt(
        g_parser,
        0x12345678 as libc::c_int as libc::c_ulong,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    /* Add a default handler to exercise more code paths */
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            dummy_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2750 as libc::c_int,
            b"Could not set foreign DTD\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text1,
        ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2753 as libc::c_int,
        );
    }
    /* Ensure that trying to set the DTD after parsing has started
     * is faulted, even if it's the same setting.
     */
    if ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING as libc::c_int
            as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2760 as libc::c_int,
            b"Failed to reject late foreign DTD setting\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Ditto for the hash salt */
    if ::c2rust_out::src::lib::xmlparse::XML_SetHashSalt(
        g_parser,
        0x23456789 as libc::c_int as libc::c_ulong,
    ) != 0
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2763 as libc::c_int,
            b"Failed to reject late hash salt change\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Now finish the parse */
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text2,
        ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2768 as libc::c_int,
        );
    };
}
/* Test XML_UseForeignDTD with no external subset present */

unsafe extern "C" fn external_entity_null_loader(
    mut _parser: crate::expat_h::XML_Parser,
    mut _context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_foreign_dtd_without_external_subset() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
            b"test_foreign_dtd_without_external_subset\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2785 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [<!ENTITY foo \'bar\'>]>\n<doc>&foo;</doc>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_null_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2795 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_empty_foreign_dtd() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_empty_foreign_dtd\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2799 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<doc>&entity;</doc>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_null_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNDEFINED_ENTITY,
        b"Undefined entity not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2807 as libc::c_int,
    );
}
/* Test XML Base is set and unset appropriately */

unsafe extern "C" fn test_set_base() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"test_set_base\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2812 as libc::c_int,
    );
    let mut old_base: *const crate::expat_external_h::XML_Char =
        0 as *const crate::expat_external_h::XML_Char;
    let mut new_base: *const crate::expat_external_h::XML_Char =
        b"/local/file/name.xml\x00" as *const u8 as *const libc::c_char;
    old_base = ::c2rust_out::src::lib::xmlparse::XML_GetBase(g_parser);
    if ::c2rust_out::src::lib::xmlparse::XML_SetBase(g_parser, new_base) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2818 as libc::c_int,
            b"Unable to set base\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::libc::strcmp(
        ::c2rust_out::src::lib::xmlparse::XML_GetBase(g_parser),
        new_base,
    ) != 0 as libc::c_int
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2820 as libc::c_int,
            b"Base setting not correct\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_SetBase(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2822 as libc::c_int,
            b"Unable to NULL base\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !::c2rust_out::src::lib::xmlparse::XML_GetBase(g_parser).is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2824 as libc::c_int,
            b"Base setting not nulled\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetBase(g_parser, old_base);
}

unsafe extern "C" fn counting_start_element_handler(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
    mut atts: *mut *const crate::expat_external_h::XML_Char,
) {
    let mut info: *mut ElementInfo = userData as *mut ElementInfo;
    let mut attr: *mut AttrInfo = 0 as *mut AttrInfo;
    let mut count: libc::c_int = 0;
    let mut id: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    while !(*info).name.is_null() {
        if ::libc::strcmp(name, (*info).name) == 0 {
            break;
        }
        info = info.offset(1)
    }
    if (*info).name.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2855 as libc::c_int,
            b"Element not recognised\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* The attribute count is twice what you might expect.  It is a
     * count of items in atts, an array which contains alternating
     * attribute names and attribute values.  For the naive user this
     * is possibly a little unexpected, but it is what the
     * documentation in expat.h tells us to expect.
     */
    count = ::c2rust_out::src::lib::xmlparse::XML_GetSpecifiedAttributeCount(g_parser);
    if (*info).attr_count * 2 as libc::c_int != count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2864 as libc::c_int,
            b"Not got expected attribute count\x00" as *const u8 as *const libc::c_char,
        );
        return;
    }
    id = ::c2rust_out::src::lib::xmlparse::XML_GetIdAttributeIndex(g_parser);
    if id == -(1 as libc::c_int) && !(*info).id_name.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2869 as libc::c_int,
            b"ID not present\x00" as *const u8 as *const libc::c_char,
        );
        return;
    }
    if id != -(1 as libc::c_int) && ::libc::strcmp(*atts.offset(id as isize), (*info).id_name) != 0
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2873 as libc::c_int,
            b"ID does not have the correct name\x00" as *const u8 as *const libc::c_char,
        );
        return;
    }
    i = 0 as libc::c_int;
    while i < (*info).attr_count {
        attr = (*info).attributes;
        while !(*attr).name.is_null() {
            if ::libc::strcmp(*atts.offset(0 as libc::c_int as isize), (*attr).name) == 0 {
                break;
            }
            attr = attr.offset(1)
        }
        if (*attr).name.is_null() {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2884 as libc::c_int,
                b"Attribute not recognised\x00" as *const u8 as *const libc::c_char,
            );
            return;
        }
        if ::libc::strcmp(*atts.offset(1 as libc::c_int as isize), (*attr).value) != 0 {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                2888 as libc::c_int,
                b"Attribute has wrong value\x00" as *const u8 as *const libc::c_char,
            );
            return;
        }
        /* Remember, two entries in atts per attribute (see above) */
        atts = atts.offset(2 as libc::c_int as isize);
        i += 1
    }
}

unsafe extern "C" fn test_attributes() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"test_attributes\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2896 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (tag)>\n<!ATTLIST doc id ID #REQUIRED>\n]><doc a=\'1\' id=\'one\' b=\'2\'><tag c=\'3\'/></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut doc_info: [AttrInfo; 4] = [
        {
            let mut init = attrInfo {
                name: b"a\x00" as *const u8 as *const libc::c_char,
                value: b"1\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = attrInfo {
                name: b"b\x00" as *const u8 as *const libc::c_char,
                value: b"2\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = attrInfo {
                name: b"id\x00" as *const u8 as *const libc::c_char,
                value: b"one\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = attrInfo {
                name: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                value: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            };
            init
        },
    ];
    let mut tag_info: [AttrInfo; 2] = [
        {
            let mut init = attrInfo {
                name: b"c\x00" as *const u8 as *const libc::c_char,
                value: b"3\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = attrInfo {
                name: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                value: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            };
            init
        },
    ];
    let mut info: [ElementInfo; 3] = [
        {
            let mut init = elementInfo {
                name: b"doc\x00" as *const u8 as *const libc::c_char,
                attr_count: 3 as libc::c_int,
                id_name: b"id\x00" as *const u8 as *const libc::c_char,
                attributes: ::c2rust_out::stddef_h::NULL as *mut AttrInfo,
            };
            init
        },
        {
            let mut init = elementInfo {
                name: b"tag\x00" as *const u8 as *const libc::c_char,
                attr_count: 1 as libc::c_int,
                id_name: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                attributes: ::c2rust_out::stddef_h::NULL as *mut AttrInfo,
            };
            init
        },
        {
            let mut init = elementInfo {
                name: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                attr_count: 0 as libc::c_int,
                id_name: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                attributes: ::c2rust_out::stddef_h::NULL as *mut AttrInfo,
            };
            init
        },
    ];
    info[0 as libc::c_int as usize].attributes = doc_info.as_mut_ptr();
    info[1 as libc::c_int as usize].attributes = tag_info.as_mut_ptr();
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            counting_start_element_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        info.as_mut_ptr() as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2919 as libc::c_int,
        );
    };
}
/* Test reset works correctly in the middle of processing an internal
 * entity.  Exercises some obscure code in XML_ParserReset().
 */

unsafe extern "C" fn test_reset_in_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_reset_in_entity\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2926 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY wombat \'wom\'>\n<!ENTITY entity \'hi &wom; there\'>\n]>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut status: ::c2rust_out::expat_h::XML_ParsingStatus =
        ::c2rust_out::expat_h::XML_ParsingStatus {
            parsing: ::c2rust_out::expat_h::XML_INITIALIZED,
            finalBuffer: 0,
        };
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2938 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        g_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_SUSPENDED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2941 as libc::c_int,
            b"Parsing status not SUSPENDED\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        g_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_INITIALIZED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2945 as libc::c_int,
            b"Parsing status doesn\'t reset to INITIALIZED\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that resume correctly passes through parse errors */

unsafe extern "C" fn test_resume_invalid_parse() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_resume_invalid_parse\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2950 as libc::c_int,
    ); /* Missing closing wedge */
    let mut text: *const libc::c_char = b"<doc>Hello</doc\x00" as *const u8 as *const libc::c_char;
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2957 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2959 as libc::c_int,
            b"Resumed invalid parse not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2961 as libc::c_int,
            b"Invalid parse not correctly faulted\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that re-suspended parses are correctly passed through */

unsafe extern "C" fn test_resume_resuspended() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_resume_resuspended\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2966 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc>Hello<meep/>world</doc>\x00" as *const u8 as *const libc::c_char;
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2973 as libc::c_int,
        );
    }
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2977 as libc::c_int,
            b"Resumption not suspended\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* This one should succeed and finish up */
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2980 as libc::c_int,
        );
    };
}
/* Test that CDATA shows up correctly through a default handler */

unsafe extern "C" fn test_cdata_default() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_cdata_default\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        2985 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc><![CDATA[Hello\nworld]]></doc>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<doc><![CDATA[Hello\nworld]]></doc>\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            2996 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test resetting a subordinate parser does exactly nothing */

unsafe extern "C" fn external_entity_resetter(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char =
        b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut status: ::c2rust_out::expat_h::XML_ParsingStatus =
        ::c2rust_out::expat_h::XML_ParsingStatus {
            parsing: ::c2rust_out::expat_h::XML_INITIALIZED,
            finalBuffer: 0,
        };
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3015 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        ext_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_INITIALIZED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3018 as libc::c_int,
            b"Parsing status is not INITIALIZED\x00" as *const u8 as *const libc::c_char,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3023 as libc::c_int,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        ext_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_FINISHED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3028 as libc::c_int,
            b"Parsing status is not FINISHED\x00" as *const u8 as *const libc::c_char,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    /* Check we can't parse here */
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3034 as libc::c_int,
            b"Parsing when finished not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_FINISHED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3036 as libc::c_int,
            b"Parsing when finished faulted with wrong code\x00" as *const u8
                as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        ext_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        ext_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_FINISHED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3040 as libc::c_int,
            b"Parsing status not still FINISHED\x00" as *const u8 as *const libc::c_char,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_subordinate_reset() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_subordinate_reset\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3047 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_resetter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3056 as libc::c_int,
        );
    };
}
/* Test suspending a subordinate parser */

unsafe extern "C" fn entity_suspending_decl_handler(
    mut userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut model: *mut crate::expat_h::XML_Content,
) {
    let mut ext_parser: crate::expat_h::XML_Parser = userData as crate::expat_h::XML_Parser;
    if ::c2rust_out::src::lib::xmlparse::XML_StopParser(
        ext_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3069 as libc::c_int,
            b"Attempting to suspend a subordinate parser not faulted\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_SUSPEND_PE as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3071 as libc::c_int,
            b"Suspending subordinate parser get wrong code\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        ext_parser,
        ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_ElementDeclHandler>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        )
            as ::std::option::Option<
                unsafe extern "C" fn(
                    _: *mut ::libc::c_void,
                    _: *const i8,
                    _: *mut ::c2rust_out::expat_h::XML_cp,
                ) -> (),
            >,
    );
    ::c2rust_out::src::lib::xmlparse::XML_FreeContentModel(
        g_parser,
        model as *mut ::c2rust_out::expat_h::XML_cp,
    );
}

unsafe extern "C" fn external_entity_suspender(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char =
        b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3088 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        ext_parser,
        ::std::mem::transmute(Some(
            entity_suspending_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(ext_parser, ext_parser as *mut libc::c_void);
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3093 as libc::c_int,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_subordinate_suspend() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_subordinate_suspend\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3100 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_suspender
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3109 as libc::c_int,
        );
    };
}
/* Test suspending a subordinate parser from an XML declaration */
/* Increases code coverage of the tests */

unsafe extern "C" fn entity_suspending_xdecl_handler(
    mut userData: *mut libc::c_void,
    mut _version: *const crate::expat_external_h::XML_Char,
    mut _encoding: *const crate::expat_external_h::XML_Char,
    mut _standalone: libc::c_int,
) {
    let mut ext_parser: crate::expat_h::XML_Parser = userData as crate::expat_h::XML_Parser;
    ::c2rust_out::src::lib::xmlparse::XML_StopParser(ext_parser, resumable);
    ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
        ext_parser,
        ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_XmlDeclHandler>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        ),
    );
}

unsafe extern "C" fn external_entity_suspend_xmldecl(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut status: ::c2rust_out::expat_h::XML_ParsingStatus =
        ::c2rust_out::expat_h::XML_ParsingStatus {
            parsing: ::c2rust_out::expat_h::XML_INITIALIZED,
            finalBuffer: 0,
        };
    let mut rc: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3141 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
        ext_parser,
        Some(
            entity_suspending_xdecl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(ext_parser, ext_parser as *mut libc::c_void);
    rc = _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        ext_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if resumable != 0 {
        if rc as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                3148 as libc::c_int,
            );
        }
        if status.parsing as libc::c_uint
            != ::c2rust_out::expat_h::XML_SUSPENDED as libc::c_int as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                3150 as libc::c_int,
                b"Ext Parsing status not SUSPENDED\x00" as *const u8 as *const libc::c_char,
            );
        }
    } else {
        if rc as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                3153 as libc::c_int,
                b"Ext parsing not aborted\x00" as *const u8 as *const libc::c_char,
            );
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_ABORTED as libc::c_int as libc::c_uint
        {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                3155 as libc::c_int,
            );
        }
        if status.parsing as libc::c_uint
            != ::c2rust_out::expat_h::XML_FINISHED as libc::c_int as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                3157 as libc::c_int,
                b"Ext Parsing status not FINISHED\x00" as *const u8 as *const libc::c_char,
            );
        }
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_subordinate_xdecl_suspend() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_subordinate_xdecl_suspend\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3164 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY entity SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_suspend_xmldecl
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3176 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_subordinate_xdecl_abort() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_subordinate_xdecl_abort\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3180 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY entity SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_suspend_xmldecl
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3192 as libc::c_int,
        );
    };
}
/* Test external entity fault handling with suspension */

unsafe extern "C" fn external_entity_suspending_faulter(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut fault: *mut ExtFaults = *(parser as *mut *mut libc::c_void) as *mut ExtFaults;
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut parse_len: libc::c_int =
        ::c2rust_out::stdlib::strlen((*fault).parse_text) as libc::c_int;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3212 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
        ext_parser,
        Some(
            entity_suspending_xdecl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(ext_parser, ext_parser as *mut libc::c_void);
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(ext_parser, parse_len);
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3218 as libc::c_int,
            b"Could not allocate parse buffer\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !buffer.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(b"buffer != NULL\x00" as *const u8 as
                          *const libc::c_char,
                      b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                          as *const u8 as *const libc::c_char,
                      3219 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 123],
                                                &[libc::c_char; 123]>(b"int external_entity_suspending_faulter(XML_Parser, const XML_Char *, const XML_Char *, const XML_Char *, const XML_Char *)\x00")).as_ptr());
    }
    ::c2rust_out::stdlib::memcpy(
        buffer,
        (*fault).parse_text as *const libc::c_void,
        parse_len as libc::c_ulong,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        ext_parser,
        parse_len,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3222 as libc::c_int,
            b"XML declaration did not suspend\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(ext_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3224 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        ext_parser,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3226 as libc::c_int,
            (*fault).fail_text,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
        != (*fault).error as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3228 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}

unsafe extern "C" fn test_ext_entity_invalid_suspended_parse() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
            b"test_ext_entity_invalid_suspended_parse\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3234 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut faults: [ExtFaults; 3] = [
        {
            let mut init = ext_faults {
                parse_text: b"<?xml version=\'1.0\' encoding=\'us-ascii\'?><\x00" as *const u8
                    as *const libc::c_char,
                fail_text: b"Incomplete element declaration not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\xe2\x82\x00" as *const u8
                    as *const libc::c_char,
                fail_text: b"Incomplete character not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                fail_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_NONE,
            };
            init
        },
    ];
    let mut fault: *mut ExtFaults = 0 as *mut ExtFaults;
    fault = &mut *faults.as_mut_ptr().offset(0 as libc::c_int as isize) as *mut ExtFaults;
    while !(*fault).parse_text.is_null() {
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_suspending_faulter
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(g_parser, fault as *mut libc::c_void);
        _expect_failure(
            text,
            ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
            b"Parser did not report external entity error\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3255 as libc::c_int,
        );
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        fault = fault.offset(1)
    }
}
/* Test setting an explicit encoding */

unsafe extern "C" fn test_explicit_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_explicit_encoding\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3262 as libc::c_int,
    );
    let mut text1: *const libc::c_char = b"<doc>Hello \x00" as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char = b" World</doc>\x00" as *const u8 as *const libc::c_char;
    /* Just check that we can set the encoding to NULL before starting */
    if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3268 as libc::c_int,
            b"Failed to initialise encoding to NULL\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Say we are UTF-8 */
    if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(
        g_parser,
        b"utf-8\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3271 as libc::c_int,
            b"Failed to set explicit encoding\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text1,
        ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3274 as libc::c_int,
        );
    }
    /* Try to switch encodings mid-parse */
    if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(
        g_parser,
        b"us-ascii\x00" as *const u8 as *const libc::c_char,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3277 as libc::c_int,
            b"Allowed encoding change\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text2,
        ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3280 as libc::c_int,
        );
    }
    /* Try now the parse is over */
    if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3283 as libc::c_int,
            b"Failed to unset encoding\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test handling of trailing CR (rather than newline) */

unsafe extern "C" fn cr_cdata_handler(
    mut userData: *mut libc::c_void,
    mut s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    let mut pfound: *mut libc::c_int = userData as *mut libc::c_int;
    /* Internal processing turns the CR into a newline for the
     * character data handler, but not for the default handler
     */
    if len == 1 as libc::c_int
        && (*s as libc::c_int == '\n' as i32 || *s as libc::c_int == '\r' as i32)
    {
        *pfound = 1 as libc::c_int
    };
}

unsafe extern "C" fn test_trailing_cr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"test_trailing_cr\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3299 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc>\r\x00" as *const u8 as *const libc::c_char;
    let mut found_cr: libc::c_int = 0;
    /* Try with a character handler, for code coverage */
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            cr_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_cr as *mut libc::c_int as *mut libc::c_void,
    );
    found_cr = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3309 as libc::c_int,
            b"Failed to fault unclosed doc\x00" as *const u8 as *const libc::c_char,
        );
    }
    if found_cr == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3311 as libc::c_int,
            b"Did not catch the carriage return\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    /* Now with a default handler instead */
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            cr_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_cr as *mut libc::c_int as *mut libc::c_void,
    );
    found_cr = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3320 as libc::c_int,
            b"Failed to fault unclosed doc\x00" as *const u8 as *const libc::c_char,
        );
    }
    if found_cr == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3322 as libc::c_int,
            b"Did not catch default carriage return\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test trailing CR in an external entity parse */

unsafe extern "C" fn external_entity_cr_catcher(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char = b"\r\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3339 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        ext_parser,
        Some(
            cr_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3343 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn external_entity_bad_cr_catcher(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char = b"<tag>\r\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3360 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        ext_parser,
        Some(
            cr_cdata_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3364 as libc::c_int,
            b"Async entity error not caught\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_ASYNC_ENTITY as libc::c_int as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3366 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ext_entity_trailing_cr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_ext_entity_trailing_cr\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3371 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut found_cr: libc::c_int = 0;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_cr_catcher
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_cr as *mut libc::c_int as *mut libc::c_void,
    );
    found_cr = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3384 as libc::c_int,
        );
    }
    if found_cr == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3386 as libc::c_int,
            b"No carriage return found\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    /* Try again with a different trailing CR */
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_bad_cr_catcher
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_cr as *mut libc::c_int as *mut libc::c_void,
    );
    found_cr = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3396 as libc::c_int,
        );
    }
    if found_cr == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3398 as libc::c_int,
            b"No carriage return found\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test handling of trailing square bracket */

unsafe extern "C" fn rsqb_handler(
    mut userData: *mut libc::c_void,
    mut s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    let mut pfound: *mut libc::c_int = userData as *mut libc::c_int;
    if len == 1 as libc::c_int && *s as libc::c_int == ']' as i32 {
        *pfound = 1 as libc::c_int
    };
}

unsafe extern "C" fn test_trailing_rsqb() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_trailing_rsqb\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3411 as libc::c_int,
    );
    let mut text8: *const libc::c_char = b"<doc>]\x00" as *const u8 as *const libc::c_char;
    let text16: [libc::c_char; 15] = *::std::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(
        b"\xff\xfe<\x00d\x00o\x00c\x00>\x00]\x00\x00",
    );
    let mut found_rsqb: libc::c_int = 0;
    let mut text8_len: libc::c_int = ::c2rust_out::stdlib::strlen(text8) as libc::c_int;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            rsqb_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_rsqb as *mut libc::c_int as *mut libc::c_void,
    );
    found_rsqb = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(g_parser, text8, text8_len, ::c2rust_out::expat_h::XML_TRUE)
        as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3422 as libc::c_int,
            b"Failed to fault unclosed doc\x00" as *const u8 as *const libc::c_char,
        );
    }
    if found_rsqb == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3424 as libc::c_int,
            b"Did not catch the right square bracket\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Try again with a different encoding */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            rsqb_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_rsqb as *mut libc::c_int as *mut libc::c_void,
    );
    found_rsqb = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text16.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3434 as libc::c_int,
            b"Failed to fault unclosed doc\x00" as *const u8 as *const libc::c_char,
        );
    }
    if found_rsqb == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3436 as libc::c_int,
            b"Did not catch the right square bracket\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* And finally with a default handler */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            rsqb_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_rsqb as *mut libc::c_int as *mut libc::c_void,
    );
    found_rsqb = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text16.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3446 as libc::c_int,
            b"Failed to fault unclosed doc\x00" as *const u8 as *const libc::c_char,
        );
    }
    if found_rsqb == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3448 as libc::c_int,
            b"Did not catch the right square bracket\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test trailing right square bracket in an external entity parse */

unsafe extern "C" fn external_entity_rsqb_catcher(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char = b"<tag>]\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3465 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        ext_parser,
        Some(
            rsqb_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3469 as libc::c_int,
            b"Async entity error not caught\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_ASYNC_ENTITY as libc::c_int as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3471 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ext_entity_trailing_rsqb() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_ext_entity_trailing_rsqb\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3476 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut found_rsqb: libc::c_int = 0;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_rsqb_catcher
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut found_rsqb as *mut libc::c_int as *mut libc::c_void,
    );
    found_rsqb = 0 as libc::c_int;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3489 as libc::c_int,
        );
    }
    if found_rsqb == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3491 as libc::c_int,
            b"No right square bracket found\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test CDATA handling in an external entity */

unsafe extern "C" fn external_entity_good_cdata_ascii(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char = b"<a><![CDATA[<greeting>Hello, world!</greeting>]]></a>\x00"
        as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<greeting>Hello, world!</greeting>\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3511 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        ext_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        ext_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3517 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ext_entity_good_cdata() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_ext_entity_good_cdata\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3524 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_good_cdata_ascii
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3534 as libc::c_int,
        );
    };
}
/* Test user parameter settings */
/* Variable holding the expected handler userData */

static mut handler_data: *mut libc::c_void = ::c2rust_out::stddef_h::NULL as *mut libc::c_void;
/* Count of the number of times the comment handler has been invoked */

static mut comment_count: libc::c_int = 0 as libc::c_int;
/* Count of the number of skipped entities */

static mut skip_count: libc::c_int = 0 as libc::c_int;
/* Count of the number of times the XML declaration handler is invoked */

static mut xdecl_count: libc::c_int = 0 as libc::c_int;

unsafe extern "C" fn xml_decl_handler(
    mut userData: *mut libc::c_void,
    mut _version: *const crate::expat_external_h::XML_Char,
    mut _encoding: *const crate::expat_external_h::XML_Char,
    mut standalone: libc::c_int,
) {
    if userData != handler_data {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3554 as libc::c_int,
            b"User data (xml decl) not correctly set\x00" as *const u8 as *const libc::c_char,
        );
    }
    if standalone != -(1 as libc::c_int) {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3556 as libc::c_int,
            b"Standalone not flagged as not present in XML decl\x00" as *const u8
                as *const libc::c_char,
        );
    }
    xdecl_count += 1;
}

unsafe extern "C" fn param_check_skip_handler(
    mut userData: *mut libc::c_void,
    mut _entityName: *const crate::expat_external_h::XML_Char,
    mut _is_parameter_entity: libc::c_int,
) {
    if userData != handler_data {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3566 as libc::c_int,
            b"User data (skip) not correctly set\x00" as *const u8 as *const libc::c_char,
        );
    }
    skip_count += 1;
}

unsafe extern "C" fn data_check_comment_handler(
    mut userData: *mut libc::c_void,
    mut _data: *const crate::expat_external_h::XML_Char,
) {
    /* Check that the userData passed through is what we expect */
    if userData != handler_data {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3575 as libc::c_int,
            b"User data (parser) not correctly set\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Check that the user data in the parser is appropriate */
    if *(userData as *mut *mut libc::c_void) != 1 as libc::c_int as *mut libc::c_void {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3578 as libc::c_int,
            b"User data in parser not correctly set\x00" as *const u8 as *const libc::c_char,
        );
    }
    comment_count += 1;
}

unsafe extern "C" fn external_entity_param_checker(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char =
        b"<!-- Subordinate parser -->\n<!ELEMENT doc (#PCDATA)*>\x00" as *const u8
            as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3595 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    handler_data = ext_parser as *mut libc::c_void;
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3599 as libc::c_int,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    handler_data = parser as *mut libc::c_void;
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_user_parameters() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_user_parameters\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3607 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!-- Primary parse -->\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;\x00"
            as *const u8 as *const libc::c_char;
    let mut epilog: *const libc::c_char =
        b"<!-- Back to primary parser -->\n</doc>\x00" as *const u8 as *const libc::c_char;
    comment_count = 0 as libc::c_int;
    skip_count = 0 as libc::c_int;
    xdecl_count = 0 as libc::c_int;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
        g_parser,
        Some(
            xml_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_param_checker
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
        g_parser,
        Some(
            data_check_comment_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetSkippedEntityHandler(
        g_parser,
        Some(
            param_check_skip_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_UseParserAsHandlerArg(g_parser);
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        1 as libc::c_int as *mut libc::c_void,
    );
    handler_data = g_parser as *mut libc::c_void;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3628 as libc::c_int,
        );
    }
    if comment_count != 2 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3630 as libc::c_int,
            b"Comment handler not invoked enough times\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Ensure we can't change policy mid-parse */
    if ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_NEVER,
    ) != 0
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3633 as libc::c_int,
            b"Changed param entity parsing policy while parsing\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        epilog,
        ::c2rust_out::stdlib::strlen(epilog) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3636 as libc::c_int,
        );
    }
    if comment_count != 3 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3638 as libc::c_int,
            b"Comment handler not invoked enough times\x00" as *const u8 as *const libc::c_char,
        );
    }
    if skip_count != 1 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3640 as libc::c_int,
            b"Skip handler not invoked enough times\x00" as *const u8 as *const libc::c_char,
        );
    }
    if xdecl_count != 1 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3642 as libc::c_int,
            b"XML declaration handler not invoked\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that an explicit external entity handler argument replaces
 * the parser as the first argument.
 *
 * We do not call the first parameter to the external entity handler
 * 'parser' for once, since the first time the handler is called it
 * will actually be a text string.  We need to be able to access the
 * global 'parser' variable to create our external entity parser from,
 * since there are code paths we need to ensure get executed.
 */

unsafe extern "C" fn external_entity_ref_param_checker(
    mut parameter: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char =
        b"<!ELEMENT doc (#PCDATA)*>\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    if parameter as *mut libc::c_void != handler_data {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3667 as libc::c_int,
            b"External entity ref handler parameter not correct\x00" as *const u8
                as *const libc::c_char,
        );
    }
    /* Here we use the global 'parser' variable */
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        g_parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3672 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3675 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ext_entity_ref_parameter() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_ext_entity_ref_parameter\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3681 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_ref_param_checker
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    /* Set a handler arg that is not NULL and not parser (which is
     * what NULL would cause to be passed.
     */
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandlerArg(
        g_parser,
        text as *mut libc::c_void,
    );
    handler_data = text as *mut libc::c_void;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3695 as libc::c_int,
        );
    }
    /* Now try again with unset args */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_ref_param_checker
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandlerArg(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    handler_data = g_parser as *mut libc::c_void;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3705 as libc::c_int,
        );
    };
}
/* Test the parsing of an empty string */

unsafe extern "C" fn test_empty_parse() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"test_empty_parse\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3710 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc></doc>\x00" as *const u8 as *const libc::c_char;
    let mut partial: *const libc::c_char = b"<doc>\x00" as *const u8 as *const libc::c_char;
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const libc::c_char,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3715 as libc::c_int,
            b"Parsing empty string faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const libc::c_char,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3717 as libc::c_int,
            b"Parsing final empty string not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NO_ELEMENTS as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3719 as libc::c_int,
            b"Parsing final empty string faulted for wrong reason\x00" as *const u8
                as *const libc::c_char,
        );
    }
    /* Now try with valid text before the empty end */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3725 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const libc::c_char,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3727 as libc::c_int,
            b"Parsing final empty string faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Now try with invalid text before the empty end */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        partial,
        ::c2rust_out::stdlib::strlen(partial) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3734 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const libc::c_char,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3736 as libc::c_int,
            b"Parsing final incomplete empty string not faulted\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Test odd corners of the XML_GetBuffer interface */

unsafe extern "C" fn get_feature(
    mut feature_id: crate::expat_h::XML_FeatureEnum,
    mut presult: *mut libc::c_long,
) -> crate::expat_h::XML_Status {
    let mut feature: *const ::c2rust_out::expat_h::XML_Feature =
        ::c2rust_out::src::lib::xmlparse::XML_GetFeatureList()
            as *const ::c2rust_out::expat_h::XML_Feature;
    if feature.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as crate::expat_h::XML_Status;
    }
    while (*feature).feature as libc::c_uint
        != ::c2rust_out::expat_h::XML_FEATURE_END as libc::c_int as libc::c_uint
    {
        if (*feature).feature as libc::c_uint == feature_id as libc::c_uint {
            *presult = (*feature).value;
            return ::c2rust_out::expat_h::XML_STATUS_OK_0 as crate::expat_h::XML_Status;
        }
        feature = feature.offset(1)
    }
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as crate::expat_h::XML_Status;
}
/* Having an element name longer than 1024 characters exercises some
 * of the pool allocation code in the parser that otherwise does not
 * get executed.  The count at the end of the line is the number of
 * characters (bytes) in the element name by that point.x
 */

static mut get_buffer_test_text: *const libc::c_char =
    b"<documentwitharidiculouslylongelementnametoteaseaparticularcorneroftheallocationinXML_GetBuffersothatwecanimprovethecoverageyetagain012345678901123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789>\n<ef0\x00"
        as *const u8 as *const libc::c_char;
/* 0x420 */
/* Test odd corners of the XML_GetBuffer interface */

unsafe extern "C" fn test_get_buffer_1() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_get_buffer_1\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3786 as libc::c_int,
    );
    let mut text: *const libc::c_char = get_buffer_test_text;
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut context_bytes: libc::c_long = 0;
    /* Attempt to allocate a negative length buffer */
    if !::c2rust_out::src::lib::xmlparse::XML_GetBuffer(g_parser, -(12 as libc::c_int)).is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3793 as libc::c_int,
            b"Negative length buffer not failed\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Now get a small buffer and extend it past valid length */
    buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(g_parser, 1536 as libc::c_int);
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3798 as libc::c_int,
            b"1.5K buffer failed\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !buffer.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"buffer != NULL\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3799 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"void test_get_buffer_1(void)\x00",
            ))
            .as_ptr(),
        );
    }
    ::c2rust_out::stdlib::memcpy(
        buffer,
        text as *const libc::c_void,
        ::c2rust_out::stdlib::strlen(text),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3803 as libc::c_int,
        );
    }
    if !::c2rust_out::src::lib::xmlparse::XML_GetBuffer(
        g_parser,
        ::c2rust_out::src::lib::xmlparse::INT_MAX,
    )
    .is_null()
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3805 as libc::c_int,
            b"INT_MAX buffer not failed\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Now try extending it a more reasonable but still too large
     * amount.  The allocator in XML_GetBuffer() doubles the buffer
     * size until it exceeds the requested amount or INT_MAX.  If it
     * exceeds INT_MAX, it rejects the request, so we want a request
     * between INT_MAX and INT_MAX/2.  A gap of 1K seems comfortable,
     * with an extra byte just to ensure that the request is off any
     * boundary.  The request will be inflated internally by
     * XML_CONTEXT_BYTES (if defined), so we subtract that from our
     * request.
     */
    if get_feature(
        ::c2rust_out::expat_h::XML_FEATURE_CONTEXT_BYTES,
        &mut context_bytes,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        context_bytes = 0 as libc::c_int as libc::c_long
    }
    if !::c2rust_out::src::lib::xmlparse::XML_GetBuffer(
        g_parser,
        (::c2rust_out::src::lib::xmlparse::INT_MAX as libc::c_long
            - (context_bytes + 1025 as libc::c_int as libc::c_long)) as libc::c_int,
    )
    .is_null()
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3820 as libc::c_int,
            b"INT_MAX- buffer not failed\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Now try extending it a carefully crafted amount */
    if ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(g_parser, 1000 as libc::c_int).is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3824 as libc::c_int,
            b"1000 buffer failed\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test more corners of the XML_GetBuffer interface */

unsafe extern "C" fn test_get_buffer_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_get_buffer_2\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3829 as libc::c_int,
    );
    let mut text: *const libc::c_char = get_buffer_test_text;
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    /* Now get a decent buffer */
    buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(g_parser, 1536 as libc::c_int);
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3836 as libc::c_int,
            b"1.5K buffer failed\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !buffer.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"buffer != NULL\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3837 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"void test_get_buffer_2(void)\x00",
            ))
            .as_ptr(),
        );
    }
    ::c2rust_out::stdlib::memcpy(
        buffer,
        text as *const libc::c_void,
        ::c2rust_out::stdlib::strlen(text),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3841 as libc::c_int,
        );
    }
    /* Extend it, to catch a different code path */
    if ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(g_parser, 1024 as libc::c_int).is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3845 as libc::c_int,
            b"1024 buffer failed\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test position information macros */

unsafe extern "C" fn test_byte_info_at_end() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_byte_info_at_end\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3850 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc></doc>\x00" as *const u8 as *const libc::c_char;
    if ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteIndex(g_parser)
        != -(1 as libc::c_int) as libc::c_long
        || ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteCount(g_parser) != 0 as libc::c_int
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3855 as libc::c_int,
            b"Byte index/count incorrect at start of parse\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3858 as libc::c_int,
        );
    }
    /* At end, the count will be zero and the index the end of string */
    if ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteCount(g_parser) != 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3861 as libc::c_int,
            b"Terminal byte count incorrect\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteIndex(g_parser)
        != ::c2rust_out::stdlib::strlen(text) as crate::expat_external_h::XML_Index
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3863 as libc::c_int,
            b"Terminal byte index incorrect\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test position information from errors */

pub const PRE_ERROR_STR: [libc::c_char; 8] =
    unsafe { *::std::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"<doc></\x00") };

unsafe extern "C" fn test_byte_info_at_error() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_byte_info_at_error\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3870 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc></wombat></doc>\x00" as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3875 as libc::c_int,
            b"Syntax error not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteCount(g_parser) != 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3877 as libc::c_int,
            b"Error byte count incorrect\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteIndex(g_parser) as libc::c_ulong
        != ::c2rust_out::stdlib::strlen(PRE_ERROR_STR.as_ptr())
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3879 as libc::c_int,
            b"Error byte index incorrect\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn byte_character_handler(
    mut userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    let mut offset: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut buffer: *const libc::c_char = 0 as *const libc::c_char;
    let mut data: *mut ByteTestData = userData as *mut ByteTestData;
    buffer =
        ::c2rust_out::src::lib::xmlparse::XML_GetInputContext(g_parser, &mut offset, &mut size);
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3902 as libc::c_int,
            b"Failed to get context buffer\x00" as *const u8 as *const libc::c_char,
        );
    }
    if offset != (*data).start_element_len {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3904 as libc::c_int,
            b"Context offset in unexpected position\x00" as *const u8 as *const libc::c_char,
        );
    }
    if len != (*data).cdata_len {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3906 as libc::c_int,
            b"CDATA length reported incorrectly\x00" as *const u8 as *const libc::c_char,
        );
    }
    if size != (*data).total_string_len {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3908 as libc::c_int,
            b"Context size is not full buffer\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteIndex(g_parser) != offset as libc::c_long
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3910 as libc::c_int,
            b"Character byte index incorrect\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetCurrentByteCount(g_parser) != len {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3912 as libc::c_int,
            b"Character byte count incorrect\x00" as *const u8 as *const libc::c_char,
        );
    };
}

pub const START_ELEMENT: [libc::c_char; 4] =
    unsafe { *::std::mem::transmute::<&[u8; 4], &[libc::c_char; 4]>(b"<e>\x00") };

pub const CDATA_TEXT: [libc::c_char; 6] =
    unsafe { *::std::mem::transmute::<&[u8; 6], &[libc::c_char; 6]>(b"Hello\x00") };

unsafe extern "C" fn test_byte_info_at_cdata() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_byte_info_at_cdata\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3923 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<e>Hello</e>\x00" as *const u8 as *const libc::c_char;
    let mut offset: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut data: ByteTestData = ByteTestData {
        start_element_len: 0,
        cdata_len: 0,
        total_string_len: 0,
    };
    /* Check initial context is empty */
    if !::c2rust_out::src::lib::xmlparse::XML_GetInputContext(g_parser, &mut offset, &mut size)
        .is_null()
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3930 as libc::c_int,
            b"Unexpected context at start of parse\x00" as *const u8 as *const libc::c_char,
        );
    }
    data.start_element_len = ::c2rust_out::stdlib::strlen(START_ELEMENT.as_ptr()) as libc::c_int;
    data.cdata_len = ::c2rust_out::stdlib::strlen(CDATA_TEXT.as_ptr()) as libc::c_int;
    data.total_string_len = ::c2rust_out::stdlib::strlen(text) as libc::c_int;
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            byte_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut data as *mut ByteTestData as *mut libc::c_void,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3938 as libc::c_int,
        );
    };
}
/* Test predefined entities are correctly recognised */

unsafe extern "C" fn test_predefined_entities() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_predefined_entities\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3946 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc>&lt;&gt;&amp;&quot;&apos;</doc>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<doc>&lt;&gt;&amp;&quot;&apos;</doc>\x00" as *const u8 as *const libc::c_char;
    let mut result: *const crate::expat_external_h::XML_Char =
        b"<>&\"\'\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    /* run_character_check uses XML_SetCharacterDataHandler(), which
     * unfortunately heads off a code path that we need to exercise.
     */
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3960 as libc::c_int,
        );
    }
    /* The default handler doesn't translate the entities */
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
    /* Now try again and check the translation */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    _run_character_check(
        text,
        result,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        3966 as libc::c_int,
    );
}
/* Regression test that an invalid tag in an external parameter
 * reference in an external DTD is correctly faulted.
 *
 * Only a few specific tags are legal in DTDs ignoring comments and
 * processing instructions, all of which begin with an exclamation
 * mark.  "<el/>" is not one of them, so the parser should raise an
 * error on encountering it.
 */

unsafe extern "C" fn external_entity_param(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text1: *const libc::c_char =
        b"<!ELEMENT doc EMPTY>\n<!ENTITY % e1 SYSTEM \'004-2.ent\'>\n<!ENTITY % e2 \'%e1;\'>\n%e1;\n\x00"
            as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<!ELEMENT el EMPTY>\n<el/>\n\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    if systemId.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_OK_0;
    }
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            3997 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::libc::strcmp(
        systemId,
        b"004-1.ent\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        if _XML_Parse_SINGLE_BYTES(
            ext_parser,
            text1,
            ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4002 as libc::c_int,
                b"Inner DTD with invalid tag not rejected\x00" as *const u8 as *const libc::c_char,
            );
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING as libc::c_int
                as libc::c_uint
        {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4004 as libc::c_int,
            );
        }
    } else if ::libc::strcmp(
        systemId,
        b"004-2.ent\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        if _XML_Parse_SINGLE_BYTES(
            ext_parser,
            text2,
            ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4008 as libc::c_int,
                b"Invalid tag in external param not rejected\x00" as *const u8
                    as *const libc::c_char,
            );
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_SYNTAX as libc::c_int as libc::c_uint
        {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4010 as libc::c_int,
            );
        }
    } else {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4012 as libc::c_int,
            b"Unknown system ID\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}

unsafe extern "C" fn test_invalid_tag_in_dtd() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_invalid_tag_in_dtd\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4019 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc SYSTEM \'004-1.ent\'>\n<doc></doc>\n\x00"
        as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_param
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Invalid tag IN DTD external param not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4026 as libc::c_int,
    );
}
/* Test entities not quite the predefined ones are not mis-recognised */

unsafe extern "C" fn test_not_predefined_entities() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_not_predefined_entities\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4031 as libc::c_int,
    );
    let mut text: [*const libc::c_char; 5] = [
        b"<doc>&pt;</doc>\x00" as *const u8 as *const libc::c_char,
        b"<doc>&amo;</doc>\x00" as *const u8 as *const libc::c_char,
        b"<doc>&quid;</doc>\x00" as *const u8 as *const libc::c_char,
        b"<doc>&apod;</doc>\x00" as *const u8 as *const libc::c_char,
        ::c2rust_out::stddef_h::NULL as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0 as libc::c_int;
    while !text[i as usize].is_null() {
        _expect_failure(
            text[i as usize],
            ::c2rust_out::expat_h::XML_ERROR_UNDEFINED_ENTITY,
            b"Undefined entity not rejected\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4038 as libc::c_int,
        );
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        i += 1
    }
}
/* Test conditional inclusion (IGNORE) */

unsafe extern "C" fn external_entity_load_ignore(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char =
        b"<![IGNORE[<!ELEMENT e (#PCDATA)*>]]>\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4058 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4061 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ignore_section() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_ignore_section\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4067 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\'>\n<doc><e>&entity;</e></doc>\x00" as *const u8
            as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<![IGNORE[<!ELEMENT e (#PCDATA)*>]]>\n&entity;\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_load_ignore
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartDoctypeDeclHandler(
        g_parser,
        Some(
            dummy_start_doctype_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndDoctypeDeclHandler(
        g_parser,
        Some(dummy_end_doctype_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            dummy_element_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            dummy_start_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndElementHandler(
        g_parser,
        Some(
            dummy_end_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4086 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn external_entity_load_ignore_utf16(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let text: [libc::c_char; 73] =
        *::std::mem::transmute::<&[u8; 73],
                                 &[libc::c_char; 73]>(b"<\x00!\x00[\x00I\x00G\x00N\x00O\x00R\x00E\x00[\x00<\x00!\x00E\x00L\x00E\x00M\x00E\x00N\x00T\x00 \x00e\x00 \x00(\x00#\x00P\x00C\x00D\x00A\x00T\x00A\x00)\x00*\x00>\x00]\x00]\x00>\x00\x00");
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4108 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 73]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4111 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ignore_section_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_ignore_section_utf16\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4117 as libc::c_int,
    );
    let text: [libc::c_char; 85] =
        *::std::mem::transmute::<&[u8; 85],
                                 &[libc::c_char; 85]>(b"<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00 \x00S\x00Y\x00S\x00T\x00E\x00M\x00 \x00\'\x00s\x00\'\x00>\x00\n\x00<\x00d\x00>\x00<\x00e\x00>\x00&\x00e\x00n\x00;\x00<\x00/\x00e\x00>\x00<\x00/\x00d\x00>\x00\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<![IGNORE[<!ELEMENT e (#PCDATA)*>]]>\n&en;\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_load_ignore_utf16
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartDoctypeDeclHandler(
        g_parser,
        Some(
            dummy_start_doctype_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndDoctypeDeclHandler(
        g_parser,
        Some(dummy_end_doctype_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            dummy_element_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            dummy_start_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndElementHandler(
        g_parser,
        Some(
            dummy_end_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 85]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4139 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn external_entity_load_ignore_utf16_be(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let text: [libc::c_char; 73] =
        *::std::mem::transmute::<&[u8; 73],
                                 &[libc::c_char; 73]>(b"\x00<\x00!\x00[\x00I\x00G\x00N\x00O\x00R\x00E\x00[\x00<\x00!\x00E\x00L\x00E\x00M\x00E\x00N\x00T\x00 \x00e\x00 \x00(\x00#\x00P\x00C\x00D\x00A\x00T\x00A\x00)\x00*\x00>\x00]\x00]\x00>\x00");
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4161 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 73]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4164 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ignore_section_utf16_be() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_ignore_section_utf16_be\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4170 as libc::c_int,
    );
    let text: [libc::c_char; 85] =
        *::std::mem::transmute::<&[u8; 85],
                                 &[libc::c_char; 85]>(b"\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00 \x00S\x00Y\x00S\x00T\x00E\x00M\x00 \x00\'\x00s\x00\'\x00>\x00\n\x00<\x00d\x00>\x00<\x00e\x00>\x00&\x00e\x00n\x00;\x00<\x00/\x00e\x00>\x00<\x00/\x00d\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<![IGNORE[<!ELEMENT e (#PCDATA)*>]]>\n&en;\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_load_ignore_utf16_be
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartDoctypeDeclHandler(
        g_parser,
        Some(
            dummy_start_doctype_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndDoctypeDeclHandler(
        g_parser,
        Some(dummy_end_doctype_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            dummy_element_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            dummy_start_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndElementHandler(
        g_parser,
        Some(
            dummy_end_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 85]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4193 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test mis-formatted conditional exclusion */

unsafe extern "C" fn test_bad_ignore_section() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_bad_ignore_section\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4199 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\'>\n<doc><e>&entity;</e></doc>\x00" as *const u8
            as *const libc::c_char;
    let mut faults: [ExtFaults; 4] = [
        {
            let mut init = ext_faults {
                parse_text: b"<![IGNORE[<!ELEM\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Broken-off declaration not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<![IGNORE[\x01]]>\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Invalid XML character not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<![IGNORE[\xe2\x82\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Partial XML character not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                fail_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_NONE,
            };
            init
        },
    ];
    let mut fault: *mut ExtFaults = 0 as *mut ExtFaults;
    fault = &mut *faults.as_mut_ptr().offset(0 as libc::c_int as isize) as *mut ExtFaults;
    while !(*fault).parse_text.is_null() {
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_faulter
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(g_parser, fault as *mut libc::c_void);
        _expect_failure(
            text,
            ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
            b"Incomplete IGNORE section not failed\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4218 as libc::c_int,
        );
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        fault = fault.offset(1)
    }
}
/* Test recursive parsing */

unsafe extern "C" fn external_entity_valuer(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text1: *const libc::c_char =
        b"<!ELEMENT doc EMPTY>\n<!ENTITY % e1 SYSTEM \'004-2.ent\'>\n<!ENTITY % e2 \'%e1;\'>\n%e1;\n\x00"
            as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    if systemId.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_OK_0;
    }
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4241 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::libc::strcmp(
        systemId,
        b"004-1.ent\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        if _XML_Parse_SINGLE_BYTES(
            ext_parser,
            text1,
            ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4245 as libc::c_int,
            );
        }
    } else if ::libc::strcmp(
        systemId,
        b"004-2.ent\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        let mut fault: *mut ExtFaults = *(parser as *mut *mut libc::c_void) as *mut ExtFaults;
        let mut status: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
        let mut error: crate::expat_h::XML_Error = ::c2rust_out::expat_h::XML_ERROR_NONE;
        status = _XML_Parse_SINGLE_BYTES(
            ext_parser,
            (*fault).parse_text,
            ::c2rust_out::stdlib::strlen((*fault).parse_text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        );
        if (*fault).error as libc::c_uint
            == ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
        {
            if status as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
                _xml_failure(
                    ext_parser,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    4255 as libc::c_int,
                );
            }
        } else {
            if status as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
                ::c2rust_out::src::tests::minicheck::_fail_unless(
                    0 as libc::c_int,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    4258 as libc::c_int,
                    (*fault).fail_text,
                );
            }
            error = ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser);
            if error as libc::c_uint != (*fault).error as libc::c_uint
                && ((*fault).error as libc::c_uint
                    != ::c2rust_out::expat_h::XML_ERROR_XML_DECL as libc::c_int as libc::c_uint
                    || error as libc::c_uint
                        != ::c2rust_out::expat_h::XML_ERROR_TEXT_DECL as libc::c_int
                            as libc::c_uint)
            {
                _xml_failure(
                    ext_parser,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    4263 as libc::c_int,
                );
            }
        }
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_external_entity_values() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_external_entity_values\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4271 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc SYSTEM \'004-1.ent\'>\n<doc></doc>\n\x00"
        as *const u8 as *const libc::c_char;
    let mut data_004_2: [ExtFaults; 12] = [
        {
            let mut init = ext_faults {
                parse_text: b"<!ATTLIST doc a1 CDATA \'value\'>\x00" as *const u8
                    as *const libc::c_char,
                fail_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_NONE,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<!ATTLIST $doc a1 CDATA \'value\'>\x00" as *const u8
                    as *const libc::c_char,
                fail_text: b"Invalid token not faulted\x00" as *const u8 as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"\'wombat\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Unterminated string not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"\xe2\x82\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Partial UTF-8 character not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n\x00" as *const u8
                    as *const libc::c_char,
                fail_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_NONE,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<?xml?>\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Malformed XML declaration not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_XML_DECL,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"\xef\xbb\xbf<!ATTLIST doc a1 CDATA \'value\'>\x00" as *const u8
                    as *const libc::c_char,
                fail_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_NONE,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n$\x00" as *const u8
                    as *const libc::c_char,
                fail_text: b"Invalid token after text declaration not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n\'wombat\x00" as *const u8
                    as *const libc::c_char,
                fail_text: b"Unterminated string after text decl not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n\xe2\x82\x00" as *const u8
                    as *const libc::c_char,
                fail_text: b"Partial UTF-8 character after text decl not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: b"%e1;\x00" as *const u8 as *const libc::c_char,
                fail_text: b"Recursive parameter entity not faulted\x00" as *const u8
                    as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_RECURSIVE_ENTITY_REF,
            };
            init
        },
        {
            let mut init = ext_faults {
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                fail_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
                encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                error: ::c2rust_out::expat_h::XML_ERROR_NONE,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !data_004_2[i as usize].parse_text.is_null() {
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_valuer
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            &mut *data_004_2.as_mut_ptr().offset(i as isize) as *mut ExtFaults as *mut libc::c_void,
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                g_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4308 as libc::c_int,
            );
        }
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        i += 1
    }
}
/* Test the recursive parse interacts with a not standalone handler */

unsafe extern "C" fn external_entity_not_standalone(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text1: *const libc::c_char =
        b"<!ELEMENT doc EMPTY>\n<!ENTITY % e1 SYSTEM \'bar\'>\n%e1;\n\x00" as *const u8
            as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<!ATTLIST doc a1 CDATA \'value\'>\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    if systemId.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_OK_0;
    }
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4331 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::libc::strcmp(systemId, b"foo\x00" as *const u8 as *const libc::c_char) == 0 {
        ::c2rust_out::src::lib::xmlparse::XML_SetNotStandaloneHandler(
            ext_parser,
            Some(
                reject_not_standalone_handler
                    as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            ext_parser,
            text1,
            ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4336 as libc::c_int,
                b"Expected not standalone rejection\x00" as *const u8 as *const libc::c_char,
            );
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_NOT_STANDALONE as libc::c_int as libc::c_uint
        {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4338 as libc::c_int,
            );
        }
        ::c2rust_out::src::lib::xmlparse::XML_SetNotStandaloneHandler(
            ext_parser,
            ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_NotStandaloneHandler>(
                ::c2rust_out::stddef_h::NULL as libc::intptr_t,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    } else {
        if ::libc::strcmp(systemId, b"bar\x00" as *const u8 as *const libc::c_char) == 0 {
            if _XML_Parse_SINGLE_BYTES(
                ext_parser,
                text2,
                ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
                ::c2rust_out::expat_h::XML_TRUE,
            ) as libc::c_uint
                == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
            {
                _xml_failure(
                    ext_parser,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    4345 as libc::c_int,
                );
            }
        }
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ext_entity_not_standalone() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_ext_entity_not_standalone\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4352 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\'>\n<doc></doc>\x00" as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_not_standalone
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Standalone rejection not caught\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4359 as libc::c_int,
    );
}

unsafe extern "C" fn external_entity_value_aborter(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text1: *const libc::c_char =
        b"<!ELEMENT doc EMPTY>\n<!ENTITY % e1 SYSTEM \'004-2.ent\'>\n<!ENTITY % e2 \'%e1;\'>\n%e1;\n\x00"
            as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    if systemId.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_OK_0;
    }
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4380 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::libc::strcmp(
        systemId,
        b"004-1.ent\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        if _XML_Parse_SINGLE_BYTES(
            ext_parser,
            text1,
            ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4384 as libc::c_int,
            );
        }
    }
    if ::libc::strcmp(
        systemId,
        b"004-2.ent\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
            ext_parser,
            Some(
                entity_suspending_xdecl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            ext_parser,
            ext_parser as *mut libc::c_void,
        );
        if _XML_Parse_SINGLE_BYTES(
            ext_parser,
            text2,
            ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4391 as libc::c_int,
                b"Aborted parse not faulted\x00" as *const u8 as *const libc::c_char,
            );
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(ext_parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_ABORTED as libc::c_int as libc::c_uint
        {
            _xml_failure(
                ext_parser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                4393 as libc::c_int,
            );
        }
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_ext_entity_value_abort() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_ext_entity_value_abort\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4400 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc SYSTEM \'004-1.ent\'>\n<doc></doc>\n\x00"
        as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_value_aborter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4409 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_bad_public_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_bad_public_doctype\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4413 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<!DOCTYPE doc PUBLIC \'{BadName}\' \'test\'>\n<doc></doc>\x00"
            as *const u8 as *const libc::c_char;
    /* Setting a handler provokes a particular code path */
    ::c2rust_out::src::lib::xmlparse::XML_SetDoctypeDeclHandler(
        g_parser,
        Some(
            dummy_start_doctype_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
        Some(dummy_end_doctype_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_PUBLICID,
        b"Bad Public ID not failed\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4421 as libc::c_int,
    );
}
/* Test based on ibm/valid/P32/ibm32v04.xml */

unsafe extern "C" fn test_attribute_enum_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_attribute_enum_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4426 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' standalone=\'no\'?>\n<!DOCTYPE animal SYSTEM \'test.dtd\'>\n<animal>This is a \n    <a/>  \n\nyellow tiger</animal>\x00"
            as *const u8 as *const libc::c_char;
    let mut dtd_data: ExtTest = {
        let mut init =
                ExtTest{parse_text:
                            b"<!ELEMENT animal (#PCDATA|a)*>\n<!ELEMENT a EMPTY>\n<!ATTLIST animal xml:space (default|preserve) \'preserve\'>\x00"
                                as *const u8 as *const libc::c_char,
                        encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                        storage: ::c2rust_out::stddef_h::NULL as *mut ::c2rust_out::src::tests::chardata::CharData,};
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"This is a \n      \n\nyellow tiger\x00" as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut dtd_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    /* An attribute list handler provokes a different code path */
    ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
        g_parser,
        Some(
            dummy_attlist_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    _run_ext_character_check(
        text,
        &mut dtd_data,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4442 as libc::c_int,
    );
}
/* Slightly bizarrely, the library seems to silently ignore entity
 * definitions for predefined entities, even when they are wrong.  The
 * language of the XML 1.0 spec is somewhat unhelpful as to what ought
 * to happen, so this is currently treated as acceptable.
 */

unsafe extern "C" fn test_predefined_entity_redefinition() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_predefined_entity_redefinition\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4451 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY apos \'foo\'>\n]>\n<doc>&apos;</doc>\x00" as *const u8
            as *const libc::c_char;
    _run_character_check(
        text,
        b"\'\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4456 as libc::c_int,
    );
}
/* Test that the parser stops processing the DTD after an unresolved
 * parameter entity is encountered.
 */

unsafe extern "C" fn test_dtd_stop_processing() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_dtd_stop_processing\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4463 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n%foo;\n<!ENTITY bar \'bas\'>\n]><doc/>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
        g_parser,
        Some(
            dummy_entity_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4473 as libc::c_int,
        );
    }
    if dummy_handler_flags != 0 as libc::c_int as libc::c_ulong {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4475 as libc::c_int,
            b"DTD processing still going after undefined PE\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Test public notations with no system ID */

unsafe extern "C" fn test_public_notation_no_sysid() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_public_notation_no_sysid\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4480 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!NOTATION note PUBLIC \'foo\'>\n<!ELEMENT doc EMPTY>\n]>\n<doc/>\x00"
            as *const u8 as *const libc::c_char;
    dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
    ::c2rust_out::src::lib::xmlparse::XML_SetNotationDeclHandler(
        g_parser,
        Some(
            dummy_notation_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4490 as libc::c_int,
        );
    }
    if dummy_handler_flags != DUMMY_NOTATION_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4492 as libc::c_int,
            b"Notation declaration handler not called\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn record_element_start_handler(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
    mut _atts: *mut *const crate::expat_external_h::XML_Char,
) {
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        userData as *mut ::c2rust_out::src::tests::chardata::CharData
            as *mut ::c2rust_out::src::tests::chardata::CharData,
        name,
        ::c2rust_out::stdlib::strlen(name) as libc::c_int,
    );
}

unsafe extern "C" fn test_nested_groups() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_nested_groups\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4503 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (e,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?))))))))))))))))))))))))))))))))>\n<!ELEMENT e EMPTY>]>\n<doc><e/></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            dummy_element_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            record_element_start_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4523 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"doce\x00" as *const u8 as *const libc::c_char,
    );
    if dummy_handler_flags != DUMMY_ELEMENT_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4526 as libc::c_int,
            b"Element handler not fired\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_group_choice() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_group_choice\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4530 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (a|b|c)+>\n<!ELEMENT a EMPTY>\n<!ELEMENT b (#PCDATA)>\n<!ELEMENT c ANY>\n]>\n<doc>\n<a/>\n<b attr=\'foo\'>This is a foo</b>\n<c></c>\n</doc>\n\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            dummy_element_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4547 as libc::c_int,
        );
    }
    if dummy_handler_flags != DUMMY_ELEMENT_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4549 as libc::c_int,
            b"Element handler flag not raised\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn external_entity_public(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut systemId: *const crate::expat_external_h::XML_Char,
    mut publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text1: *const libc::c_char = *(parser as *mut *mut libc::c_void) as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<!ATTLIST doc a CDATA \'value\'>\x00" as *const u8 as *const libc::c_char;
    let mut text: *const libc::c_char = ::c2rust_out::stddef_h::NULL as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut parse_res: libc::c_int = 0;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    if !systemId.is_null()
        && ::libc::strcmp(
            systemId,
            b"http://example.org/\x00" as *const u8 as *const libc::c_char,
        ) == 0
    {
        text = text1
    } else if !publicId.is_null()
        && ::libc::strcmp(publicId, b"foo\x00" as *const u8 as *const libc::c_char) == 0
    {
        text = text2
    } else {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4572 as libc::c_int,
            b"Unexpected parameters to external entity parser\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if !text.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(b"text != NULL\x00" as *const u8 as *const libc::c_char,
                      b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                          as *const u8 as *const libc::c_char,
                      4573 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 111],
                                                &[libc::c_char; 111]>(b"int external_entity_public(XML_Parser, const XML_Char *, const XML_Char *, const XML_Char *, const XML_Char *)\x00")).as_ptr());
    }
    parse_res = _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_int;
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return parse_res;
}

unsafe extern "C" fn test_standalone_parameter_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_standalone_parameter_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4580 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' standalone=\'yes\'?>\n<!DOCTYPE doc SYSTEM \'http://example.org/\' [\n<!ENTITY % entity \'<!ELEMENT doc (#PCDATA)>\'>\n%entity;\n]>\n<doc></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut dtd_data: [libc::c_char; 22] = *::std::mem::transmute::<
        &[u8; 22],
        &mut [libc::c_char; 22],
    >(b"<!ENTITY % e1 \'foo\'>\n\x00");
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        dtd_data.as_mut_ptr() as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_public
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4594 as libc::c_int,
        );
    };
}
/* Test skipping of parameter entity in an external DTD */
/* Derived from ibm/invalid/P69/ibm69i01.xml */

unsafe extern "C" fn test_skipped_parameter_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_skipped_parameter_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4600 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\'?>\n<!DOCTYPE root SYSTEM \'http://example.org/dtd.ent\' [\n<!ELEMENT root (#PCDATA|a)* >\n]>\n<root></root>\x00"
            as *const u8 as *const libc::c_char;
    let mut dtd_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"%pe2;\x00" as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut dtd_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetSkippedEntityHandler(
        g_parser,
        Some(
            dummy_skip_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4615 as libc::c_int,
        );
    }
    if dummy_handler_flags != DUMMY_SKIP_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4617 as libc::c_int,
            b"Skip handler not executed\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test recursive parameter entity definition rejected in external DTD */

unsafe extern "C" fn test_recursive_external_parameter_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
            b"test_recursive_external_parameter_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4622 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\'?>\n<!DOCTYPE root SYSTEM \'http://example.org/dtd.ent\' [\n<!ELEMENT root (#PCDATA|a)* >\n]>\n<root></root>\x00"
            as *const u8 as *const libc::c_char;
    let mut dtd_data: ExtFaults = {
        let mut init = ext_faults {
            parse_text: b"<!ENTITY % pe2 \'&#37;pe2;\'>\n%pe2;\x00" as *const u8
                as *const libc::c_char,
            fail_text: b"Recursive external parameter entity not faulted\x00" as *const u8
                as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            error: ::c2rust_out::expat_h::XML_ERROR_RECURSIVE_ENTITY_REF,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_faulter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut dtd_data as *mut ExtFaults as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Recursive external parameter not spotted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4636 as libc::c_int,
    );
}
/* Test undefined parameter entity in external entity handler */

unsafe extern "C" fn external_entity_devaluer(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char =
        b"<!ELEMENT doc EMPTY>\n<!ENTITY % e1 SYSTEM \'bar\'>\n%e1;\n\x00" as *const u8
            as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut clear_handler: crate::stdlib::intptr_t =
        *(parser as *mut *mut libc::c_void) as crate::stdlib::intptr_t;
    if systemId.is_null()
        || ::libc::strcmp(systemId, b"bar\x00" as *const u8 as *const libc::c_char) == 0
    {
        return ::c2rust_out::expat_h::XML_STATUS_OK_0;
    }
    if ::libc::strcmp(systemId, b"foo\x00" as *const u8 as *const libc::c_char) != 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4656 as libc::c_int,
            b"Unexpected system ID\x00" as *const u8 as *const libc::c_char,
        );
    }
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4659 as libc::c_int,
            b"Could note create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if clear_handler != 0 {
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            ext_parser,
            ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_ExternalEntityRefHandler>(
                ::c2rust_out::stddef_h::NULL as libc::intptr_t,
            ),
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4664 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_undefined_ext_entity_in_external_dtd() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 42], &[libc::c_char; 42]>(
            b"test_undefined_ext_entity_in_external_dtd\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4670 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\'>\n<doc></doc>\n\x00" as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_devaluer
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(g_parser, 0 as *mut libc::c_void);
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4679 as libc::c_int,
        );
    }
    /* Now repeat without the external entity ref handler invoking
     * another copy of itself.
     */
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_devaluer
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool as crate::stdlib::intptr_t
            as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4690 as libc::c_int,
        );
    };
}

unsafe extern "C" fn aborting_xdecl_handler(
    mut _userData: *mut libc::c_void,
    mut _version: *const crate::expat_external_h::XML_Char,
    mut _encoding: *const crate::expat_external_h::XML_Char,
    mut _standalone: libc::c_int,
) {
    ::c2rust_out::src::lib::xmlparse::XML_StopParser(g_parser, resumable);
    ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
        g_parser,
        ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_XmlDeclHandler>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        ),
    );
}
/* Test suspending the parse on receiving an XML declaration works */

unsafe extern "C" fn test_suspend_xdecl() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_suspend_xdecl\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4706 as libc::c_int,
    );
    let mut text: *const libc::c_char = long_character_data_text;
    ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
        g_parser,
        Some(
            aborting_xdecl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4713 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4715 as libc::c_int,
        );
    }
    /* Attempt to start a new parse while suspended */
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4719 as libc::c_int,
            b"Attempt to parse while suspended not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_SUSPENDED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4721 as libc::c_int,
            b"Suspended parse not faulted with correct error\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Test aborting the parse in an epilog works */

unsafe extern "C" fn selective_aborting_default_handler(
    mut userData: *mut libc::c_void,
    mut s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    let mut match_0: *const crate::expat_external_h::XML_Char =
        userData as *const crate::expat_external_h::XML_Char;
    if match_0.is_null()
        || ::c2rust_out::stdlib::strlen(match_0) == len as libc::c_uint as libc::c_ulong
            && crate::stdlib::strncmp(match_0, s, len as libc::c_ulong) == 0
    {
        ::c2rust_out::src::lib::xmlparse::XML_StopParser(g_parser, resumable);
        ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
            g_parser,
            ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_DefaultHandler>(
                ::c2rust_out::stddef_h::NULL as libc::intptr_t,
            ),
        );
    };
}

unsafe extern "C" fn test_abort_epilog() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_abort_epilog\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4737 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc></doc>\n\r\n\x00" as *const u8 as *const libc::c_char;
    let mut match_0: [crate::expat_external_h::XML_Char; 2] =
        *::std::mem::transmute::<&[u8; 2], &mut [crate::expat_external_h::XML_Char; 2]>(b"\r\x00");
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            selective_aborting_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        match_0.as_mut_ptr() as *mut libc::c_void,
    );
    resumable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4746 as libc::c_int,
            b"Abort not triggered\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_ABORTED as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4748 as libc::c_int,
        );
    };
}
/* Test a different code path for abort in the epilog */

unsafe extern "C" fn test_abort_epilog_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_abort_epilog_2\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4753 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc></doc>\n\x00" as *const u8 as *const libc::c_char;
    let mut match_0: [crate::expat_external_h::XML_Char; 2] =
        *::std::mem::transmute::<&[u8; 2], &mut [crate::expat_external_h::XML_Char; 2]>(b"\n\x00");
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            selective_aborting_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        match_0.as_mut_ptr() as *mut libc::c_void,
    );
    resumable = ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_ABORTED,
        b"Abort not triggered\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4760 as libc::c_int,
    );
}
/* Test suspension from the epilog */

unsafe extern "C" fn test_suspend_epilog() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_suspend_epilog\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4765 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc></doc>\n\x00" as *const u8 as *const libc::c_char;
    let mut match_0: [crate::expat_external_h::XML_Char; 2] =
        *::std::mem::transmute::<&[u8; 2], &mut [crate::expat_external_h::XML_Char; 2]>(b"\n\x00");
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            selective_aborting_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        match_0.as_mut_ptr() as *mut libc::c_void,
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4774 as libc::c_int,
        );
    };
}

unsafe extern "C" fn suspending_end_handler(
    mut userData: *mut libc::c_void,
    mut _s: *const crate::expat_external_h::XML_Char,
) {
    ::c2rust_out::src::lib::xmlparse::XML_StopParser(
        userData as crate::expat_h::XML_Parser,
        1 as libc::c_int as crate::expat_h::XML_Bool,
    );
}

unsafe extern "C" fn test_suspend_in_sole_empty_tag() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_suspend_in_sole_empty_tag\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4784 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc/>\x00" as *const u8 as *const libc::c_char;
    let mut rc: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    ::c2rust_out::src::lib::xmlparse::XML_SetEndElementHandler(
        g_parser,
        Some(
            suspending_end_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(g_parser, g_parser as *mut libc::c_void);
    rc = _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    if rc as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4792 as libc::c_int,
        );
    } else if rc as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4794 as libc::c_int,
            b"Suspend not triggered\x00" as *const u8 as *const libc::c_char,
        );
    }
    rc = ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser);
    if rc as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4797 as libc::c_int,
        );
    } else if rc as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4799 as libc::c_int,
            b"Resume failed\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_unfinished_epilog() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_unfinished_epilog\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4803 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc></doc><\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNCLOSED_TOKEN,
        b"Incomplete epilog entry not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4807 as libc::c_int,
    );
}

unsafe extern "C" fn test_partial_char_in_epilog() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_partial_char_in_epilog\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4811 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc></doc>\xe2\x82\x00" as *const u8 as *const libc::c_char;
    /* First check that no fault is raised if the parse is not finished */
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4817 as libc::c_int,
        );
    }
    /* Now check that it is faulted once we finish */
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4820 as libc::c_int,
            b"Partial character in epilog not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_PARTIAL_CHAR as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4822 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_hash_collision() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_hash_collision\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4826 as libc::c_int,
    );
    /* For full coverage of the lookup routine, we need to ensure a
     * hash collision even though we can only tell that we have one
     * through breakpoint debugging or coverage statistics.  The
     * following will cause a hash collision on machines with a 64-bit
     * long type; others will have to experiment.  The full coverage
     * tests invoked from qa.sh usually provide a hash collision, but
     * not always.  This is an attempt to provide insurance.
     */
    let mut text: *const libc::c_char =
        b"<doc>\n<a1/><a2/><a3/><a4/><a5/><a6/><a7/><a8/>\n<b1></b1><b2 attr=\'foo\'>This is a foo</b2><b3></b3><b4></b4>\n<b5></b5><b6></b6><b7></b7><b8></b8>\n<c1/><c2/><c3/><c4/><c5/><c6/><c7/><c8/>\n<d1/><d2/><d3/><d4/><d5/><d6/><d7/>\n<d8>This triggers the table growth and collides with b2</d8>\n</doc>\n\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetHashSalt(
        g_parser,
        (0xffffffff as libc::c_uint as crate::stdlib::uint64_t) << 32 as libc::c_int
            | 0xff99fc90 as libc::c_uint as libc::c_ulong,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4849 as libc::c_int,
        );
    };
}
/* Test resuming a parse suspended in entity substitution */

unsafe extern "C" fn start_element_suspender(
    mut _userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
    mut _atts: *mut *const crate::expat_external_h::XML_Char,
) {
    if ::libc::strcmp(name, b"suspend\x00" as *const u8 as *const libc::c_char) == 0 {
        ::c2rust_out::src::lib::xmlparse::XML_StopParser(
            g_parser,
            ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
        );
    }
    if ::libc::strcmp(name, b"abort\x00" as *const u8 as *const libc::c_char) == 0 {
        ::c2rust_out::src::lib::xmlparse::XML_StopParser(
            g_parser,
            ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool,
        );
    };
}

unsafe extern "C" fn test_suspend_resume_internal_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_suspend_resume_internal_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4866 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY foo \'<suspend>Hi<suspend>Ho</suspend></suspend>\'>\n]>\n<doc>&foo;</doc>\n\x00"
            as *const u8 as *const libc::c_char;
    let mut expected1: *const crate::expat_external_h::XML_Char =
        b"Hi\x00" as *const u8 as *const libc::c_char;
    let mut expected2: *const crate::expat_external_h::XML_Char =
        b"HiHo\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            start_element_suspender
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4882 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"\x00" as *const u8 as *const libc::c_char,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4885 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected1,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4888 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected2,
    );
}
/* Test syntax error is caught at parse resumption */

unsafe extern "C" fn test_resume_entity_with_syntax_error() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_resume_entity_with_syntax_error\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4894 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY foo \'<suspend>Hi</wombat>\'>\n]>\n<doc>&foo;</doc>\n\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            start_element_suspender
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4903 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4905 as libc::c_int,
            b"Syntax error in entity not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_TAG_MISMATCH as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4907 as libc::c_int,
        );
    };
}
/* Test suspending and resuming in a parameter entity substitution */

unsafe extern "C" fn element_decl_suspender(
    mut _userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut model: *mut crate::expat_h::XML_Content,
) {
    ::c2rust_out::src::lib::xmlparse::XML_StopParser(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
    );
    ::c2rust_out::src::lib::xmlparse::XML_FreeContentModel(
        g_parser,
        model as *mut ::c2rust_out::expat_h::XML_cp,
    );
}

unsafe extern "C" fn test_suspend_resume_parameter_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_suspend_resume_parameter_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4921 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY % foo \'<!ELEMENT doc (#PCDATA)*>\'>\n%foo;\n]>\n<doc>Hello, world</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"Hello, world\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
        g_parser,
        ::std::mem::transmute(Some(
            element_decl_suspender
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut crate::expat_h::XML_Content,
                ) -> (),
        )),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4937 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"\x00" as *const u8 as *const libc::c_char,
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4940 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test attempting to use parser after an error is faulted */

unsafe extern "C" fn test_restart_on_error() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_restart_on_error\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4946 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<$doc><doc></doc>\x00" as *const u8 as *const libc::c_char;
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4951 as libc::c_int,
            b"Invalid tag name not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4953 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const libc::c_char,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4955 as libc::c_int,
            b"Restarting invalid parse not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4957 as libc::c_int,
        );
    };
}
/* Test that angle brackets in an attribute default value are faulted */

unsafe extern "C" fn test_reject_lt_in_attribute_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_reject_lt_in_attribute_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4962 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [<!ATTLIST doc a CDATA \'<bar>\'>]>\n<doc></doc>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Bad attribute default not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4967 as libc::c_int,
    );
}

unsafe extern "C" fn test_reject_unfinished_param_in_att_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 42], &[libc::c_char; 42]>(
            b"test_reject_unfinished_param_in_att_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4971 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [<!ATTLIST doc a CDATA \'&foo\'>]>\n<doc></doc>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Bad attribute default not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4976 as libc::c_int,
    );
}

unsafe extern "C" fn test_trailing_cr_in_att_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_trailing_cr_in_att_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4980 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc a=\'value\r\'/>\x00" as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            4985 as libc::c_int,
        );
    };
}
/* Try parsing a general entity within a parameter entity in a
 * standalone internal DTD.  Covers a corner case in the parser.
 */

unsafe extern "C" fn test_standalone_internal_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_standalone_internal_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        4992 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' standalone=\'yes\' ?>\n<!DOCTYPE doc [\n  <!ELEMENT doc (#PCDATA)>\n  <!ENTITY % pe \'<!ATTLIST doc att2 CDATA \"&ge;\">\'>\n  <!ENTITY ge \'AttDefaultValue\'>\n  %pe;\n]>\n<doc att2=\'any\'/>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5005 as libc::c_int,
        );
    };
}
/* Test that a reference to an unknown external entity is skipped */

unsafe extern "C" fn test_skipped_external_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_skipped_external_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5010 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'http://example.org/\'>\n<doc></doc>\n\x00" as *const u8
            as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ELEMENT doc EMPTY>\n<!ENTITY % e2 \'%e1;\'>\n\x00" as *const u8
                as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5022 as libc::c_int,
        );
    };
}

unsafe extern "C" fn external_entity_oneshot_loader(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut test_data: *mut ExtHdlrData = *(parser as *mut *mut libc::c_void) as *mut ExtHdlrData;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5044 as libc::c_int,
            b"Could not create external entity parser.\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Use the requested entity parser for further externals */
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        ext_parser,
        (*test_data).handler,
    );
    if _XML_Parse_SINGLE_BYTES(
        ext_parser,
        (*test_data).parse_text,
        ::c2rust_out::stdlib::strlen((*test_data).parse_text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            ext_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5050 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_skipped_null_loaded_ext_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_skipped_null_loaded_ext_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5057 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'http://example.org/one.ent\'>\n<doc />\x00" as *const u8
            as *const libc::c_char;
    let mut test_data: ExtHdlrData = {
        let mut init =
                ext_hdlr_data{parse_text:
                                  b"<!ENTITY % pe1 SYSTEM \'http://example.org/two.ent\'>\n<!ENTITY % pe2 \'%pe1;\'>\n%pe2;\n\x00"
                                      as *const u8 as *const libc::c_char,
                              handler:
                                  Some(external_entity_null_loader as
                                           unsafe extern "C" fn(_: crate::expat_h::XML_Parser,
                                                                _:
                                                                    *const crate::expat_external_h::XML_Char,
                                                                _:
                                                                    *const crate::expat_external_h::XML_Char,
                                                                _:
                                                                    *const crate::expat_external_h::XML_Char,
                                                                _:
                                                                    *const crate::expat_external_h::XML_Char)
                                               -> libc::c_int),};
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtHdlrData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_oneshot_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5071 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_skipped_unloaded_ext_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_skipped_unloaded_ext_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5075 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'http://example.org/one.ent\'>\n<doc />\x00" as *const u8
            as *const libc::c_char;
    let mut test_data: ExtHdlrData = {
        let mut init =
                ext_hdlr_data{parse_text:
                                  b"<!ENTITY % pe1 SYSTEM \'http://example.org/two.ent\'>\n<!ENTITY % pe2 \'%pe1;\'>\n%pe2;\n\x00"
                                      as *const u8 as *const libc::c_char,
                              handler:
                                  ::std::mem::transmute::<libc::intptr_t,
                                                          crate::expat_h::XML_ExternalEntityRefHandler>(::c2rust_out::stddef_h::NULL
                                                                                            as
                                                                                            libc::intptr_t),};
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtHdlrData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_oneshot_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5089 as libc::c_int,
        );
    };
}
/* Test that a parameter entity value ending with a carriage return
 * has it translated internally into a newline.
 */

unsafe extern "C" fn test_param_entity_with_trailing_cr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_param_entity_with_trailing_cr\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5096 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc SYSTEM \'http://example.org/\'>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest = {
        let mut init = ExtTest {
            parse_text: b"<!ENTITY % pe \'<!ATTLIST doc att CDATA \"default\">\r\'>\n%pe;\n\x00"
                as *const u8 as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
        g_parser,
        Some(
            param_entity_match_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    entity_name_to_match = b"pe\x00" as *const u8 as *const libc::c_char;
    entity_value_to_match =
        b"<!ATTLIST doc att CDATA \"default\">\n\x00" as *const u8 as *const libc::c_char;
    entity_match_flag = ENTITY_MATCH_NOT_FOUND;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5115 as libc::c_int,
        );
    }
    if entity_match_flag == ENTITY_MATCH_FAIL {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5117 as libc::c_int,
            b"Parameter entity CR->NEWLINE conversion failed\x00" as *const u8
                as *const libc::c_char,
        );
    } else if entity_match_flag == ENTITY_MATCH_NOT_FOUND {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5119 as libc::c_int,
            b"Parameter entity not parsed\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_invalid_character_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_invalid_character_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5125 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY entity \'&#x110000;\'>\n]>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_BAD_CHAR_REF,
        b"Out of range character reference not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5132 as libc::c_int,
    );
}

unsafe extern "C" fn test_invalid_character_entity_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_invalid_character_entity_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5136 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY entity \'&#xg0;\'>\n]>\n<doc>&entity;</doc>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Out of range character reference not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5143 as libc::c_int,
    );
}

unsafe extern "C" fn test_invalid_character_entity_3() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_invalid_character_entity_3\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5147 as libc::c_int,
    );
    let text: [libc::c_char; 125] =
        *::std::mem::transmute::<&[u8; 125],
                                 &[libc::c_char; 125]>(b"\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00o\x00c\x00 \x00[\x00\n\x00<\x00!\x00E\x00N\x00T\x00I\x00T\x00Y\x00 \x00e\x00n\x00t\x00i\x00t\x00y\x00 \x00\'\x00&\x0e\x04\x0e\x08\x00;\x00\'\x00>\x00\n\x00]\x00>\x00\n\x00<\x00d\x00o\x00c\x00>\x00&\x00e\x00n\x00t\x00i\x00t\x00y\x00;\x00<\x00/\x00d\x00o\x00c\x00>\x00");
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 125]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5163 as libc::c_int,
            b"Invalid start of entity name not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_UNDEFINED_ENTITY as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5165 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_invalid_character_entity_4() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_invalid_character_entity_4\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5169 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY entity \'&#1114112;\'>\n]>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_BAD_CHAR_REF,
        b"Out of range character reference not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5176 as libc::c_int,
    );
}
/* Test that processing instructions are picked up by a default handler */

unsafe extern "C" fn test_pi_handled_in_default() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_pi_handled_in_default\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5181 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?test processing instruction?>\n<doc/>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<?test processing instruction?>\n<doc/>\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5191 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test that comments are picked up by a default handler */

unsafe extern "C" fn test_comment_handled_in_default() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_comment_handled_in_default\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5197 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!-- This is a comment -->\n<doc/>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"<!-- This is a comment -->\n<doc/>\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5207 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test PIs that look almost but not quite like XML declarations */

unsafe extern "C" fn accumulate_pi_characters(
    mut userData: *mut libc::c_void,
    mut target: *const crate::expat_external_h::XML_Char,
    mut data: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        target,
        -(1 as libc::c_int),
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b": \x00" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        data,
        -(1 as libc::c_int),
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"\n\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
}

unsafe extern "C" fn test_pi_yml() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"test_pi_yml\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5224 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?yml something like data?><doc/>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"yml: something like data\n\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
        g_parser,
        Some(
            accumulate_pi_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5234 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_pi_xnl() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"test_pi_xnl\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5239 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xnl nothing like data?><doc/>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"xnl: nothing like data\n\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
        g_parser,
        Some(
            accumulate_pi_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5249 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_pi_xmm() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"test_pi_xmm\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5254 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xmm everything like data?><doc/>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"xmm: everything like data\n\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
        g_parser,
        Some(
            accumulate_pi_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5264 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_utf16_pi() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"test_utf16_pi\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5269 as libc::c_int,
    );
    let text: [libc::c_char; 21] = *::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
        b"<\x00?\x00\x04\x0e\x08\x0e?\x00>\x00<\x00q\x00/\x00>\x00\x00",
    );
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xe0\xb8\x84\xe0\xb8\x88: \n\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
        g_parser,
        Some(
            accumulate_pi_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5290 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_utf16_be_pi() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"test_utf16_be_pi\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5295 as libc::c_int,
    );
    let text: [libc::c_char; 21] = *::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
        b"\x00<\x00?\x0e\x04\x0e\x08\x00?\x00>\x00<\x00q\x00/\x00>\x00",
    );
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xe0\xb8\x84\xe0\xb8\x88: \n\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
        g_parser,
        Some(
            accumulate_pi_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5316 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test that comments can be picked up and translated */

unsafe extern "C" fn accumulate_comment(
    mut userData: *mut libc::c_void,
    mut data: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        data,
        -(1 as libc::c_int),
    );
}

unsafe extern "C" fn test_utf16_be_comment() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_utf16_be_comment\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5329 as libc::c_int,
    );
    let text: [libc::c_char; 51] =
        *::std::mem::transmute::<&[u8; 51],
                                 &[libc::c_char; 51]>(b"\x00<\x00!\x00-\x00-\x00 \x00C\x00o\x00m\x00m\x00e\x00n\x00t\x00 \x00A\x00 \x00-\x00-\x00>\x00\n\x00<\x00d\x00o\x00c\x00/\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b" Comment A \x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
        g_parser,
        Some(
            accumulate_comment
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 51]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5343 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_utf16_le_comment() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_utf16_le_comment\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5348 as libc::c_int,
    );
    let text: [libc::c_char; 51] =
        *::std::mem::transmute::<&[u8; 51],
                                 &[libc::c_char; 51]>(b"<\x00!\x00-\x00-\x00 \x00C\x00o\x00m\x00m\x00e\x00n\x00t\x00 \x00B\x00 \x00-\x00-\x00>\x00\n\x00<\x00d\x00o\x00c\x00/\x00>\x00\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b" Comment B \x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
        g_parser,
        Some(
            accumulate_comment
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 51]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5362 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test that the unknown encoding handler with map entries that expect
 * conversion but no conversion function is faulted
 */

unsafe extern "C" fn failing_converter(
    mut _data: *mut libc::c_void,
    mut _s: *const libc::c_char,
) -> libc::c_int {
    /* Always claim to have failed */
    return -(1 as libc::c_int);
}

unsafe extern "C" fn prefix_converter(
    mut _data: *mut libc::c_void,
    mut s: *const libc::c_char,
) -> libc::c_int {
    /* If the first byte is 0xff, raise an error */
    if *s.offset(0 as libc::c_int as isize) as libc::c_int
        == -(1 as libc::c_int) as libc::c_char as libc::c_int
    {
        return -(1 as libc::c_int);
    }
    /* Just add the low bits of the first byte to the second */
    return *s.offset(1 as libc::c_int as isize) as libc::c_int
        + (*s.offset(0 as libc::c_int as isize) as libc::c_int & 0x7f as libc::c_int)
        & 0x1ff as libc::c_int; /* Assume a 2-byte sequence */
}

unsafe extern "C" fn MiscEncodingHandler(
    mut data: *mut libc::c_void,
    mut encoding: *const crate::expat_external_h::XML_Char,
    mut info: *mut ::c2rust_out::expat_h::XML_Encoding,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut high_map: libc::c_int = -(2 as libc::c_int);
    if ::libc::strcmp(
        encoding,
        b"invalid-9\x00" as *const u8 as *const libc::c_char,
    ) == 0
        || ::libc::strcmp(
            encoding,
            b"ascii-like\x00" as *const u8 as *const libc::c_char,
        ) == 0
        || ::libc::strcmp(
            encoding,
            b"invalid-len\x00" as *const u8 as *const libc::c_char,
        ) == 0
        || ::libc::strcmp(
            encoding,
            b"invalid-a\x00" as *const u8 as *const libc::c_char,
        ) == 0
        || ::libc::strcmp(
            encoding,
            b"invalid-surrogate\x00" as *const u8 as *const libc::c_char,
        ) == 0
        || ::libc::strcmp(
            encoding,
            b"invalid-high\x00" as *const u8 as *const libc::c_char,
        ) == 0
    {
        high_map = -(1 as libc::c_int)
    }
    i = 0 as libc::c_int;
    while i < 128 as libc::c_int {
        (*info).map[i as usize] = i;
        i += 1
    }
    while i < 256 as libc::c_int {
        (*info).map[i as usize] = high_map;
        i += 1
    }
    /* If required, put an invalid value in the ASCII entries */
    if ::libc::strcmp(
        encoding,
        b"invalid-9\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*info).map[9 as libc::c_int as usize] = 5 as libc::c_int
    }
    /* If required, have a top-bit set character starts a 5-byte sequence */
    if ::libc::strcmp(
        encoding,
        b"invalid-len\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*info).map[0x81 as libc::c_int as usize] = -(5 as libc::c_int)
    }
    /* If required, make a top-bit set character a valid ASCII character */
    if ::libc::strcmp(
        encoding,
        b"invalid-a\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*info).map[0x82 as libc::c_int as usize] = 'a' as i32
    }
    /* If required, give a top-bit set character a forbidden value,
     * what would otherwise be the first of a surrogate pair.
     */
    if ::libc::strcmp(
        encoding,
        b"invalid-surrogate\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*info).map[0x83 as libc::c_int as usize] = 0xd801 as libc::c_int
    }
    /* If required, give a top-bit set character too high a value */
    if ::libc::strcmp(
        encoding,
        b"invalid-high\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*info).map[0x84 as libc::c_int as usize] = 0x10101 as libc::c_int
    }
    (*info).data = data;
    (*info).release = ::std::mem::transmute::<
        libc::intptr_t,
        Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    >(::c2rust_out::stddef_h::NULL as libc::intptr_t);
    if ::libc::strcmp(
        encoding,
        b"failing-conv\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*info).convert = Some(
            failing_converter
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        )
    } else if ::libc::strcmp(
        encoding,
        b"prefix-conv\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*info).convert = Some(
            prefix_converter
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        )
    } else {
        (*info).convert = ::std::mem::transmute::<
            libc::intptr_t,
            Option<
                unsafe extern "C" fn(_: *mut libc::c_void, _: *const libc::c_char) -> libc::c_int,
            >,
        >(::c2rust_out::stddef_h::NULL as libc::intptr_t)
    }
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_missing_encoding_conversion_fn() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_missing_encoding_conversion_fn\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5435 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'no-conv\'?>\n<doc>\x81</doc>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    /* MiscEncodingHandler sets up an encoding with every top-bit-set
     * character introducing a two-byte sequence.  For this, it
     * requires a convert function.  The above function call doesn't
     * pass one through, so when BadEncodingHandler actually gets
     * called it should supply an invalid encoding.
     */
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        b"Encoding with missing convert() not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5447 as libc::c_int,
    );
}

unsafe extern "C" fn test_failing_encoding_conversion_fn() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_failing_encoding_conversion_fn\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5451 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'failing-conv\'?>\n<doc>\x81</doc>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    /* BadEncodingHandler sets up an encoding with every top-bit-set
     * character introducing a two-byte sequence.  For this, it
     * requires a convert function.  The above function call passes
     * one that insists all possible sequences are invalid anyway.
     */
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Encoding with failing convert() not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5462 as libc::c_int,
    );
}
/* Test unknown encoding conversions */

unsafe extern "C" fn test_unknown_encoding_success() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_unknown_encoding_success\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5467 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<\x81d\x80oc>Hello, world</\x81d\x80oc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _run_character_check(
        text,
        b"Hello, world\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5473 as libc::c_int,
    );
}
/* Test bad name character in unknown encoding */

unsafe extern "C" fn test_unknown_encoding_bad_name() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_unknown_encoding_bad_name\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5478 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<\xffdoc>Hello, world</\xffdoc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Bad name start in unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5484 as libc::c_int,
    );
}
/* Test bad mid-name character in unknown encoding */

unsafe extern "C" fn test_unknown_encoding_bad_name_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_unknown_encoding_bad_name_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5489 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<d\xffoc>Hello, world</d\xffoc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Bad name in unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5495 as libc::c_int,
    );
}
/* Test element name that is long enough to fill the conversion buffer
 * in an unknown encoding, finishing with an encoded character.
 */

unsafe extern "C" fn test_unknown_encoding_long_name_1() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_unknown_encoding_long_name_1\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5502 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<abcdefghabcdefghabcdefghijkl\x80m\x80n\x80o\x80p>Hi</abcdefghabcdefghabcdefghijkl\x80m\x80n\x80o\x80p>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"abcdefghabcdefghabcdefghijklmnop\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            record_element_start_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5516 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test element name that is long enough to fill the conversion buffer
 * in an unknown encoding, finishing with an simple character.
 */

unsafe extern "C" fn test_unknown_encoding_long_name_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_unknown_encoding_long_name_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5524 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<abcdefghabcdefghabcdefghijklmnop>Hi</abcdefghabcdefghabcdefghijklmnop>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"abcdefghabcdefghabcdefghijklmnop\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            record_element_start_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5538 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_invalid_unknown_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_invalid_unknown_encoding\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5543 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'invalid-9\'?>\n<doc>Hello world</doc>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        b"Invalid unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5549 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_ascii_encoding_ok() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_unknown_ascii_encoding_ok\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5553 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'ascii-like\'?>\n<doc>Hello, world</doc>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _run_character_check(
        text,
        b"Hello, world\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5558 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_ascii_encoding_fail() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_unknown_ascii_encoding_fail\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5562 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'ascii-like\'?>\n<doc>Hello, \x80 world</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Invalid character not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5568 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_encoding_invalid_length() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_unknown_encoding_invalid_length\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5572 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'invalid-len\'?>\n<doc>Hello, world</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        b"Invalid unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5578 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_encoding_invalid_topbit() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_unknown_encoding_invalid_topbit\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5582 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'invalid-a\'?>\n<doc>Hello, world</doc>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        b"Invalid unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5588 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_encoding_invalid_surrogate() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
            b"test_unknown_encoding_invalid_surrogate\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5592 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'invalid-surrogate\'?>\n<doc>Hello, \x82 world</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Invalid unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5598 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_encoding_invalid_high() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_unknown_encoding_invalid_high\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5602 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'invalid-high\'?>\n<doc>Hello, world</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNKNOWN_ENCODING,
        b"Invalid unknown encoding not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5608 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_encoding_invalid_attr_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
            b"test_unknown_encoding_invalid_attr_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5612 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<doc attr=\'\xff0\'/>\x00" as *const u8
            as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Invalid attribute valid not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5618 as libc::c_int,
    );
}

unsafe extern "C" fn external_entity_loader2(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut test_data: *mut ExtTest2 = *(parser as *mut *mut libc::c_void) as *mut ExtTest2;
    let mut extparser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    extparser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if extparser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5647 as libc::c_int,
            b"Coulr not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !(*test_data).encoding.is_null() {
        if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(extparser, (*test_data).encoding)
            as u64
            == 0
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                5650 as libc::c_int,
                b"XML_SetEncoding() ignored for external entity\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if (*test_data).flags as libc::c_uint & EE_PARSE_FULL_BUFFER as libc::c_int as libc::c_uint != 0
    {
        if ::c2rust_out::src::lib::xmlparse::XML_Parse(
            extparser,
            (*test_data).parse_text,
            (*test_data).parse_len,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            _xml_failure(
                extparser,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                5656 as libc::c_int,
            );
        }
    } else if _XML_Parse_SINGLE_BYTES(
        extparser,
        (*test_data).parse_text,
        (*test_data).parse_len,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            extparser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5661 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(extparser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}
/* Test that UTF-16 BOM does not select UTF-16 given explicit encoding */

unsafe extern "C" fn ext2_accumulate_characters(
    mut userData: *mut libc::c_void,
    mut s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    let mut test_data: *mut ExtTest2 = userData as *mut ExtTest2;
    accumulate_characters((*test_data).storage as *mut libc::c_void, s, len);
}

unsafe extern "C" fn test_ext_entity_latin1_utf16le_bom() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_ext_entity_latin1_utf16le_bom\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5675 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest2 = {
        let mut init = ExtTest2 {
            parse_text: b"\xff\xfeL \x00" as *const u8 as *const libc::c_char,
            parse_len: 4 as libc::c_int,
            encoding: b"iso-8859-1\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
            flags: EE_PARSE_NONE,
        };
        init
    };
    /* In UTF-8, y-diaeresis is 0xc3 0xbf, lowercase thorn is 0xc3 0xbe */
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xbf\xc3\xbeL \x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5701 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_ext_entity_latin1_utf16be_bom() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_ext_entity_latin1_utf16be_bom\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5706 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest2 = {
        let mut init = ExtTest2 {
            parse_text: b"\xfe\xff L\x00" as *const u8 as *const libc::c_char,
            parse_len: 4 as libc::c_int,
            encoding: b"iso-8859-1\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
            flags: EE_PARSE_NONE,
        };
        init
    };
    /* In UTF-8, y-diaeresis is 0xc3 0xbf, lowercase thorn is 0xc3 0xbe */
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xbe\xc3\xbf L\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5732 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Parsing the full buffer rather than a byte at a time makes a
 * difference to the encoding scanning code, so repeat the above tests
 * without breaking them down by byte.
 */

unsafe extern "C" fn test_ext_entity_latin1_utf16le_bom2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_ext_entity_latin1_utf16le_bom2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5741 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest2 = {
        let mut init = ExtTest2 {
            parse_text: b"\xff\xfeL \x00" as *const u8 as *const libc::c_char,
            parse_len: 4 as libc::c_int,
            encoding: b"iso-8859-1\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
            flags: EE_PARSE_FULL_BUFFER,
        };
        init
    };
    /* In UTF-8, y-diaeresis is 0xc3 0xbf, lowercase thorn is 0xc3 0xbe */
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xbf\xc3\xbeL \x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5767 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_ext_entity_latin1_utf16be_bom2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_ext_entity_latin1_utf16be_bom2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5772 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest2 = {
        let mut init = ExtTest2 {
            parse_text: b"\xfe\xff L\x00" as *const u8 as *const libc::c_char,
            parse_len: 4 as libc::c_int,
            encoding: b"iso-8859-1\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
            flags: EE_PARSE_FULL_BUFFER,
        };
        init
    };
    /* In UTF-8, y-diaeresis is 0xc3 0xbf, lowercase thorn is 0xc3 0xbe */
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xbe\xc3\xbf L\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5798 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test little-endian UTF-16 given an explicit big-endian encoding */

unsafe extern "C" fn test_ext_entity_utf16_be() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_ext_entity_utf16_be\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5804 as libc::c_int,
    ); /* U+3E00 */
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest2 = {
        let mut init = ExtTest2 {
            parse_text: b"<\x00e\x00/\x00>\x00\x00" as *const u8 as *const libc::c_char,
            parse_len: 8 as libc::c_int,
            encoding: b"utf-16be\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
            flags: EE_PARSE_NONE,
        };
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xe3\xb0\x80\xe6\x94\x80\xe2\xbc\x80\xe3\xb8\x80\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5828 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test big-endian UTF-16 given an explicit little-endian encoding */

unsafe extern "C" fn test_ext_entity_utf16_le() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_ext_entity_utf16_le\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5834 as libc::c_int,
    ); /* U+3E00 */
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest2 = {
        let mut init = ExtTest2 {
            parse_text: b"\x00<\x00e\x00/\x00>\x00" as *const u8 as *const libc::c_char,
            parse_len: 8 as libc::c_int,
            encoding: b"utf-16le\x00" as *const u8 as *const libc::c_char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
            flags: EE_PARSE_NONE,
        };
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xe3\xb0\x80\xe6\x94\x80\xe2\xbc\x80\xe3\xb8\x80\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5858 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn external_entity_faulter2(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut test_data: *mut ExtFaults2 = *(parser as *mut *mut libc::c_void) as *mut ExtFaults2;
    let mut extparser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    extparser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if extparser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5890 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !(*test_data).encoding.is_null() {
        if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(extparser, (*test_data).encoding)
            as u64
            == 0
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                5893 as libc::c_int,
                b"XML_SetEncoding() ignored for external entity\x00" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if ::c2rust_out::src::lib::xmlparse::XML_Parse(
        extparser,
        (*test_data).parse_text,
        (*test_data).parse_len,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5898 as libc::c_int,
            (*test_data).fail_text,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(extparser) as libc::c_uint
        != (*test_data).error as libc::c_uint
    {
        _xml_failure(
            extparser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5900 as libc::c_int,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(extparser);
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}

unsafe extern "C" fn test_ext_entity_utf16_unknown() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_ext_entity_utf16_unknown\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5906 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtFaults2 = {
        let mut init = ExtFaults2 {
            parse_text: b"a\x00b\x00c\x00\x00" as *const u8 as *const libc::c_char,
            parse_len: 6 as libc::c_int,
            fail_text: b"Invalid character in entity not faulted\x00" as *const u8
                as *const libc::c_char,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            error: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_faulter2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtFaults2 as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Invalid character should not have been accepted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5918 as libc::c_int,
    );
}
/* Test not-quite-UTF-8 BOM (0xEF 0xBB 0xBF) */

unsafe extern "C" fn test_ext_entity_utf8_non_bom() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_ext_entity_utf8_non_bom\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5923 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: ExtTest2 = {
        let mut init = ExtTest2 {
            parse_text: b"\xef\xbb\x80\x00" as *const u8 as *const libc::c_char,
            parse_len: 3 as libc::c_int,
            encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            storage: ::c2rust_out::stddef_h::NULL
                as *mut ::c2rust_out::src::tests::chardata::CharData,
            flags: EE_PARSE_NONE,
        };
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xef\xbb\x80\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5945 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test that UTF-8 in a CDATA section is correctly passed through */

unsafe extern "C" fn test_utf8_in_cdata_section() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_utf8_in_cdata_section\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5951 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc><![CDATA[one \xc3\xa9 two]]></doc>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"one \xc3\xa9 two\x00" as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5959 as libc::c_int,
    );
}
/* Test that little-endian UTF-16 in a CDATA section is handled */

unsafe extern "C" fn test_utf8_in_cdata_section_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_utf8_in_cdata_section_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5964 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc><![CDATA[\xc3\xa9]\xc3\xa9two]]></doc>\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa9]\xc3\xa9two\x00" as *const u8 as *const libc::c_char;
    _run_character_check(
        text,
        expected,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5972 as libc::c_int,
    );
}
/* Test trailing spaces in elements are accepted */

unsafe extern "C" fn record_element_end_handler(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"/\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        name,
        -(1 as libc::c_int),
    );
}

unsafe extern "C" fn test_trailing_spaces_in_elements() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_trailing_spaces_in_elements\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        5985 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc   >Hi</doc >\x00" as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"doc/doc\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
        g_parser,
        Some(
            record_element_start_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
        Some(
            record_element_end_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            5996 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_utf16_attribute() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_utf16_attribute\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6001 as libc::c_int,
    );
    let text: [libc::c_char; 23] = *::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
        b"<\x00d\x00 \x00\x04\x0e\x08\x0e=\x00\'\x00a\x00\'\x00/\x00>\x00\x00",
    );
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"a\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            accumulate_attribute
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6016 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_utf16_second_attr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_utf16_second_attr\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6021 as libc::c_int,
    );
    /* <d a='1' {KHO KHWAI}{CHO CHAN}='2'/>
     * where {KHO KHWAI} = U+0E04 = 0xe0 0xb8 0x84 in UTF-8
     * and   {CHO CHAN}  = U+0E08 = 0xe0 0xb8 0x88 in UTF-8
     */
    let text: [libc::c_char; 35] =
        *::std::mem::transmute::<&[u8; 35],
                                 &[libc::c_char; 35]>(b"<\x00d\x00 \x00a\x00=\x00\'\x001\x00\'\x00 \x00\x04\x0e\x08\x0e=\x00\'\x002\x00\'\x00/\x00>\x00\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"1\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            accumulate_attribute
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 35]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6036 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_attr_after_solidus() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_attr_after_solidus\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6041 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc attr1=\'a\' / attr2=\'b\'>\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Misplaced / not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6044 as libc::c_int,
    );
}

unsafe extern "C" fn accumulate_entity_decl(
    mut userData: *mut libc::c_void,
    mut entityName: *const crate::expat_external_h::XML_Char,
    mut _is_parameter_entity: libc::c_int,
    mut value: *const crate::expat_external_h::XML_Char,
    mut value_length: libc::c_int,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
    mut _notationName: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        entityName,
        -(1 as libc::c_int),
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"=\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        value,
        value_length,
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"\n\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
}

unsafe extern "C" fn test_utf16_pe() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"test_utf16_pe\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6067 as libc::c_int,
    );
    /* <!DOCTYPE doc [
     * <!ENTITY % {KHO KHWAI}{CHO CHAN} '<!ELEMENT doc (#PCDATA)>'>
     * %{KHO KHWAI}{CHO CHAN};
     * ]>
     * <doc></doc>
     *
     * where {KHO KHWAI} = U+0E04 = 0xe0 0xb8 0x84 in UTF-8
     * and   {CHO CHAN}  = U+0E08 = 0xe0 0xb8 0x88 in UTF-8
     */
    let text: [libc::c_char; 155] =
        *::std::mem::transmute::<&[u8; 155],
                                 &[libc::c_char; 155]>(b"\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00o\x00c\x00 \x00[\x00\n\x00<\x00!\x00E\x00N\x00T\x00I\x00T\x00Y\x00 \x00%\x00 \x0e\x04\x0e\x08\x00 \x00\'\x00<\x00!\x00E\x00L\x00E\x00M\x00E\x00N\x00T\x00 \x00d\x00o\x00c\x00 \x00(\x00#\x00P\x00C\x00D\x00A\x00T\x00A\x00)\x00>\x00\'\x00>\x00\n\x00%\x0e\x04\x0e\x08\x00;\x00\n\x00]\x00>\x00\n\x00<\x00d\x00o\x00c\x00>\x00<\x00/\x00d\x00o\x00c\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xe0\xb8\x84\xe0\xb8\x88=<!ELEMENT doc (#PCDATA)>\n\x00" as *const u8
            as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
        g_parser,
        Some(
            accumulate_entity_decl
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 155]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6097 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test that duff attribute description keywords are rejected */

unsafe extern "C" fn test_bad_attr_desc_keyword() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_bad_attr_desc_keyword\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6103 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ATTLIST doc attr CDATA #!IMPLIED>\n]>\n<doc />\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Bad keyword !IMPLIED not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6110 as libc::c_int,
    );
}
/* Test that an invalid attribute description keyword consisting of
 * UTF-16 characters with their top bytes non-zero are correctly
 * faulted
 */

unsafe extern "C" fn test_bad_attr_desc_keyword_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_bad_attr_desc_keyword_utf16\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6118 as libc::c_int,
    );
    /* <!DOCTYPE d [
     * <!ATTLIST d a CDATA #{KHO KHWAI}{CHO CHAN}>
     * ]><d/>
     *
     * where {KHO KHWAI} = U+0E04 = 0xe0 0xb8 0x84 in UTF-8
     * and   {CHO CHAN}  = U+0E08 = 0xe0 0xb8 0x88 in UTF-8
     */
    let text: [libc::c_char; 91] =
        *::std::mem::transmute::<&[u8; 91],
                                 &[libc::c_char; 91]>(b"\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00 \x00[\x00\n\x00<\x00!\x00A\x00T\x00T\x00L\x00I\x00S\x00T\x00 \x00d\x00 \x00a\x00 \x00C\x00D\x00A\x00T\x00A\x00 \x00#\x0e\x04\x0e\x08\x00>\x00\n\x00]\x00>\x00<\x00d\x00/\x00>\x00");
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 91]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6134 as libc::c_int,
            b"Invalid UTF16 attribute keyword not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_SYNTAX as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6136 as libc::c_int,
        );
    };
}
/* Test that invalid syntax in a <!DOCTYPE> is rejected.  Do this
 * using prefix-encoding (see above) to trigger specific code paths
 */

unsafe extern "C" fn test_bad_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"test_bad_doctype\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6143 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<!DOCTYPE doc [ \x80D ]><doc/>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"Invalid bytes in DOCTYPE not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6149 as libc::c_int,
    );
}

unsafe extern "C" fn test_bad_doctype_utf16() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_bad_doctype_utf16\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6153 as libc::c_int,
    );
    let text: [libc::c_char; 53] =
        *::std::mem::transmute::<&[u8; 53],
                                 &[libc::c_char; 53]>(b"\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00o\x00c\x00 \x00[\x00 \x06\xf2\x00 \x00]\x00>\x00<\x00d\x00o\x00c\x00/\x00>\x00");
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 53]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6166 as libc::c_int,
            b"Invalid bytes in DOCTYPE not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_SYNTAX as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6168 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_bad_doctype_plus() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_bad_doctype_plus\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6172 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE 1+ [ <!ENTITY foo \'bar\'> ]>\n<1+>&foo;</1+>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"\'+\' in document name not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6177 as libc::c_int,
    );
}

unsafe extern "C" fn test_bad_doctype_star() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_bad_doctype_star\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6181 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE 1* [ <!ENTITY foo \'bar\'> ]>\n<1*>&foo;</1*>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"\'*\' in document name not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6186 as libc::c_int,
    );
}

unsafe extern "C" fn test_bad_doctype_query() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_bad_doctype_query\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6190 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE 1? [ <!ENTITY foo \'bar\'> ]>\n<1?>&foo;</1?>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"\'?\' in document name not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6195 as libc::c_int,
    );
}

unsafe extern "C" fn test_unknown_encoding_bad_ignore() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_unknown_encoding_bad_ignore\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6199 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?><!DOCTYPE doc SYSTEM \'foo\'><doc><e>&entity;</e></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut fault: ExtFaults = {
        let mut init = ext_faults {
            parse_text: b"<![IGNORE[<!ELEMENT \xffG (#PCDATA)*>]]>\x00" as *const u8
                as *const libc::c_char,
            fail_text: b"Invalid character not faulted\x00" as *const u8 as *const libc::c_char,
            encoding: b"prefix-conv\x00" as *const u8 as *const libc::c_char,
            error: ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        };
        init
    };
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_faulter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut fault as *mut ExtFaults as *mut libc::c_void,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Bad IGNORE section with unknown encoding not failed\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6212 as libc::c_int,
    );
}

unsafe extern "C" fn test_entity_in_utf16_be_attr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_entity_in_utf16_be_attr\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6216 as libc::c_int,
    );
    let text: [libc::c_char; 55] =
        *::std::mem::transmute::<&[u8; 55],
                                 &[libc::c_char; 55]>(b"\x00<\x00e\x00 \x00a\x00=\x00\'\x00&\x00#\x002\x002\x008\x00;\x00 \x00&\x00#\x00x\x000\x000\x00E\x004\x00;\x00\'\x00>\x00<\x00/\x00e\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa4 \xc3\xa4\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            accumulate_attribute
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 55]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6233 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_entity_in_utf16_le_attr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_entity_in_utf16_le_attr\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6238 as libc::c_int,
    );
    let text: [libc::c_char; 55] =
        *::std::mem::transmute::<&[u8; 55],
                                 &[libc::c_char; 55]>(b"<\x00e\x00 \x00a\x00=\x00\'\x00&\x00#\x002\x002\x008\x00;\x00 \x00&\x00#\x00x\x000\x000\x00E\x004\x00;\x00\'\x00>\x00<\x00/\x00e\x00>\x00\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\xc3\xa4 \xc3\xa4\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            accumulate_attribute
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 55]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6255 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_entity_public_utf16_be() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_entity_public_utf16_be\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6260 as libc::c_int,
    );
    let text: [libc::c_char; 137] =
        *::std::mem::transmute::<&[u8; 137],
                                 &[libc::c_char; 137]>(b"\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00 \x00[\x00\n\x00<\x00!\x00E\x00N\x00T\x00I\x00T\x00Y\x00 \x00%\x00 \x00e\x00 \x00P\x00U\x00B\x00L\x00I\x00C\x00 \x00\'\x00f\x00o\x00o\x00\'\x00 \x00\'\x00b\x00a\x00r\x00.\x00e\x00n\x00t\x00\'\x00>\x00\n\x00%\x00e\x00;\x00\n\x00]\x00>\x00\n\x00<\x00d\x00>\x00&\x00j\x00;\x00<\x00/\x00d\x00>\x00");
    let mut test_data: ExtTest2 = {
        let mut init =
                ExtTest2{parse_text:
                             b"\x00<\x00!\x00E\x00N\x00T\x00I\x00T\x00Y\x00 \x00j\x00 \x00\'\x00b\x00a\x00z\x00\'\x00>\x00"
                                 as *const u8 as *const libc::c_char,
                         parse_len: 34 as libc::c_int,
                         encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                         storage: ::c2rust_out::stddef_h::NULL as *mut ::c2rust_out::src::tests::chardata::CharData,
                         flags: EE_PARSE_NONE,};
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"baz\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 137]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6287 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_entity_public_utf16_le() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_entity_public_utf16_le\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6292 as libc::c_int,
    );
    let text: [libc::c_char; 137] =
        *::std::mem::transmute::<&[u8; 137],
                                 &[libc::c_char; 137]>(b"<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00d\x00 \x00[\x00\n\x00<\x00!\x00E\x00N\x00T\x00I\x00T\x00Y\x00 \x00%\x00 \x00e\x00 \x00P\x00U\x00B\x00L\x00I\x00C\x00 \x00\'\x00f\x00o\x00o\x00\'\x00 \x00\'\x00b\x00a\x00r\x00.\x00e\x00n\x00t\x00\'\x00>\x00\n\x00%\x00e\x00;\x00\n\x00]\x00>\x00\n\x00<\x00d\x00>\x00&\x00j\x00;\x00<\x00/\x00d\x00>\x00\x00");
    let mut test_data: ExtTest2 = {
        let mut init =
                ExtTest2{parse_text:
                             b"<\x00!\x00E\x00N\x00T\x00I\x00T\x00Y\x00 \x00j\x00 \x00\'\x00b\x00a\x00z\x00\'\x00>\x00\x00"
                                 as *const u8 as *const libc::c_char,
                         parse_len: 34 as libc::c_int,
                         encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                         storage: ::c2rust_out::stddef_h::NULL as *mut ::c2rust_out::src::tests::chardata::CharData,
                         flags: EE_PARSE_NONE,};
        init
    };
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"baz\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    test_data.storage = &mut storage;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_loader2
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtTest2 as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            ext2_accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 137]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6319 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}
/* Test that a doctype with neither an internal nor external subset is
 * faulted
 */

unsafe extern "C" fn test_short_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_short_doctype\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6327 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc></doc>\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"DOCTYPE without subset not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6330 as libc::c_int,
    );
}

unsafe extern "C" fn test_short_doctype_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_short_doctype_2\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6334 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc PUBLIC></doc>\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"DOCTYPE without Public ID not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6337 as libc::c_int,
    );
}

unsafe extern "C" fn test_short_doctype_3() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_short_doctype_3\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6341 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM></doc>\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"DOCTYPE without System ID not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6344 as libc::c_int,
    );
}

unsafe extern "C" fn test_long_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_long_doctype\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6348 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc PUBLIC \'foo\' \'bar\' \'baz\'></doc>\x00"
        as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"DOCTYPE with extra ID not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6350 as libc::c_int,
    );
}

unsafe extern "C" fn test_bad_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"test_bad_entity\x00")).as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6354 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc [\n  <!ENTITY foo PUBLIC>\n]>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"ENTITY without Public ID is not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6360 as libc::c_int,
    );
}
/* Test unquoted value is faulted */

unsafe extern "C" fn test_bad_entity_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_bad_entity_2\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6365 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc [\n  <!ENTITY % foo bar>\n]>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"ENTITY without Public ID is not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6371 as libc::c_int,
    );
}

unsafe extern "C" fn test_bad_entity_3() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_bad_entity_3\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6375 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc [\n  <!ENTITY % foo PUBLIC>\n]>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"Parameter ENTITY without Public ID is not rejected\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6381 as libc::c_int,
    );
}

unsafe extern "C" fn test_bad_entity_4() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_bad_entity_4\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6385 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc [\n  <!ENTITY % foo SYSTEM>\n]>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"Parameter ENTITY without Public ID is not rejected\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6391 as libc::c_int,
    );
}

unsafe extern "C" fn test_bad_notation() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_bad_notation\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6395 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc [\n  <!NOTATION n SYSTEM>\n]>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"Notation without System ID is not rejected\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6401 as libc::c_int,
    );
}

unsafe extern "C" fn checking_default_handler(
    mut userData: *mut libc::c_void,
    mut s: *const crate::expat_external_h::XML_Char,
    mut len: libc::c_int,
) {
    let mut data: *mut DefaultCheck = userData as *mut DefaultCheck;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !(*data.offset(i as isize)).expected.is_null() {
        if (*data.offset(i as isize)).expectedLen == len
            && ::c2rust_out::stdlib::memcmp(
                (*data.offset(i as isize)).expected as *const libc::c_void,
                s as *const libc::c_void,
                (len as libc::c_ulong).wrapping_mul(::std::mem::size_of::<
                    crate::expat_external_h::XML_Char,
                >() as libc::c_ulong),
            ) == 0
        {
            (*data.offset(i as isize)).seen =
                ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
            break;
        } else {
            i += 1
        }
    }
}

unsafe extern "C" fn test_default_doctype_handler() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_default_doctype_handler\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6426 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc PUBLIC \'pubname\' \'test.dtd\' [\n  <!ENTITY foo \'bar\'>\n]>\n<doc>&foo;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut test_data: [DefaultCheck; 3] = [
        {
            let mut init = default_check {
                expected: b"\'pubname\'\x00" as *const u8 as *const libc::c_char,
                expectedLen: 9 as libc::c_int,
                seen: ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool,
            };
            init
        },
        {
            let mut init = default_check {
                expected: b"\'test.dtd\'\x00" as *const u8 as *const libc::c_char,
                expectedLen: 10 as libc::c_int,
                seen: ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool,
            };
            init
        },
        {
            let mut init = default_check {
                expected: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                expectedLen: 0 as libc::c_int,
                seen: ::c2rust_out::expat_h::XML_FALSE as crate::expat_h::XML_Bool,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut [DefaultCheck; 3] as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
        g_parser,
        Some(
            checking_default_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
        g_parser,
        Some(
            dummy_entity_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6441 as libc::c_int,
        );
    }
    i = 0 as libc::c_int;
    while !test_data[i as usize].expected.is_null() {
        if test_data[i as usize].seen == 0 {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                6444 as libc::c_int,
                b"Default handler not run for public !DOCTYPE\x00" as *const u8
                    as *const libc::c_char,
            );
        }
        i += 1
    }
}

unsafe extern "C" fn test_empty_element_abort() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_empty_element_abort\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6448 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<abort/>\x00" as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            start_element_suspender
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6454 as libc::c_int,
            b"Expected to error on abort\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/*
 * Namespaces tests.
 */

unsafe extern "C" fn namespace_setup() {
    g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreateNS(
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        ' ' as i32 as crate::expat_external_h::XML_Char,
    );
    if g_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6466 as libc::c_int,
            b"Parser not created.\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn namespace_teardown() {
    basic_teardown();
}
/* Check that an element name and attribute name match the expected values.
   The expected values are passed as an array reference of string pointers
   provided as the userData argument; the first is the expected
   element name, and the second is the expected attribute name.
*/

static mut triplet_start_flag: libc::c_int = ::c2rust_out::expat_h::XML_FALSE;

static mut triplet_end_flag: libc::c_int = ::c2rust_out::expat_h::XML_FALSE;

unsafe extern "C" fn triplet_start_checker(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
    mut atts: *mut *const crate::expat_external_h::XML_Char,
) {
    let mut elemstr: *mut *mut crate::expat_external_h::XML_Char =
        userData as *mut *mut crate::expat_external_h::XML_Char;
    let mut buffer: [libc::c_char; 1024] = [0; 1024];
    if ::libc::strcmp(*elemstr.offset(0 as libc::c_int as isize), name) != 0 as libc::c_int {
        ::libc::sprintf(
            buffer.as_mut_ptr(),
            b"unexpected start string: \'%s\'\x00" as *const u8 as *const libc::c_char,
            name,
        );
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6489 as libc::c_int,
            buffer.as_mut_ptr(),
        );
    }
    if ::libc::strcmp(
        *elemstr.offset(1 as libc::c_int as isize),
        *atts.offset(0 as libc::c_int as isize),
    ) != 0 as libc::c_int
    {
        ::libc::sprintf(
            buffer.as_mut_ptr(),
            b"unexpected attribute string: \'%s\'\x00" as *const u8 as *const libc::c_char,
            *atts.offset(0 as libc::c_int as isize),
        );
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6493 as libc::c_int,
            buffer.as_mut_ptr(),
        );
    }
    triplet_start_flag = ::c2rust_out::expat_h::XML_TRUE;
}
/* Check that the element name passed to the end-element handler matches
   the expected value.  The expected value is passed as the first element
   in an array of strings passed as the userData argument.
*/

unsafe extern "C" fn triplet_end_checker(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
) {
    let mut elemstr: *mut *mut crate::expat_external_h::XML_Char =
        userData as *mut *mut crate::expat_external_h::XML_Char;
    if ::libc::strcmp(*elemstr.offset(0 as libc::c_int as isize), name) != 0 as libc::c_int {
        let mut buffer: [libc::c_char; 1024] = [0; 1024];
        ::libc::sprintf(
            buffer.as_mut_ptr(),
            b"unexpected end string: \'%s\'\x00" as *const u8 as *const libc::c_char,
            name,
        );
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6508 as libc::c_int,
            buffer.as_mut_ptr(),
        );
    }
    triplet_end_flag = ::c2rust_out::expat_h::XML_TRUE;
}

unsafe extern "C" fn test_return_ns_triplet() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_return_ns_triplet\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6513 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' bar:a=\'12\'\n       xmlns:bar=\'http://example.org/\'>\x00"
            as *const u8 as *const libc::c_char;
    let mut epilog: *const libc::c_char = b"</foo:e>\x00" as *const u8 as *const libc::c_char;
    let mut elemstr: [*const crate::expat_external_h::XML_Char; 2] = [
        b"http://example.org/ e foo\x00" as *const u8 as *const libc::c_char,
        b"http://example.org/ a bar\x00" as *const u8 as *const libc::c_char,
    ];
    ::c2rust_out::src::lib::xmlparse::XML_SetReturnNSTriplet(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        elemstr.as_mut_ptr() as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
        g_parser,
        Some(
            triplet_start_checker
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
        Some(
            triplet_end_checker
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetNamespaceDeclHandler(
        g_parser,
        Some(
            dummy_start_namespace_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
        Some(
            dummy_end_namespace_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    triplet_start_flag = ::c2rust_out::expat_h::XML_FALSE;
    triplet_end_flag = ::c2rust_out::expat_h::XML_FALSE;
    dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6529 as libc::c_int,
        );
    }
    if triplet_start_flag == 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6531 as libc::c_int,
            b"triplet_start_checker not invoked\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Check that unsetting "return triplets" fails while still parsing */
    ::c2rust_out::src::lib::xmlparse::XML_SetReturnNSTriplet(
        g_parser,
        ::c2rust_out::expat_h::XML_FALSE,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        epilog,
        ::c2rust_out::stdlib::strlen(epilog) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6536 as libc::c_int,
        );
    }
    if triplet_end_flag == 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6538 as libc::c_int,
            b"triplet_end_checker not invoked\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_START_NS_DECL_HANDLER_FLAG | DUMMY_END_NS_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6541 as libc::c_int,
            b"Namespace handlers not called\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn overwrite_start_checker(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
    mut atts: *mut *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"start \x00" as *const u8 as *const libc::c_char,
        6 as libc::c_int,
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        name,
        -(1 as libc::c_int),
    );
    while !(*atts).is_null() {
        ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
            storage as *mut ::c2rust_out::src::tests::chardata::CharData,
            b"\nattribute \x00" as *const u8 as *const libc::c_char,
            11 as libc::c_int,
        );
        ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
            storage as *mut ::c2rust_out::src::tests::chardata::CharData,
            *atts,
            -(1 as libc::c_int),
        );
        atts = atts.offset(2 as libc::c_int as isize)
    }
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"\n\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
}

unsafe extern "C" fn overwrite_end_checker(
    mut userData: *mut libc::c_void,
    mut name: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: *mut ::c2rust_out::src::tests::chardata::CharData =
        userData as *mut ::c2rust_out::src::tests::chardata::CharData;
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"end \x00" as *const u8 as *const libc::c_char,
        4 as libc::c_int,
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        name,
        -(1 as libc::c_int),
    );
    ::c2rust_out::src::tests::chardata::CharData_AppendXMLChars(
        storage as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"\n\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
}

unsafe extern "C" fn run_ns_tagname_overwrite_test(
    mut text: *const libc::c_char,
    mut result: *const crate::expat_external_h::XML_Char,
) {
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
        g_parser,
        Some(
            overwrite_start_checker
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
        Some(
            overwrite_end_checker
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6576 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        result,
    );
}
/* Regression test for SF bug #566334. */

unsafe extern "C" fn test_ns_tagname_overwrite() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_ns_tagname_overwrite\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6581 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<n:e xmlns:n=\'http://example.org/\'>\n  <n:f n:attr=\'foo\'/>\n  <n:g n:attr2=\'bar\'/>\n</n:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut result: *const crate::expat_external_h::XML_Char =
        b"start http://example.org/ e\nstart http://example.org/ f\nattribute http://example.org/ attr\nend http://example.org/ f\nstart http://example.org/ g\nattribute http://example.org/ attr2\nend http://example.org/ g\nend http://example.org/ e\n\x00"
            as *const u8 as *const libc::c_char;
    run_ns_tagname_overwrite_test(text, result);
}
/* Regression test for SF bug #566334. */

unsafe extern "C" fn test_ns_tagname_overwrite_triplet() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_ns_tagname_overwrite_triplet\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6599 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<n:e xmlns:n=\'http://example.org/\'>\n  <n:f n:attr=\'foo\'/>\n  <n:g n:attr2=\'bar\'/>\n</n:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut result: *const crate::expat_external_h::XML_Char =
        b"start http://example.org/ e n\nstart http://example.org/ f n\nattribute http://example.org/ attr n\nend http://example.org/ f n\nstart http://example.org/ g n\nattribute http://example.org/ attr2 n\nend http://example.org/ g n\nend http://example.org/ e n\n\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetReturnNSTriplet(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    run_ns_tagname_overwrite_test(text, result);
}
/* Regression test for SF bug #620343. */

unsafe extern "C" fn start_element_fail(
    mut _userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut _atts: *mut *const crate::expat_external_h::XML_Char,
) {
    /* We should never get here. */
    ::c2rust_out::src::tests::minicheck::_fail_unless(
        0 as libc::c_int,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6626 as libc::c_int,
        b"should never reach start_element_fail()\x00" as *const u8 as *const libc::c_char,
    );
}

unsafe extern "C" fn start_ns_clearing_start_element(
    mut userData: *mut libc::c_void,
    mut _prefix: *const crate::expat_external_h::XML_Char,
    mut _uri: *const crate::expat_external_h::XML_Char,
) {
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        userData as crate::expat_h::XML_Parser,
        ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_StartElementHandler>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        ),
    );
}

unsafe extern "C" fn test_start_ns_clears_start_element() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_start_ns_clears_start_element\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6637 as libc::c_int,
    );
    /* This needs to use separate start/end tags; using the empty tag
       syntax doesn't cause the problematic path through Expat to be
       taken.
    */
    let mut text: *const libc::c_char =
        b"<e xmlns=\'http://example.org/\'></e>\x00" as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            start_element_fail
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartNamespaceDeclHandler(
        g_parser,
        Some(
            start_ns_clearing_start_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndNamespaceDeclHandler(
        g_parser,
        Some(
            dummy_end_namespace_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_UseParserAsHandlerArg(g_parser);
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6650 as libc::c_int,
        );
    };
}
/* Regression test for SF bug #616863. */

unsafe extern "C" fn external_entity_handler(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut callno: crate::stdlib::intptr_t = 1 as libc::c_int as libc::c_long
        + *(parser as *mut *mut libc::c_void) as crate::stdlib::intptr_t;
    let mut text: *const libc::c_char = 0 as *const libc::c_char;
    let mut p2: crate::expat_h::XML_Parser = 0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    if callno == 1 as libc::c_int as libc::c_long {
        text = b"<!ELEMENT doc (e+)>\n<!ATTLIST doc xmlns CDATA #IMPLIED>\n<!ELEMENT e EMPTY>\n\x00"
            as *const u8 as *const libc::c_char
    } else {
        text = b"<?xml version=\'1.0\' encoding=\'us-ascii\'?><e/>\x00" as *const u8
            as *const libc::c_char
    }
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(parser, callno as *mut libc::c_void);
    p2 = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if _XML_Parse_SINGLE_BYTES(
        p2,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            p2,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6678 as libc::c_int,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(p2);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_default_ns_from_ext_subset_and_ext_ge() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 43], &[libc::c_char; 43]>(
            b"test_default_ns_from_ext_subset_and_ext_ge\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6685 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\'?>\n<!DOCTYPE doc SYSTEM \'http://example.org/doc.dtd\' [\n  <!ENTITY en SYSTEM \'http://example.org/entity.ent\'>\n]>\n<doc xmlns=\'http://example.org/ns1\'>\n&en;\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_handler
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    /* We actually need to set this handler to tickle this bug. */
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            dummy_start_element
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6701 as libc::c_int,
        );
    };
}
/* Regression test #1 for SF bug #673791. */

unsafe extern "C" fn test_ns_prefix_with_empty_uri_1() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_ns_prefix_with_empty_uri_1\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6706 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc xmlns:prefix=\'http://example.org/\'>\n  <e xmlns:prefix=\'\'/>\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNDECLARING_PREFIX,
        b"Did not report re-setting namespace URI with prefix to \'\'.\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6713 as libc::c_int,
    );
}
/* Regression test #2 for SF bug #673791. */

unsafe extern "C" fn test_ns_prefix_with_empty_uri_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_ns_prefix_with_empty_uri_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6718 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<?xml version=\'1.0\'?>\n<docelem xmlns:pre=\'\'/>\x00"
        as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNDECLARING_PREFIX,
        b"Did not report setting namespace URI with prefix to \'\'.\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6723 as libc::c_int,
    );
}
/* Regression test #3 for SF bug #673791. */

unsafe extern "C" fn test_ns_prefix_with_empty_uri_3() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_ns_prefix_with_empty_uri_3\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6728 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ELEMENT doc EMPTY>\n  <!ATTLIST doc\n    xmlns:prefix CDATA \'\'>\n]>\n<doc/>\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNDECLARING_PREFIX,
        b"Didn\'t report attr default setting NS w/ prefix to \'\'.\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6737 as libc::c_int,
    );
}
/* Regression test #4 for SF bug #673791. */

unsafe extern "C" fn test_ns_prefix_with_empty_uri_4() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_ns_prefix_with_empty_uri_4\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6742 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ELEMENT prefix:doc EMPTY>\n  <!ATTLIST prefix:doc\n    xmlns:prefix CDATA \'http://example.org/\'>\n]>\n<prefix:doc/>\x00"
            as *const u8 as *const libc::c_char;
    /* Packaged info expected by the end element handler;
    the weird structuring lets us re-use the triplet_end_checker()
    function also used for another test. */
    let mut elemstr: [*const crate::expat_external_h::XML_Char; 1] =
        [b"http://example.org/ doc prefix\x00" as *const u8 as *const libc::c_char];
    ::c2rust_out::src::lib::xmlparse::XML_SetReturnNSTriplet(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        elemstr.as_mut_ptr() as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndElementHandler(
        g_parser,
        Some(
            triplet_end_checker
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6758 as libc::c_int,
        );
    };
}
/* Test with non-xmlns prefix */

unsafe extern "C" fn test_ns_unbound_prefix() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_ns_unbound_prefix\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6763 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ELEMENT prefix:doc EMPTY>\n  <!ATTLIST prefix:doc\n    notxmlns:prefix CDATA \'http://example.org/\'>\n]>\n<prefix:doc/>\x00"
            as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6773 as libc::c_int,
            b"Unbound prefix incorrectly passed\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_UNBOUND_PREFIX as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6775 as libc::c_int,
        );
    };
}

unsafe extern "C" fn test_ns_default_with_empty_uri() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_ns_default_with_empty_uri\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6779 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc xmlns=\'http://example.org/\'>\n  <e xmlns=\'\'/>\n</doc>\x00" as *const u8
            as *const libc::c_char;
    /* Add some handlers to exercise extra code paths */
    ::c2rust_out::src::lib::xmlparse::XML_SetStartNamespaceDeclHandler(
        g_parser,
        Some(
            dummy_start_namespace_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetEndNamespaceDeclHandler(
        g_parser,
        Some(
            dummy_end_namespace_decl_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6789 as libc::c_int,
        );
    };
}
/* Regression test for SF bug #692964: two prefixes for one namespace. */

unsafe extern "C" fn test_ns_duplicate_attrs_diff_prefixes() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 38], &[libc::c_char; 38]>(
            b"test_ns_duplicate_attrs_diff_prefixes\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6794 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc xmlns:a=\'http://example.org/a\'\n     xmlns:b=\'http://example.org/a\'\n     a:a=\'v\' b:a=\'v\' />\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_DUPLICATE_ATTRIBUTE,
        b"did not report multiple attributes with same URI+name\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6799 as libc::c_int,
    );
}

unsafe extern "C" fn test_ns_duplicate_hashes() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_ns_duplicate_hashes\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6803 as libc::c_int,
    );
    /* The hash of an attribute is calculated as the hash of its URI
     * concatenated with a space followed by its name (after the
     * colon).  We wish to generate attributes with the same hash
     * value modulo the attribute table size so that we can check that
     * the attribute hash table works correctly.  The attribute hash
     * table size will be the smallest power of two greater than the
     * number of attributes, but at least eight.  There is
     * unfortunately no programmatic way of getting the hash or the
     * table size at user level, but the test code coverage percentage
     * will drop if the hashes cease to point to the same row.
     *
     * The cunning plan is to have few enough attributes to have a
     * reliable table size of 8, and have the single letter attribute
     * names be 8 characters apart, producing a hash which will be the
     * same modulo 8.
     */
    let mut text: *const libc::c_char =
        b"<doc xmlns:a=\'http://example.org/a\'\n     a:a=\'v\' a:i=\'w\' />\x00" as *const u8
            as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6824 as libc::c_int,
        );
    };
}
/* Regression test for SF bug #695401: unbound prefix. */

unsafe extern "C" fn test_ns_unbound_prefix_on_attribute() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_ns_unbound_prefix_on_attribute\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6829 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc a:attr=\'\'/>\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNBOUND_PREFIX,
        b"did not report unbound prefix on attribute\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6832 as libc::c_int,
    );
}
/* Regression test for SF bug #695401: unbound prefix. */

unsafe extern "C" fn test_ns_unbound_prefix_on_element() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_ns_unbound_prefix_on_element\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6837 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<a:doc/>\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNBOUND_PREFIX,
        b"did not report unbound prefix on element\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6840 as libc::c_int,
    );
}
/* Test that the parsing status is correctly reset by XML_ParserReset().
 * We usE test_return_ns_triplet() for our example parse to improve
 * coverage of tidying up code executed.
 */

unsafe extern "C" fn test_ns_parser_reset() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_ns_parser_reset\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6848 as libc::c_int,
    );
    let mut status: ::c2rust_out::expat_h::XML_ParsingStatus =
        ::c2rust_out::expat_h::XML_ParsingStatus {
            parsing: ::c2rust_out::expat_h::XML_INITIALIZED,
            finalBuffer: 0,
        };
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        g_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_INITIALIZED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6853 as libc::c_int,
            b"parsing status doesn\'t start INITIALIZED\x00" as *const u8 as *const libc::c_char,
        );
    }
    test_return_ns_triplet();
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        g_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_FINISHED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6857 as libc::c_int,
            b"parsing status doesn\'t end FINISHED\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_GetParsingStatus(
        g_parser,
        &mut status as *mut _ as *mut ::c2rust_out::expat_h::XML_ParsingStatus,
    );
    if status.parsing as libc::c_uint
        != ::c2rust_out::expat_h::XML_INITIALIZED as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6861 as libc::c_int,
            b"parsing status doesn\'t reset to INITIALIZED\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that long element names with namespaces are handled correctly */

unsafe extern "C" fn test_ns_long_element() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_ns_long_element\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6866 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:thisisalongenoughelementnametotriggerareallocation\n xmlns:foo=\'http://example.org/\' bar:a=\'12\'\n xmlns:bar=\'http://example.org/\'></foo:thisisalongenoughelementnametotriggerareallocation>\x00"
            as *const u8 as *const libc::c_char;
    let mut elemstr: [*const crate::expat_external_h::XML_Char; 2] = [
        b"http://example.org/ thisisalongenoughelementnametotriggerareallocation foo\x00"
            as *const u8 as *const libc::c_char,
        b"http://example.org/ a bar\x00" as *const u8 as *const libc::c_char,
    ];
    ::c2rust_out::src::lib::xmlparse::XML_SetReturnNSTriplet(
        g_parser,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        elemstr.as_mut_ptr() as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
        g_parser,
        Some(
            triplet_start_checker
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
        Some(
            triplet_end_checker
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6882 as libc::c_int,
        );
    };
}
/* Test mixed population of prefixed and unprefixed attributes */

unsafe extern "C" fn test_ns_mixed_prefix_atts() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_ns_mixed_prefix_atts\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6887 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<e a=\'12\' bar:b=\'13\'\n xmlns:bar=\'http://example.org/\'></e>\x00" as *const u8
            as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6894 as libc::c_int,
        );
    };
}
/* Test having a long namespaced element name inside a short one.
 * This exercises some internal buffer reallocation that is shared
 * across elements with the same namespace URI.
 */

unsafe extern "C" fn test_ns_extend_uri_buffer() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_ns_extend_uri_buffer\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6902 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\'> <foo:thisisalongenoughnametotriggerallocationaction   foo:a=\'12\' /></foo:e>\x00"
            as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6909 as libc::c_int,
        );
    };
}
/* Test that xmlns is correctly rejected as an attribute in the xmlns
 * namespace, but not in other namespaces
 */

unsafe extern "C" fn test_ns_reserved_attributes() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_ns_reserved_attributes\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6916 as libc::c_int,
    );
    let mut text1: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' xmlns:xmlns=\'12\' />\x00" as *const u8
            as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' foo:xmlns=\'12\' />\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text1,
        ::c2rust_out::expat_h::XML_ERROR_RESERVED_PREFIX_XMLNS,
        b"xmlns not rejected as an attribute\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6922 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text2,
        ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            6926 as libc::c_int,
        );
    };
}
/* Test more reserved attributes */

unsafe extern "C" fn test_ns_reserved_attributes_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_ns_reserved_attributes_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6931 as libc::c_int,
    );
    let mut text1: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\'  xmlns:xml=\'http://example.org/\' />\x00"
            as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://www.w3.org/XML/1998/namespace\' />\x00" as *const u8
            as *const libc::c_char;
    let mut text3: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://www.w3.org/2000/xmlns/\' />\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text1,
        ::c2rust_out::expat_h::XML_ERROR_RESERVED_PREFIX_XML,
        b"xml not rejected as an attribute\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6939 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    _expect_failure(
        text2,
        ::c2rust_out::expat_h::XML_ERROR_RESERVED_NAMESPACE_URI,
        b"Use of w3.org URL not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6942 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    _expect_failure(
        text3,
        ::c2rust_out::expat_h::XML_ERROR_RESERVED_NAMESPACE_URI,
        b"Use of w3.org xmlns URL not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6945 as libc::c_int,
    );
}
/* Test string pool handling of namespace names of 2048 characters */
/* Exercises a particular string pool growth path */

unsafe extern "C" fn test_ns_extremely_long_prefix() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_ns_extremely_long_prefix\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        6951 as libc::c_int,
    );
    /* C99 compilers are only required to support 4095-character
     * strings, so the following needs to be split in two to be safe
     * for all compilers.
     */
    let mut text1: *const libc::c_char =
        b"<doc ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP:a=\'12\'\x00"
            as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b" xmlns:ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP=\'foo\'\n></doc>\x00"
            as *const u8 as *const libc::c_char;
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text1,
        ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7032 as libc::c_int,
        );
    }
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text2,
        ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7035 as libc::c_int,
        );
    };
}
/* Test unknown encoding handlers in namespace setup */

unsafe extern "C" fn test_ns_unknown_encoding_success() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_ns_unknown_encoding_success\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7040 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'prefix-conv\'?>\n<foo:e xmlns:foo=\'http://example.org/\'>Hi</foo:e>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    _run_character_check(
        text,
        b"Hi\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7045 as libc::c_int,
    );
}
/* Test that too many colons are rejected */

unsafe extern "C" fn test_ns_double_colon() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_ns_double_colon\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7050 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' foo:a:b=\'bar\' />\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Double colon in attribute name not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7054 as libc::c_int,
    );
}

unsafe extern "C" fn test_ns_double_colon_element() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_ns_double_colon_element\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7058 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:bar:e xmlns:foo=\'http://example.org/\' />\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Double colon in element name not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7062 as libc::c_int,
    );
}
/* Test that non-name characters after a colon are rejected */

unsafe extern "C" fn test_ns_bad_attr_leafname() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_ns_bad_attr_leafname\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7067 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' foo:?ar=\'baz\' />\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Invalid character in leafname not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7071 as libc::c_int,
    );
}

unsafe extern "C" fn test_ns_bad_element_leafname() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_ns_bad_element_leafname\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7075 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:?oc xmlns:foo=\'http://example.org/\' />\x00" as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Invalid character in element leafname not faulted\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7079 as libc::c_int,
    );
}
/* Test high-byte-set UTF-16 characters are valid in a leafname */

unsafe extern "C" fn test_ns_utf16_leafname() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_ns_utf16_leafname\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7084 as libc::c_int,
    );
    let text: [libc::c_char; 59] =
        *::std::mem::transmute::<&[u8; 59],
                                 &[libc::c_char; 59]>(b"<\x00n\x00:\x00e\x00 \x00x\x00m\x00l\x00n\x00s\x00:\x00n\x00=\x00\'\x00U\x00R\x00I\x00\'\x00 \x00n\x00:\x00\x04\x0e=\x00\'\x00a\x00\'\x00 \x00/\x00>\x00\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"a\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            accumulate_attribute
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 59]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7099 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_ns_utf16_element_leafname() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_ns_utf16_element_leafname\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7104 as libc::c_int,
    );
    let text: [libc::c_char; 41] =
        *::std::mem::transmute::<&[u8; 41],
                                 &[libc::c_char; 41]>(b"\x00<\x00n\x00:\x0e\x04\x00 \x00x\x00m\x00l\x00n\x00s\x00:\x00n\x00=\x00\'\x00U\x00R\x00I\x00\'\x00/\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"URI \xe0\xb8\x84\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            start_element_event_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 41]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7122 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_ns_utf16_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_ns_utf16_doctype\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7127 as libc::c_int,
    );
    let text: [libc::c_char; 155] =
        *::std::mem::transmute::<&[u8; 155],
                                 &[libc::c_char; 155]>(b"\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00f\x00o\x00o\x00:\x0e\x04\x00 \x00[\x00 \x00<\x00!\x00E\x00N\x00T\x00I\x00T\x00Y\x00 \x00b\x00a\x00r\x00 \x00\'\x00b\x00a\x00z\x00\'\x00>\x00 \x00]\x00>\x00\n\x00<\x00f\x00o\x00o\x00:\x0e\x04\x00 \x00x\x00m\x00l\x00n\x00s\x00:\x00f\x00o\x00o\x00=\x00\'\x00U\x00R\x00I\x00\'\x00>\x00&\x00b\x00a\x00r\x00;\x00<\x00/\x00f\x00o\x00o\x00:\x0e\x04\x00>\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"URI \xe0\xb8\x84\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
        g_parser,
        Some(
            start_element_event_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
        g_parser,
        ::std::mem::transmute(Some(
            MiscEncodingHandler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut ::c2rust_out::expat_h::XML_Encoding,
                ) -> libc::c_int,
        )),
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 155]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7153 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn test_ns_invalid_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_ns_invalid_doctype\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7158 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE foo:!bad [ <!ENTITY bar \'baz\' ]>\n<foo:!bad>&bar;</foo:!bad>\x00" as *const u8
            as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN,
        b"Invalid character in document local name not faulted\x00" as *const u8
            as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7163 as libc::c_int,
    );
}

unsafe extern "C" fn test_ns_double_colon_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_ns_double_colon_doctype\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7167 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE foo:a:doc [ <!ENTITY bar \'baz\' ]>\n<foo:a:doc>&bar;</foo:a:doc>\x00"
            as *const u8 as *const libc::c_char;
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_SYNTAX,
        b"Double colon in document name not faulted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7172 as libc::c_int,
    );
}
/* Control variable; the number of times duff_allocator() will successfully
 * allocate */

pub const ALLOC_ALWAYS_SUCCEED: libc::c_int = -(1 as libc::c_int);

pub const REALLOC_ALWAYS_SUCCEED: libc::c_int = -(1 as libc::c_int);

static mut allocation_count: crate::stdlib::intptr_t =
    ALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;

static mut reallocation_count: crate::stdlib::intptr_t =
    REALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
/* Crocked allocator for allocation failure tests */

unsafe extern "C" fn duff_allocator(mut size: crate::stddef_h::size_t) -> *mut libc::c_void {
    if allocation_count == 0 as libc::c_int as libc::c_long {
        return ::c2rust_out::stddef_h::NULL as *mut libc::c_void;
    }
    if allocation_count != ALLOC_ALWAYS_SUCCEED as libc::c_long {
        allocation_count -= 1
    }
    return ::c2rust_out::stdlib::malloc(size);
}
/* Crocked reallocator for allocation failure tests */

unsafe extern "C" fn duff_reallocator(
    mut ptr: *mut libc::c_void,
    mut size: crate::stddef_h::size_t,
) -> *mut libc::c_void {
    if reallocation_count == 0 as libc::c_int as libc::c_long {
        return ::c2rust_out::stddef_h::NULL as *mut libc::c_void;
    }
    if reallocation_count != REALLOC_ALWAYS_SUCCEED as libc::c_long {
        reallocation_count -= 1
    }
    return ::c2rust_out::stdlib::realloc(ptr, size);
}
/* Test that a failure to allocate the parser structure fails gracefully */

unsafe extern "C" fn test_misc_alloc_create_parser() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_misc_alloc_create_parser\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7205 as libc::c_int,
    );
    let mut memsuite: ::c2rust_out::expat_h::XML_Memory_Handling_Suite = {
        let mut init = ::c2rust_out::expat_h::XML_Memory_Handling_Suite {
            malloc_fcn: Some(
                duff_allocator
                    as unsafe extern "C" fn(_: crate::stddef_h::size_t) -> *mut libc::c_void,
            ),
            realloc_fcn: Some(
                ::c2rust_out::stdlib::realloc
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: libc::c_ulong,
                    ) -> *mut libc::c_void,
            ),
            free_fcn: Some(::libc::free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        };
        init
    };
    let mut i: libc::c_uint = 0;
    let max_alloc_count: libc::c_uint = 10 as libc::c_int as libc::c_uint;
    /* Something this simple shouldn't need more than 10 allocations */
    i = 0 as libc::c_int as libc::c_uint;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate_MM(
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            &mut memsuite as *mut _ as *const ::c2rust_out::expat_h::XML_Memory_Handling_Suite,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        if !g_parser.is_null() {
            break;
        }
        i = i.wrapping_add(1)
    }
    if i == 0 as libc::c_int as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7218 as libc::c_int,
            b"Parser unexpectedly ignored failing allocator\x00" as *const u8
                as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7220 as libc::c_int,
            b"Parser not created with max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test memory allocation failures for a parser with an encoding */

unsafe extern "C" fn test_misc_alloc_create_parser_with_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 44], &[libc::c_char; 44]>(
            b"test_misc_alloc_create_parser_with_encoding\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7225 as libc::c_int,
    );
    let mut memsuite: ::c2rust_out::expat_h::XML_Memory_Handling_Suite = {
        let mut init = ::c2rust_out::expat_h::XML_Memory_Handling_Suite {
            malloc_fcn: Some(
                duff_allocator
                    as unsafe extern "C" fn(_: crate::stddef_h::size_t) -> *mut libc::c_void,
            ),
            realloc_fcn: Some(
                ::c2rust_out::stdlib::realloc
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: libc::c_ulong,
                    ) -> *mut libc::c_void,
            ),
            free_fcn: Some(::libc::free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        };
        init
    };
    let mut i: libc::c_uint = 0;
    let max_alloc_count: libc::c_uint = 10 as libc::c_int as libc::c_uint;
    /* Try several levels of allocation */
    i = 0 as libc::c_int as libc::c_uint;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate_MM(
            b"us-ascii\x00" as *const u8 as *const libc::c_char,
            &mut memsuite as *mut _ as *const ::c2rust_out::expat_h::XML_Memory_Handling_Suite,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        if !g_parser.is_null() {
            break;
        }
        i = i.wrapping_add(1)
    }
    if i == 0 as libc::c_int as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7238 as libc::c_int,
            b"Parser ignored failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7240 as libc::c_int,
            b"Parser not created with max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that freeing a NULL parser doesn't cause an explosion.
 * (Not actually tested anywhere else)
 */

unsafe extern "C" fn test_misc_null_parser() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_misc_null_parser\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7247 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(
        ::c2rust_out::stddef_h::NULL as crate::expat_h::XML_Parser,
    );
}
/* Test that XML_ErrorString rejects out-of-range codes */

unsafe extern "C" fn test_misc_error_string() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_misc_error_string\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7253 as libc::c_int,
    );
    if !::c2rust_out::src::lib::xmlparse::XML_ErrorString(4294967295 as crate::expat_h::XML_Error)
        .is_null()
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7255 as libc::c_int,
            b"Negative error code not rejected\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !::c2rust_out::src::lib::xmlparse::XML_ErrorString(100 as crate::expat_h::XML_Error)
        .is_null()
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7257 as libc::c_int,
            b"Large error code not rejected\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test the version information is consistent */
/* Since we are working in XML_LChars (potentially 16-bits), we
 * can't use the standard C library functions for character
 * manipulation and have to roll our own.
 */

unsafe extern "C" fn parse_version(
    mut version_text: *const crate::expat_external_h::XML_LChar,
    mut version_struct: *mut ::c2rust_out::expat_h::XML_Expat_Version,
) -> libc::c_int {
    if version_text.is_null() {
        return ::c2rust_out::expat_h::XML_FALSE;
    }
    while *version_text as libc::c_int != 0 as libc::c_int {
        if *version_text as libc::c_int >= ::c2rust_out::ascii_h_0::ASCII_0
            && *version_text as libc::c_int <= ::c2rust_out::ascii_h_0::ASCII_9
        {
            break;
        }
        version_text = version_text.offset(1)
    }
    if *version_text as libc::c_int == 0 as libc::c_int {
        return ::c2rust_out::expat_h::XML_FALSE;
    }
    /* version_struct->major = strtoul(version_text, 10, &version_text) */
    (*version_struct).major = 0 as libc::c_int;
    while *version_text as libc::c_int >= ::c2rust_out::ascii_h_0::ASCII_0
        && *version_text as libc::c_int <= ::c2rust_out::ascii_h_0::ASCII_9
    {
        let fresh2 = version_text;
        version_text = version_text.offset(1);
        (*version_struct).major = 10 as libc::c_int * (*version_struct).major
            + (*fresh2 as libc::c_int - ::c2rust_out::ascii_h_0::ASCII_0)
    }
    let fresh3 = version_text;
    version_text = version_text.offset(1);
    if *fresh3 as libc::c_int != ::c2rust_out::ascii_h::ASCII_PERIOD {
        return ::c2rust_out::expat_h::XML_FALSE;
    }
    /* Now for the minor version number */
    (*version_struct).minor = 0 as libc::c_int;
    while *version_text as libc::c_int >= ::c2rust_out::ascii_h_0::ASCII_0
        && *version_text as libc::c_int <= ::c2rust_out::ascii_h_0::ASCII_9
    {
        let fresh4 = version_text;
        version_text = version_text.offset(1);
        (*version_struct).minor = 10 as libc::c_int * (*version_struct).minor
            + (*fresh4 as libc::c_int - ::c2rust_out::ascii_h_0::ASCII_0)
    }
    let fresh5 = version_text;
    version_text = version_text.offset(1);
    if *fresh5 as libc::c_int != ::c2rust_out::ascii_h::ASCII_PERIOD {
        return ::c2rust_out::expat_h::XML_FALSE;
    }
    /* Finally the micro version number */
    (*version_struct).micro = 0 as libc::c_int;
    while *version_text as libc::c_int >= ::c2rust_out::ascii_h_0::ASCII_0
        && *version_text as libc::c_int <= ::c2rust_out::ascii_h_0::ASCII_9
    {
        let fresh6 = version_text;
        version_text = version_text.offset(1);
        (*version_struct).micro = 10 as libc::c_int * (*version_struct).micro
            + (*fresh6 as libc::c_int - ::c2rust_out::ascii_h_0::ASCII_0)
    }
    if *version_text as libc::c_int != 0 as libc::c_int {
        return ::c2rust_out::expat_h::XML_FALSE;
    }
    return ::c2rust_out::expat_h::XML_TRUE;
}

unsafe extern "C" fn versions_equal(
    mut first: *const ::c2rust_out::expat_h::XML_Expat_Version,
    mut second: *const ::c2rust_out::expat_h::XML_Expat_Version,
) -> libc::c_int {
    return ((*first).major == (*second).major
        && (*first).minor == (*second).minor
        && (*first).micro == (*second).micro) as libc::c_int;
}

unsafe extern "C" fn test_misc_version() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_misc_version\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7317 as libc::c_int,
    );
    let mut read_version: ::c2rust_out::expat_h::XML_Expat_Version =
        ::c2rust_out::src::lib::xmlparse::XML_ExpatVersionInfo()
            as ::c2rust_out::expat_h::XML_Expat_Version;
    /* ! defined(XML_UNICODE) || defined(XML_UNICODE_WCHAR_T) */
    let mut parsed_version: ::c2rust_out::expat_h::XML_Expat_Version = {
        let mut init = ::c2rust_out::expat_h::XML_Expat_Version {
            major: 0 as libc::c_int,
            minor: 0 as libc::c_int,
            micro: 0 as libc::c_int,
        };
        init
    };
    let mut version_text: *const crate::expat_external_h::XML_LChar =
        ::c2rust_out::src::lib::xmlparse::XML_ExpatVersion();
    if version_text.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7324 as libc::c_int,
            b"Could not obtain version text\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !version_text.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"version_text != NULL\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7325 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"void test_misc_version(void)\x00",
            ))
            .as_ptr(),
        );
    }
    if parse_version(version_text, &mut parsed_version) == 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7327 as libc::c_int,
            b"Unable to parse version text\x00" as *const u8 as *const libc::c_char,
        );
    }
    if versions_equal(&mut read_version, &mut parsed_version) == 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7329 as libc::c_int,
            b"Version mismatch\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::libc::strcmp(
        version_text,
        b"expat_2.2.9\x00" as *const u8 as *const libc::c_char,
    ) != 0
    {
        /* Silence compiler warning with the following assignment */
        /* needs bump on releases */
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7333 as libc::c_int,
            b"XML_*_VERSION in expat.h out of sync?\n\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test feature information */

unsafe extern "C" fn test_misc_features() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_misc_features\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7345 as libc::c_int,
    );
    let mut features: *const ::c2rust_out::expat_h::XML_Feature =
        ::c2rust_out::src::lib::xmlparse::XML_GetFeatureList()
            as *const ::c2rust_out::expat_h::XML_Feature;
    /* Prevent problems with double-freeing parsers */
    g_parser = ::c2rust_out::stddef_h::NULL as crate::expat_h::XML_Parser;
    if features.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7351 as libc::c_int,
            b"Failed to get feature information\x00" as *const u8 as *const libc::c_char,
        );
    } else {
        /* Loop through the features checking what we can */
        while (*features).feature as libc::c_uint
            != ::c2rust_out::expat_h::XML_FEATURE_END as libc::c_int as libc::c_uint
        {
            match (*features).feature as libc::c_uint {
                6 => {
                    if (*features).value as libc::c_ulong
                        != ::std::mem::size_of::<crate::expat_external_h::XML_Char>()
                            as libc::c_ulong
                    {
                        ::c2rust_out::src::tests::minicheck::_fail_unless(0 as libc::c_int,
                                     b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                                         as *const u8 as *const libc::c_char,
                                     7358 as libc::c_int,
                                     b"Incorrect size of XML_Char\x00" as
                                         *const u8 as *const libc::c_char);
                    }
                }
                7 => {
                    if (*features).value as libc::c_ulong
                        != ::std::mem::size_of::<crate::expat_external_h::XML_LChar>()
                            as libc::c_ulong
                    {
                        ::c2rust_out::src::tests::minicheck::_fail_unless(0 as libc::c_int,
                                     b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                                         as *const u8 as *const libc::c_char,
                                     7362 as libc::c_int,
                                     b"Incorrect size of XML_LChar\x00" as
                                         *const u8 as *const libc::c_char);
                    }
                }
                _ => {}
            }
            features = features.offset(1)
        }
    };
}
/* Regression test for GitHub Issue #17: memory leak parsing attribute
 * values with mixed bound and unbound namespaces.
 */

unsafe extern "C" fn test_misc_attribute_leak() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_misc_attribute_leak\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7376 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<D xmlns:L=\"D\" l:a=\'\' L:a=\'\'/>\x00" as *const u8 as *const libc::c_char;
    let mut memsuite: ::c2rust_out::expat_h::XML_Memory_Handling_Suite = {
        let mut init = ::c2rust_out::expat_h::XML_Memory_Handling_Suite {
            malloc_fcn: Some(
                ::c2rust_out::src::tests::memcheck::tracking_malloc
                    as unsafe extern "C" fn(_: crate::stddef_h::size_t) -> *mut libc::c_void,
            ),
            realloc_fcn: Some(
                ::c2rust_out::src::tests::memcheck::tracking_realloc
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: crate::stddef_h::size_t,
                    ) -> *mut libc::c_void,
            ),
            free_fcn: Some(
                ::c2rust_out::src::tests::memcheck::tracking_free
                    as unsafe extern "C" fn(_: *mut libc::c_void) -> (),
            ),
        };
        init
    };
    g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate_MM(
        b"UTF-8\x00" as *const u8 as *const libc::c_char,
        &mut memsuite as *mut _ as *const ::c2rust_out::expat_h::XML_Memory_Handling_Suite,
        b"\n\x00" as *const u8 as *const libc::c_char,
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_UNBOUND_PREFIX,
        b"Unbound prefixes not found\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7382 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(g_parser);
    /* Prevent the teardown trying to double free */
    g_parser = ::c2rust_out::stddef_h::NULL as crate::expat_h::XML_Parser;
    if ::c2rust_out::src::tests::memcheck::tracking_report() == 0 {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7388 as libc::c_int,
            b"Memory leak found\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test parser created for UTF-16LE is successful */

unsafe extern "C" fn test_misc_utf16le() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"test_misc_utf16le\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7393 as libc::c_int,
    );
    let text: [libc::c_char; 61] =
        *::std::mem::transmute::<&[u8; 61],
                                 &[libc::c_char; 61]>(b"<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00=\x00\'\x001\x00.\x000\x00\'\x00?\x00>\x00<\x00q\x00>\x00H\x00i\x00<\x00/\x00q\x00>\x00\x00");
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"Hi\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate(
        b"UTF-16LE\x00" as *const u8 as *const libc::c_char,
    );
    if g_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7404 as libc::c_int,
            b"Parser not created\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_Init(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            accumulate_characters
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text.as_ptr(),
        ::std::mem::size_of::<[libc::c_char; 61]>() as libc::c_ulong as libc::c_int
            - 1 as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7411 as libc::c_int,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
}

unsafe extern "C" fn start_element_issue_240(
    mut userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
    mut _atts: *mut *const crate::expat_external_h::XML_Char,
) {
    let mut mydata: *mut DataIssue240 = userData as *mut DataIssue240;
    (*mydata).deep += 1;
}

unsafe extern "C" fn end_element_issue_240(
    mut userData: *mut libc::c_void,
    mut _name: *const crate::expat_external_h::XML_Char,
) {
    let mut mydata: *mut DataIssue240 = userData as *mut DataIssue240;
    (*mydata).deep -= 1;
    if (*mydata).deep == 0 as libc::c_int {
        ::c2rust_out::src::lib::xmlparse::XML_StopParser(
            (*mydata).parser,
            0 as libc::c_int as crate::expat_h::XML_Bool,
        );
    };
}

unsafe extern "C" fn test_misc_stop_during_end_handler_issue_240_1() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 46], &[libc::c_char; 46]>(
            b"test_misc_stop_during_end_handler_issue_240_1\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7441 as libc::c_int,
    );
    let mut parser: crate::expat_h::XML_Parser = 0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut mydata: *mut DataIssue240 = 0 as *mut DataIssue240;
    let mut result: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    let doc1: *const libc::c_char =
        b"<doc><e1/><e><foo/></e></doc>\x00" as *const u8 as *const libc::c_char;
    parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate(
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
        parser,
        Some(
            start_element_issue_240
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
        Some(
            end_element_issue_240
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    mydata = ::c2rust_out::stdlib::malloc(::std::mem::size_of::<DataIssue240>() as libc::c_ulong)
        as *mut DataIssue240;
    (*mydata).parser = parser;
    (*mydata).deep = 0 as libc::c_int;
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(parser, mydata as *mut libc::c_void);
    result = ::c2rust_out::src::lib::xmlparse::XML_Parse(
        parser,
        doc1,
        ::c2rust_out::stdlib::strlen(doc1) as libc::c_int,
        1 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(parser);
    ::libc::free(mydata as *mut libc::c_void);
    if result as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7458 as libc::c_int,
            b"Stopping the parser did not work as expected\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_misc_stop_during_end_handler_issue_240_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 46], &[libc::c_char; 46]>(
            b"test_misc_stop_during_end_handler_issue_240_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7462 as libc::c_int,
    );
    let mut parser: crate::expat_h::XML_Parser = 0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut mydata: *mut DataIssue240 = 0 as *mut DataIssue240;
    let mut result: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    let doc2: *const libc::c_char = b"<doc><elem/></doc>\x00" as *const u8 as *const libc::c_char;
    parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate(
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
        parser,
        Some(
            start_element_issue_240
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *mut *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
        Some(
            end_element_issue_240
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> (),
        ),
    );
    mydata = ::c2rust_out::stdlib::malloc(::std::mem::size_of::<DataIssue240>() as libc::c_ulong)
        as *mut DataIssue240;
    (*mydata).parser = parser;
    (*mydata).deep = 0 as libc::c_int;
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(parser, mydata as *mut libc::c_void);
    result = ::c2rust_out::src::lib::xmlparse::XML_Parse(
        parser,
        doc2,
        ::c2rust_out::stdlib::strlen(doc2) as libc::c_int,
        1 as libc::c_int,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(parser);
    ::libc::free(mydata as *mut libc::c_void);
    if result as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7479 as libc::c_int,
            b"Stopping the parser did not work as expected\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_misc_deny_internal_entity_closing_doctype_issue_317() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
            b"test_misc_deny_internal_entity_closing_doctype_issue_317\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7484 as libc::c_int,
    );
    let inputOne: *const libc::c_char =
        b"<!DOCTYPE d [\n<!ENTITY % e \']><d/>\'>\n\n%e;\x00" as *const u8 as *const libc::c_char;
    let inputTwo: *const libc::c_char =
        b"<!DOCTYPE d [\n<!ENTITY % e1 \']><d/>\'><!ENTITY % e2 \'&e1;\'>\n\n%e2;\x00" as *const u8
            as *const libc::c_char;
    let inputThree: *const libc::c_char =
        b"<!DOCTYPE d [\n<!ENTITY % e \']><d\'>\n\n%e;\x00" as *const u8 as *const libc::c_char;
    let inputIssue317: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY % foo \']>\n<doc>Hell<oc (#PCDATA)*>\'>\n%foo;\n]>\n<doc>Hello, world</dVc>\x00"
            as *const u8 as *const libc::c_char;
    let inputs: [*const libc::c_char; 4] = [inputOne, inputTwo, inputThree, inputIssue317];
    let mut inputIndex: crate::stddef_h::size_t = 0 as libc::c_int as crate::stddef_h::size_t;
    while inputIndex
        < (::std::mem::size_of::<[*const libc::c_char; 4]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
    {
        let mut parser: crate::expat_h::XML_Parser =
            0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
        let mut parseResult: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
        let mut setParamEntityResult: libc::c_int = 0;
        let mut lineNumber: crate::expat_external_h::XML_Size = 0;
        let mut columnNumber: crate::expat_external_h::XML_Size = 0;
        let input: *const libc::c_char = inputs[inputIndex as usize];
        parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate(
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        setParamEntityResult = ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        if setParamEntityResult != 1 as libc::c_int {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                7519 as libc::c_int,
                b"Failed to set XML_PARAM_ENTITY_PARSING_ALWAYS.\x00" as *const u8
                    as *const libc::c_char,
            );
        }
        parseResult = ::c2rust_out::src::lib::xmlparse::XML_Parse(
            parser,
            input,
            ::c2rust_out::stdlib::strlen(input) as libc::c_int,
            0 as libc::c_int,
        );
        if parseResult as libc::c_uint != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            parseResult = ::c2rust_out::src::lib::xmlparse::XML_Parse(
                parser,
                b"\x00" as *const u8 as *const libc::c_char,
                0 as libc::c_int,
                1 as libc::c_int,
            );
            if parseResult as libc::c_uint
                != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
            {
                ::c2rust_out::src::tests::minicheck::_fail_unless(
                    0 as libc::c_int,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    7525 as libc::c_int,
                    b"Parsing was expected to fail but succeeded.\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(parser) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_INVALID_TOKEN as libc::c_int as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                7530 as libc::c_int,
                b"Error code does not match XML_ERROR_INVALID_TOKEN\x00" as *const u8
                    as *const libc::c_char,
            );
        }
        lineNumber = ::c2rust_out::src::lib::xmlparse::XML_GetCurrentLineNumber(parser);
        if lineNumber != 4 as libc::c_int as libc::c_ulong {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                7534 as libc::c_int,
                b"XML_GetCurrentLineNumber does not work as expected.\x00" as *const u8
                    as *const libc::c_char,
            );
        }
        columnNumber = ::c2rust_out::src::lib::xmlparse::XML_GetCurrentColumnNumber(parser);
        if columnNumber != 0 as libc::c_int as libc::c_ulong {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                7538 as libc::c_int,
                b"XML_GetCurrentColumnNumber does not work as expected.\x00" as *const u8
                    as *const libc::c_char,
            );
        }
        ::c2rust_out::src::lib::xmlparse::XML_ParserFree(parser);
        inputIndex = inputIndex.wrapping_add(1)
    }
}

unsafe extern "C" fn alloc_setup() {
    let mut memsuite: ::c2rust_out::expat_h::XML_Memory_Handling_Suite = {
        let mut init = ::c2rust_out::expat_h::XML_Memory_Handling_Suite {
            malloc_fcn: Some(
                duff_allocator
                    as unsafe extern "C" fn(_: crate::stddef_h::size_t) -> *mut libc::c_void,
            ),
            realloc_fcn: Some(
                duff_reallocator
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: crate::stddef_h::size_t,
                    ) -> *mut libc::c_void,
            ),
            free_fcn: Some(::libc::free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        };
        init
    };
    /* Ensure the parser creation will go through */
    allocation_count = ALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
    reallocation_count = REALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
    g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate_MM(
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        &mut memsuite as *mut _ as *const ::c2rust_out::expat_h::XML_Memory_Handling_Suite,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if g_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7555 as libc::c_int,
            b"Parser not created\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn alloc_teardown() {
    basic_teardown();
}
/* Test the effects of allocation failures on xml declaration processing */

unsafe extern "C" fn test_alloc_parse_xdecl() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_alloc_parse_xdecl\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7564 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<doc>Hello, world</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
            g_parser,
            Some(
                dummy_xdecl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* Resetting the parser is insufficient, because some memory
         * allocations are cached within the parser.  Instead we use
         * the teardown and setup routines to ensure that we have the
         * right sort of parser back in our hands.
         */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7585 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7587 as libc::c_int,
            b"Parse failed with max allocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* As above, but with an encoding big enough to cause storing the
 * version information to expand the string pool being used.
 */

unsafe extern "C" fn long_encoding_handler(
    mut _userData: *mut libc::c_void,
    mut _encoding: *const crate::expat_external_h::XML_Char,
    mut info: *mut ::c2rust_out::expat_h::XML_Encoding,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        (*info).map[i as usize] = i;
        i += 1
    }
    (*info).data = ::c2rust_out::stddef_h::NULL as *mut libc::c_void;
    (*info).convert = ::std::mem::transmute::<
        libc::intptr_t,
        Option<unsafe extern "C" fn(_: *mut libc::c_void, _: *const libc::c_char) -> libc::c_int>,
    >(::c2rust_out::stddef_h::NULL as libc::intptr_t);
    (*info).release = ::std::mem::transmute::<
        libc::intptr_t,
        Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    >(::c2rust_out::stddef_h::NULL as libc::intptr_t);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_alloc_parse_xdecl_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_alloc_parse_xdecl_2\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7609 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'ThisIsAStupidlyLongEncodingNameIntendedToTriggerPoolGrowth123456ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMN\'?><doc>Hello, world</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetXmlDeclHandler(
            g_parser,
            Some(
                dummy_xdecl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
            g_parser,
            ::std::mem::transmute(Some(
                long_encoding_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut ::c2rust_out::expat_h::XML_Encoding,
                    ) -> libc::c_int,
            )),
            ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7646 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7648 as libc::c_int,
            b"Parse failed with max allocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test the effects of allocation failures on a straightforward parse */

unsafe extern "C" fn test_alloc_parse_pi() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_alloc_parse_pi\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7653 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<?pi unknown?>\n<doc>Hello, world</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
            g_parser,
            Some(
                dummy_pi_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7673 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7675 as libc::c_int,
            b"Parse failed with max allocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_parse_pi_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_alloc_parse_pi_2\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7679 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<doc>Hello, world<?pi unknown?>\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
            g_parser,
            Some(
                dummy_pi_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7699 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7701 as libc::c_int,
            b"Parse failed with max allocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_parse_pi_3() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_alloc_parse_pi_3\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7705 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?This processing instruction should be long enough to ensure thatit triggers the growth of an internal string pool when the      allocator fails at a cruicial moment FGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPQ?><doc/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
            g_parser,
            Some(
                dummy_pi_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7740 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7742 as libc::c_int,
            b"Parse failed with max allocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_parse_comment() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_alloc_parse_comment\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7746 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<!-- Test parsing this comment --><doc>Hi</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
            g_parser,
            Some(
                dummy_comment_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7764 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7766 as libc::c_int,
            b"Parse failed with max allocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_parse_comment_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_parse_comment_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7770 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<doc>Hello, world<!-- Parse this comment too --></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
            g_parser,
            Some(
                dummy_comment_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7790 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7792 as libc::c_int,
            b"Parse failed with max allocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn external_entity_duff_loader(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut new_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut i: libc::c_uint = 0;
    let max_alloc_count: libc::c_uint = 10 as libc::c_int as libc::c_uint;
    /* Try a few different allocation levels */
    i = 0 as libc::c_int as libc::c_uint;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        new_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
            parser,
            context,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        if !new_parser.is_null() {
            ::c2rust_out::src::lib::xmlparse::XML_ParserFree(new_parser);
            break;
        } else {
            i = i.wrapping_add(1)
        }
    }
    if i == 0 as libc::c_int as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7817 as libc::c_int,
            b"External parser creation ignored failing allocator\x00" as *const u8
                as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7819 as libc::c_int,
            b"Extern parser not created with max allocation count\x00" as *const u8
                as *const libc::c_char,
        );
    }
    /* Make sure other random allocation doesn't now fail */
    allocation_count = ALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
    /* Make sure the failure code path is executed too */
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}
/* Test that external parser creation running out of memory is
 * correctly reported.  Based on the external entity test cases.
 */

unsafe extern "C" fn test_alloc_create_external_parser() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_alloc_create_external_parser\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7831 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut foo_text: [libc::c_char; 26] = *::std::mem::transmute::<
        &[u8; 26],
        &mut [libc::c_char; 26],
    >(b"<!ELEMENT doc (#PCDATA)*>\x00");
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        foo_text.as_mut_ptr() as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_duff_loader
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7842 as libc::c_int,
            b"External parser allocator returned success incorrectly\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* More external parser memory allocation testing */

unsafe extern "C" fn test_alloc_run_external_parser() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_alloc_run_external_parser\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7848 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<!DOCTYPE doc SYSTEM \'foo\'>\n<doc>&entity;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut foo_text: [libc::c_char; 26] = *::std::mem::transmute::<
        &[u8; 26],
        &mut [libc::c_char; 26],
    >(b"<!ELEMENT doc (#PCDATA)*>\x00");
    let mut i: libc::c_uint = 0;
    let max_alloc_count: libc::c_uint = 15 as libc::c_int as libc::c_uint;
    i = 0 as libc::c_int as libc::c_uint;
    while i < max_alloc_count {
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            foo_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_null_loader
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i = i.wrapping_add(1)
    }
    if i == 0 as libc::c_int as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7869 as libc::c_int,
            b"Parsing ignored failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7871 as libc::c_int,
            b"Parsing failed with allocation count 10\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn external_entity_dbl_handler(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut callno: crate::stdlib::intptr_t =
        *(parser as *mut *mut libc::c_void) as crate::stdlib::intptr_t;
    let mut text: *const libc::c_char = 0 as *const libc::c_char;
    let mut new_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    if callno == 0 as libc::c_int as libc::c_long {
        /* First time through, check how many calls to malloc occur */
        text = b"<!ELEMENT doc (e+)>\n<!ATTLIST doc xmlns CDATA #IMPLIED>\n<!ELEMENT e EMPTY>\n\x00"
            as *const u8 as *const libc::c_char;
        allocation_count = 10000 as libc::c_int as crate::stdlib::intptr_t;
        new_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
            parser,
            context,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        if new_parser.is_null() {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                7896 as libc::c_int,
                b"Unable to allocate first external parser\x00" as *const u8 as *const libc::c_char,
            );
            return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
        }
        /* Stash the number of calls in the user data */
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            parser,
            (10000 as libc::c_int as libc::c_long - allocation_count) as *mut libc::c_void,
        );
    } else {
        text = b"<?xml version=\'1.0\' encoding=\'us-ascii\'?><e/>\x00" as *const u8
            as *const libc::c_char;
        /* Try at varying levels to exercise more code paths */
        i = 0 as libc::c_int;
        while i < max_alloc_count {
            allocation_count = callno + i as libc::c_long;
            new_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
                parser,
                context,
                ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            );
            if !new_parser.is_null() {
                break;
            }
            i += 1
        }
        if i == 0 as libc::c_int {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                7912 as libc::c_int,
                b"Second external parser unexpectedly created\x00" as *const u8
                    as *const libc::c_char,
            );
            ::c2rust_out::src::lib::xmlparse::XML_ParserFree(new_parser);
            return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
        } else {
            if i == max_alloc_count {
                ::c2rust_out::src::tests::minicheck::_fail_unless(
                    0 as libc::c_int,
                    b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                        as *const u8 as *const libc::c_char,
                    7916 as libc::c_int,
                    b"Second external parser not created\x00" as *const u8 as *const libc::c_char,
                );
                return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
            }
        }
    }
    allocation_count = ALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
    if _XML_Parse_SINGLE_BYTES(
        new_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            new_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7924 as libc::c_int,
        );
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(new_parser);
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}
/* Test that running out of memory in dtdCopy is correctly reported.
 * Based on test_default_ns_from_ext_subset_and_ext_ge()
 */

unsafe extern "C" fn test_alloc_dtd_copy_default_atts() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_alloc_dtd_copy_default_atts\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7934 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\'?>\n<!DOCTYPE doc SYSTEM \'http://example.org/doc.dtd\' [\n  <!ENTITY en SYSTEM \'http://example.org/entity.ent\'>\n]>\n<doc xmlns=\'http://example.org/ns1\'>\n&en;\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_dbl_handler
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
    );
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            7948 as libc::c_int,
        );
    };
}

unsafe extern "C" fn external_entity_dbl_handler_2(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut callno: crate::stdlib::intptr_t =
        *(parser as *mut *mut libc::c_void) as crate::stdlib::intptr_t;
    let mut text: *const libc::c_char = 0 as *const libc::c_char;
    let mut new_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut rv: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    if callno == 0 as libc::c_int as libc::c_long {
        /* Try different allocation levels for whole exercise */
        text = b"<!ELEMENT doc (e+)>\n<!ATTLIST doc xmlns CDATA #IMPLIED>\n<!ELEMENT e EMPTY>\n\x00"
            as *const u8 as *const libc::c_char;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            parser,
            1 as libc::c_int as crate::stdlib::intptr_t as *mut libc::c_void,
        );
        new_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
            parser,
            context,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        if new_parser.is_null() {
            return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
        }
        rv = _XML_Parse_SINGLE_BYTES(
            new_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        )
    } else {
        /* Just run through once */
        text = b"<?xml version=\'1.0\' encoding=\'us-ascii\'?><e/>\x00" as *const u8
            as *const libc::c_char;
        new_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
            parser,
            context,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        if new_parser.is_null() {
            return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
        }
        rv = _XML_Parse_SINGLE_BYTES(
            new_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        )
    }
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(new_parser);
    if rv as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}
/* Test more external entity allocation failure paths */

unsafe extern "C" fn test_alloc_external_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_external_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        7990 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\'?>\n<!DOCTYPE doc SYSTEM \'http://example.org/doc.dtd\' [\n  <!ENTITY en SYSTEM \'http://example.org/entity.ent\'>\n]>\n<doc xmlns=\'http://example.org/ns1\'>\n&en;\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let alloc_test_max_repeats: libc::c_int = 50 as libc::c_int;
    i = 0 as libc::c_int;
    while i < alloc_test_max_repeats {
        allocation_count = -(1 as libc::c_int) as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_dbl_handler_2
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
        );
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    allocation_count = -(1 as libc::c_int) as crate::stdlib::intptr_t;
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8016 as libc::c_int,
            b"External entity parsed despite duff allocator\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if i == alloc_test_max_repeats {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8018 as libc::c_int,
            b"External entity not parsed at max allocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Test more allocation failure paths */

unsafe extern "C" fn external_entity_alloc_set_encoding(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    /* As for external_entity_loader() */
    let mut text: *const libc::c_char =
        b"<?xml encoding=\'iso-8859-3\'?>\xc3\xa9\x00" as *const u8 as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut status: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(
        ext_parser,
        b"utf-8\x00" as *const u8 as *const libc::c_char,
    ) as u64
        == 0
    {
        ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    status = _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    );
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    if status as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint {
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    return ::c2rust_out::expat_h::XML_STATUS_OK_0;
}

unsafe extern "C" fn test_alloc_ext_entity_set_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_alloc_ext_entity_set_encoding\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8052 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_allocation_count: libc::c_int = 30 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_allocation_count {
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc_set_encoding
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
        {
            break;
        }
        allocation_count = -(1 as libc::c_int) as crate::stdlib::intptr_t;
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8073 as libc::c_int,
            b"Encoding check succeeded despite failing allocator\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if i == max_allocation_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8075 as libc::c_int,
            b"Encoding failed at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn unknown_released_encoding_handler(
    mut _data: *mut libc::c_void,
    mut encoding: *const crate::expat_external_h::XML_Char,
    mut info: *mut ::c2rust_out::expat_h::XML_Encoding,
) -> libc::c_int {
    if ::libc::strcmp(
        encoding,
        b"unsupported-encoding\x00" as *const u8 as *const libc::c_char,
    ) == 0
    {
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < 256 as libc::c_int {
            (*info).map[i as usize] = i;
            i += 1
        }
        (*info).data = ::c2rust_out::stddef_h::NULL as *mut libc::c_void;
        (*info).convert = ::std::mem::transmute::<
            libc::intptr_t,
            Option<
                unsafe extern "C" fn(_: *mut libc::c_void, _: *const libc::c_char) -> libc::c_int,
            >,
        >(::c2rust_out::stddef_h::NULL as libc::intptr_t);
        (*info).release = Some(dummy_release as unsafe extern "C" fn(_: *mut libc::c_void) -> ());
        return ::c2rust_out::expat_h::XML_STATUS_OK_0;
    }
    return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
}
/* Test the effects of allocation failure in internal entities.
 * Based on test_unknown_encoding_internal_entity
 */

unsafe extern "C" fn test_alloc_internal_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_internal_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8099 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'unsupported-encoding\'?>\n<!DOCTYPE test [<!ENTITY foo \'bar\'>]>\n<test a=\'&foo;\'/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_uint = 0;
    let max_alloc_count: libc::c_uint = 20 as libc::c_int as libc::c_uint;
    i = 0 as libc::c_int as libc::c_uint;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUnknownEncodingHandler(
            g_parser,
            ::std::mem::transmute(Some(
                unknown_released_encoding_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut ::c2rust_out::expat_h::XML_Encoding,
                    ) -> libc::c_int,
            )),
            ::c2rust_out::stddef_h::NULL as *mut libc::c_void,
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i = i.wrapping_add(1)
    }
    if i == 0 as libc::c_int as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8118 as libc::c_int,
            b"Internal entity worked despite failing allocations\x00" as *const u8
                as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8120 as libc::c_int,
            b"Internal entity failed at max allocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Test the robustness against allocation failure of element handling
 * Based on test_dtd_default_handling().
 */

unsafe extern "C" fn test_alloc_dtd_default_handling() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_alloc_dtd_default_handling\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8127 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ENTITY e SYSTEM \'http://example.org/e\'>\n<!NOTATION n SYSTEM \'http://example.org/n\'>\n<!ENTITY e1 SYSTEM \'http://example.org/e\' NDATA n>\n<!ELEMENT doc (#PCDATA)>\n<!ATTLIST doc a CDATA #IMPLIED>\n<?pi in dtd?>\n<!--comment in dtd-->\n]>\n<doc><![CDATA[text in doc]]></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut expected: *const crate::expat_external_h::XML_Char =
        b"\n\n\n\n\n\n\n\n\n<doc>text in doc</doc>\x00" as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 25 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
            g_parser,
            Some(
                accumulate_characters
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetDoctypeDeclHandler(
            g_parser,
            Some(
                dummy_start_doctype_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
            Some(dummy_end_doctype_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
            g_parser,
            Some(
                dummy_entity_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetNotationDeclHandler(
            g_parser,
            Some(
                dummy_notation_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
            g_parser,
            ::std::mem::transmute(Some(
                dummy_element_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut crate::expat_h::XML_Content,
                    ) -> (),
            )),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
            g_parser,
            Some(
                dummy_attlist_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
            g_parser,
            Some(
                dummy_pi_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
            g_parser,
            Some(
                dummy_comment_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetCdataSectionHandler(
            g_parser,
            Some(dummy_start_cdata_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
            Some(dummy_end_cdata_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUnparsedEntityDeclHandler(
            g_parser,
            Some(
                dummy_unparsed_entity_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::tests::chardata::CharData_Init(
            &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
            g_parser,
            Some(
                accumulate_characters
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8170 as libc::c_int,
            b"Default DTD parsed despite allocation failures\x00" as *const u8
                as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8172 as libc::c_int,
            b"Default DTD not parsed with maximum alloc count\x00" as *const u8
                as *const libc::c_char,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        expected,
    );
    if dummy_handler_flags
        != DUMMY_START_DOCTYPE_HANDLER_FLAG
            | DUMMY_END_DOCTYPE_HANDLER_FLAG
            | DUMMY_ENTITY_DECL_HANDLER_FLAG
            | DUMMY_NOTATION_DECL_HANDLER_FLAG
            | DUMMY_ELEMENT_DECL_HANDLER_FLAG
            | DUMMY_ATTLIST_DECL_HANDLER_FLAG
            | DUMMY_COMMENT_HANDLER_FLAG
            | DUMMY_PI_HANDLER_FLAG
            | DUMMY_START_CDATA_HANDLER_FLAG
            | DUMMY_END_CDATA_HANDLER_FLAG
            | DUMMY_UNPARSED_ENTITY_DECL_HANDLER_FLAG
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8181 as libc::c_int,
            b"Not all handlers were called\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test robustness of XML_SetEncoding() with a failing allocator */

unsafe extern "C" fn test_alloc_explicit_encoding() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_alloc_explicit_encoding\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8186 as libc::c_int,
    );
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 5 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if ::c2rust_out::src::lib::xmlparse::XML_SetEncoding(
            g_parser,
            b"us-ascii\x00" as *const u8 as *const libc::c_char,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
        {
            break;
        }
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8196 as libc::c_int,
            b"Encoding set despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8198 as libc::c_int,
            b"Encoding not set at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test robustness of XML_SetBase against a failing allocator */

unsafe extern "C" fn test_alloc_set_base() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_alloc_set_base\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8203 as libc::c_int,
    );
    let mut new_base: *const crate::expat_external_h::XML_Char =
        b"/local/file/name.xml\x00" as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 5 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if ::c2rust_out::src::lib::xmlparse::XML_SetBase(g_parser, new_base) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
        {
            break;
        }
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8214 as libc::c_int,
            b"Base set despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8216 as libc::c_int,
            b"Base not set with max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test buffer extension in the face of a duff reallocator */

unsafe extern "C" fn test_alloc_realloc_buffer() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_alloc_realloc_buffer\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8221 as libc::c_int,
    );
    let mut text: *const libc::c_char = get_buffer_test_text;
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    /* Get a smallish buffer */
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(g_parser, 1536 as libc::c_int);
        if buffer.is_null() {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                8232 as libc::c_int,
                b"1.5K buffer reallocation failed\x00" as *const u8 as *const libc::c_char,
            );
        }
        if !buffer.is_null() {
        } else {
            ::c2rust_out::stdlib::__assert_fail(
                b"buffer != NULL\x00" as *const u8 as *const libc::c_char,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                8233 as libc::c_int as libc::c_uint,
                (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
                    b"void test_alloc_realloc_buffer(void)\x00",
                ))
                .as_ptr(),
            );
        }
        ::c2rust_out::stdlib::memcpy(
            buffer,
            text as *const libc::c_void,
            ::c2rust_out::stdlib::strlen(text),
        );
        if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
            g_parser,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_FALSE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    reallocation_count = -(1 as libc::c_int) as crate::stdlib::intptr_t;
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8244 as libc::c_int,
            b"Parse succeeded with no reallocation\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8246 as libc::c_int,
            b"Parse failed with max reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Same test for external entity parsers */

unsafe extern "C" fn external_entity_reallocator(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char = get_buffer_test_text;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut status: crate::expat_h::XML_Status = ::c2rust_out::expat_h::XML_STATUS_ERROR;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8265 as libc::c_int,
            b"Could not create external entity parser\x00" as *const u8 as *const libc::c_char,
        );
    }
    reallocation_count = *(parser as *mut *mut libc::c_void) as crate::stdlib::intptr_t;
    buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(ext_parser, 1536 as libc::c_int);
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8270 as libc::c_int,
            b"Buffer allocation failed\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !buffer.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(b"buffer != NULL\x00" as *const u8 as
                          *const libc::c_char,
                      b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                          as *const u8 as *const libc::c_char,
                      8271 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 116],
                                                &[libc::c_char; 116]>(b"int external_entity_reallocator(XML_Parser, const XML_Char *, const XML_Char *, const XML_Char *, const XML_Char *)\x00")).as_ptr());
    }
    ::c2rust_out::stdlib::memcpy(
        buffer,
        text as *const libc::c_void,
        ::c2rust_out::stdlib::strlen(text),
    );
    status = ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        ext_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    );
    reallocation_count = -(1 as libc::c_int) as crate::stdlib::intptr_t;
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return if status as libc::c_uint == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint {
        ::c2rust_out::expat_h::XML_STATUS_OK_0
    } else {
        ::c2rust_out::expat_h::XML_STATUS_ERROR_0
    };
}

unsafe extern "C" fn test_alloc_ext_entity_realloc_buffer() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_alloc_ext_entity_realloc_buffer\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8279 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY en SYSTEM \'http://example.org/dummy.ent\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_reallocator
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            i as crate::stdlib::intptr_t as *mut libc::c_void,
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8298 as libc::c_int,
            b"Succeeded with no reallocations\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8300 as libc::c_int,
            b"Failed with max reallocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test elements with many attributes are handled correctly */

unsafe extern "C" fn test_alloc_realloc_many_attributes() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_alloc_realloc_many_attributes\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8305 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ATTLIST doc za CDATA \'default\'>\n<!ATTLIST doc zb CDATA \'def2\'>\n<!ATTLIST doc zc CDATA \'def3\'>\n]>\n<doc a=\'1\'     b=\'2\'     c=\'3\'     d=\'4\'     e=\'5\'     f=\'6\'     g=\'7\'     h=\'8\'     i=\'9\'     j=\'10\'     k=\'11\'     l=\'12\'     m=\'13\'     n=\'14\'     p=\'15\'     q=\'16\'     r=\'17\'     s=\'18\'></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8343 as libc::c_int,
            b"Parse succeeded despite no reallocations\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8345 as libc::c_int,
            b"Parse failed at max reallocations\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test handling of a public entity with failing allocator */

unsafe extern "C" fn test_alloc_public_entity_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"test_alloc_public_entity_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8350 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'http://example.org/\'>\n<doc></doc>\n\x00" as *const u8
            as *const libc::c_char;
    let mut dtd_text: [libc::c_char; 1109] =
        *::std::mem::transmute::<&[u8; 1109],
                                 &mut [libc::c_char; 1109]>(b"<!ELEMENT doc EMPTY>\n<!ENTITY % e1 PUBLIC \'foo\' \'bar.ent\'>\n<!ENTITY % ThisIsAStupidlyLongParameterNameIntendedToTriggerPoolGrowth12345ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP \'%e1;\'>\n%e1;\n\x00");
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 50 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            dtd_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_public
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        /* Provoke a particular code path */
        ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
            g_parser,
            Some(
                dummy_entity_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8395 as libc::c_int,
            b"Parsing worked despite failing allocation\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8397 as libc::c_int,
            b"Parsing failed at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_ENTITY_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8399 as libc::c_int,
            b"Entity declaration handler not called\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_realloc_subst_public_entity_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 45], &[libc::c_char; 45]>(
            b"test_alloc_realloc_subst_public_entity_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8403 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'http://example.org/\'>\n<doc></doc>\n\x00" as *const u8
            as *const libc::c_char;
    let mut dtd_text: [libc::c_char; 2108] =
        *::std::mem::transmute::<&[u8; 2108],
                                 &mut [libc::c_char; 2108]>(b"<!ELEMENT doc EMPTY>\n<!ENTITY % ThisIsAStupidlyLongParameterNameIntendedToTriggerPoolGrowth12345ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP PUBLIC \'foo\' \'bar.ent\'>\n%ThisIsAStupidlyLongParameterNameIntendedToTriggerPoolGrowth12345ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP;\x00");
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            dtd_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_public
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8459 as libc::c_int,
            b"Parsing worked despite failing reallocation\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8461 as libc::c_int,
            b"Parsing failed at max reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_parse_public_doctype() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_alloc_parse_public_doctype\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8465 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<!DOCTYPE doc PUBLIC \'http://example.com/a/long/enough/name/to/trigger/pool/growth/zz/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/\' \'test\'>\n<doc></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 25 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        ::c2rust_out::src::lib::xmlparse::XML_SetDoctypeDeclHandler(
            g_parser,
            Some(
                dummy_start_doctype_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
            Some(
                dummy_end_doctype_decl_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8504 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8506 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags
        != DUMMY_START_DOCTYPE_DECL_HANDLER_FLAG | DUMMY_END_DOCTYPE_DECL_HANDLER_FLAG
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8510 as libc::c_int,
            b"Doctype handler functions not called\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_parse_public_doctype_long_name() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 42], &[libc::c_char; 42]>(
            b"test_alloc_parse_public_doctype_long_name\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8514 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'utf-8\'?>\n<!DOCTYPE doc PUBLIC \'http://example.com/foo\' \'ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOPABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP\'>\n<doc></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 25 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetDoctypeDeclHandler(
            g_parser,
            Some(
                dummy_start_doctype_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
            Some(
                dummy_end_doctype_decl_handler as unsafe extern "C" fn(_: *mut libc::c_void) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8552 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8554 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn external_entity_alloc(
    mut parser: crate::expat_h::XML_Parser,
    mut context: *const crate::expat_external_h::XML_Char,
    mut _base: *const crate::expat_external_h::XML_Char,
    mut _systemId: *const crate::expat_external_h::XML_Char,
    mut _publicId: *const crate::expat_external_h::XML_Char,
) -> libc::c_int {
    let mut text: *const libc::c_char = *(parser as *mut *mut libc::c_void) as *const libc::c_char;
    let mut ext_parser: crate::expat_h::XML_Parser =
        0 as *mut ::c2rust_out::expat_h::XML_ParserStruct;
    let mut parse_res: libc::c_int = 0;
    ext_parser = ::c2rust_out::src::lib::xmlparse::XML_ExternalEntityParserCreate(
        parser,
        context,
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
    );
    if ext_parser.is_null() {
        return ::c2rust_out::expat_h::XML_STATUS_ERROR_0;
    }
    parse_res = _XML_Parse_SINGLE_BYTES(
        ext_parser,
        text,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_int;
    ::c2rust_out::src::lib::xmlparse::XML_ParserFree(ext_parser);
    return parse_res;
}
/* Test foreign DTD handling */

unsafe extern "C" fn test_alloc_set_foreign_dtd() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_set_foreign_dtd\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8579 as libc::c_int,
    );
    let mut text1: *const libc::c_char =
        b"<?xml version=\'1.0\' encoding=\'us-ascii\'?>\n<doc>&entity;</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut text2: [libc::c_char; 26] = *::std::mem::transmute::<&[u8; 26], &mut [libc::c_char; 26]>(
        b"<!ELEMENT doc (#PCDATA)*>\x00",
    );
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 25 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            &mut text2 as *mut [libc::c_char; 26] as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if ::c2rust_out::src::lib::xmlparse::XML_UseForeignDTD(
            g_parser,
            ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
        {
            ::c2rust_out::src::tests::minicheck::_fail_unless(
                0 as libc::c_int,
                b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                    as *const u8 as *const libc::c_char,
                8592 as libc::c_int,
                b"Could not set foreign DTD\x00" as *const u8 as *const libc::c_char,
            );
        }
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text1,
            ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8601 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8603 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test based on ibm/valid/P32/ibm32v04.xml */

unsafe extern "C" fn test_alloc_attribute_enum_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_alloc_attribute_enum_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8608 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' standalone=\'no\'?>\n<!DOCTYPE animal SYSTEM \'test.dtd\'>\n<animal>This is a \n    <a/>  \n\nyellow tiger</animal>\x00"
            as *const u8 as *const libc::c_char;
    let mut dtd_text: [libc::c_char; 108] =
        *::std::mem::transmute::<&[u8; 108],
                                 &mut [libc::c_char; 108]>(b"<!ELEMENT animal (#PCDATA|a)*>\n<!ELEMENT a EMPTY>\n<!ATTLIST animal xml:space (default|preserve) \'preserve\'>\x00");
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 30 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            dtd_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        /* An attribute list handler provokes a different code path */
        ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
            g_parser,
            Some(
                dummy_attlist_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8633 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8635 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test attribute enums sufficient to overflow the string pool */

unsafe extern "C" fn test_alloc_realloc_attribute_enum_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
            b"test_alloc_realloc_attribute_enum_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8640 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<?xml version=\'1.0\' standalone=\'no\'?>\n<!DOCTYPE animal SYSTEM \'test.dtd\'>\n<animal>This is a yellow tiger</animal>\x00"
            as *const u8 as *const libc::c_char;
    /* We wish to define a collection of attribute enums that will
     * cause the string pool storing them to have to expand.  This
     * means more than 1024 bytes, including the parentheses and
     * separator bars.
     */
    let mut dtd_text: [libc::c_char; 1097] =
        *::std::mem::transmute::<&[u8; 1097],
                                 &mut [libc::c_char; 1097]>(b"<!ELEMENT animal (#PCDATA)*>\n<!ATTLIST animal thing (default|ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|BBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|CBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|DBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|EBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|FBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|GBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|HBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|IBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|JBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|KBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|LBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|MBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|NBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|OBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|PBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO) \'default\'>\x00");
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            dtd_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        /* An attribute list handler provokes a different code path */
        ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
            g_parser,
            Some(
                dummy_attlist_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8689 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8691 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test attribute enums in a #IMPLIED attribute forcing pool growth */

unsafe extern "C" fn test_alloc_realloc_implied_attribute() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_alloc_realloc_implied_attribute\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8696 as libc::c_int,
    );
    /* Forcing this particular code path is a balancing act.  The
     * addition of the closing parenthesis and terminal NUL must be
     * what pushes the string of enums over the 1024-byte limit,
     * otherwise a different code path will pick up the realloc.
     */
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc EMPTY>\n<!ATTLIST doc a (ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|BBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|CBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|DBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|EBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|FBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|GBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|HBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|IBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|JBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|KBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|LBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|MBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|NBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|OBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|PBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMN) #IMPLIED>\n]><doc/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
            g_parser,
            Some(
                dummy_attlist_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8739 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8741 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test attribute enums in a defaulted attribute forcing pool growth */

unsafe extern "C" fn test_alloc_realloc_default_attribute() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
            b"test_alloc_realloc_default_attribute\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8746 as libc::c_int,
    );
    /* Forcing this particular code path is a balancing act.  The
     * addition of the closing parenthesis and terminal NUL must be
     * what pushes the string of enums over the 1024-byte limit,
     * otherwise a different code path will pick up the realloc.
     */
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc EMPTY>\n<!ATTLIST doc a (ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|BBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|CBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|DBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|EBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|FBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|GBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|HBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|IBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|JBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|KBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|LBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|MBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|NBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|OBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO|PBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMN) \'ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO\'>\n]><doc/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetAttlistDeclHandler(
            g_parser,
            Some(
                dummy_attlist_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8789 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8791 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test long notation name with dodgy allocator */

unsafe extern "C" fn test_alloc_notation() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"test_alloc_notation\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8796 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!NOTATION ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP SYSTEM \'http://example.org/n\'>\n<!ENTITY e SYSTEM \'http://example.org/e\' NDATA ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP>\n<!ELEMENT doc EMPTY>\n]>\n<doc/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        ::c2rust_out::src::lib::xmlparse::XML_SetNotationDeclHandler(
            g_parser,
            Some(
                dummy_notation_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetEntityDeclHandler(
            g_parser,
            Some(
                dummy_entity_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8854 as libc::c_int,
            b"Parse succeeded despite allocation failures\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8856 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_ENTITY_DECL_HANDLER_FLAG | DUMMY_NOTATION_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8859 as libc::c_int,
            b"Entity declaration handler not called\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test public notation with dodgy allocator */

unsafe extern "C" fn test_alloc_public_notation() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_public_notation\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8864 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!NOTATION note PUBLIC \'http://example.com/a/long/enough/name/to/trigger/pool/growth/zz/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/\' \'foo\'>\n<!ENTITY e SYSTEM \'http://example.com/e\' NDATA note>\n<!ELEMENT doc EMPTY>\n]>\n<doc/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        ::c2rust_out::src::lib::xmlparse::XML_SetNotationDeclHandler(
            g_parser,
            Some(
                dummy_notation_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8904 as libc::c_int,
            b"Parse succeeded despite allocation failures\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8906 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_NOTATION_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8908 as libc::c_int,
            b"Notation handler not called\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test public notation with dodgy allocator */

unsafe extern "C" fn test_alloc_system_notation() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_system_notation\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8913 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!NOTATION note SYSTEM \'http://example.com/a/long/enough/name/to/trigger/pool/growth/zz/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/\'>\n<!ENTITY e SYSTEM \'http://example.com/e\' NDATA note>\n<!ELEMENT doc EMPTY>\n]>\n<doc/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        ::c2rust_out::src::lib::xmlparse::XML_SetNotationDeclHandler(
            g_parser,
            Some(
                dummy_notation_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8953 as libc::c_int,
            b"Parse succeeded despite allocation failures\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8955 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_NOTATION_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8957 as libc::c_int,
            b"Notation handler not called\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_nested_groups() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_alloc_nested_groups\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        8961 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (e,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?))))))))))))))))))))))))))))))))>\n<!ELEMENT e EMPTY>]>\n<doc><e/></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::tests::chardata::CharData_Init(
            &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
            g_parser,
            ::std::mem::transmute(Some(
                dummy_element_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut crate::expat_h::XML_Content,
                    ) -> (),
            )),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
            g_parser,
            Some(
                record_element_start_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
        );
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8992 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8994 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"doce\x00" as *const u8 as *const libc::c_char,
    );
    if dummy_handler_flags != DUMMY_ELEMENT_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            8997 as libc::c_int,
            b"Element handler not fired\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_realloc_nested_groups() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_alloc_realloc_nested_groups\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9001 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (e,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?))))))))))))))))))))))))))))))))>\n<!ELEMENT e EMPTY>]>\n<doc><e/></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut storage: ::c2rust_out::src::tests::chardata::CharData =
        ::c2rust_out::src::tests::chardata::CharData {
            count: 0,
            data: [0; 2048],
        };
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::tests::chardata::CharData_Init(
            &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
            g_parser,
            ::std::mem::transmute(Some(
                dummy_element_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut crate::expat_h::XML_Content,
                    ) -> (),
            )),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetStartElementHandler(
            g_parser,
            Some(
                record_element_start_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            &mut storage as *mut ::c2rust_out::src::tests::chardata::CharData as *mut libc::c_void,
        );
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9032 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9034 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    ::c2rust_out::src::tests::chardata::CharData_CheckXMLChars(
        &mut storage as *mut _ as *mut ::c2rust_out::src::tests::chardata::CharData,
        b"doce\x00" as *const u8 as *const libc::c_char,
    );
    if dummy_handler_flags != DUMMY_ELEMENT_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9037 as libc::c_int,
            b"Element handler not fired\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_large_group() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_alloc_large_group\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9041 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (a1|a2|a3|a4|a5|a6|a7|a8|b1|b2|b3|b4|b5|b6|b7|b8|c1|c2|c3|c4|c5|c6|c7|c8|d1|d2|d3|d4|d5|d6|d7|d8|e1)+>\n]>\n<doc>\n<a1/>\n</doc>\n\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 50 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
            g_parser,
            ::std::mem::transmute(Some(
                dummy_element_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut crate::expat_h::XML_Content,
                    ) -> (),
            )),
        );
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9069 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9071 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_ELEMENT_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9073 as libc::c_int,
            b"Element handler flag not raised\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_realloc_group_choice() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_alloc_realloc_group_choice\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9077 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n<!ELEMENT doc (a1|a2|a3|a4|a5|a6|a7|a8|b1|b2|b3|b4|b5|b6|b7|b8|c1|c2|c3|c4|c5|c6|c7|c8|d1|d2|d3|d4|d5|d6|d7|d8|e1)+>\n]>\n<doc>\n<a1/>\n<b2 attr=\'foo\'>This is a foo</b2>\n<c3></c3>\n</doc>\n\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetElementDeclHandler(
            g_parser,
            ::std::mem::transmute(Some(
                dummy_element_decl_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut crate::expat_h::XML_Content,
                    ) -> (),
            )),
        );
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9107 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9109 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_ELEMENT_DECL_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9111 as libc::c_int,
            b"Element handler flag not raised\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_pi_in_epilog() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"test_alloc_pi_in_epilog\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9115 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc></doc>\n<?pi in epilog?>\x00" as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetProcessingInstructionHandler(
            g_parser,
            Some(
                dummy_pi_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9133 as libc::c_int,
            b"Parse completed despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9135 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_PI_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9137 as libc::c_int,
            b"Processing instruction handler not invoked\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_comment_in_epilog() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_alloc_comment_in_epilog\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9141 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc></doc>\n<!-- comment in epilog -->\x00" as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetCommentHandler(
            g_parser,
            Some(
                dummy_comment_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        dummy_handler_flags = 0 as libc::c_int as libc::c_ulong;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9159 as libc::c_int,
            b"Parse completed despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9161 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    }
    if dummy_handler_flags != DUMMY_COMMENT_HANDLER_FLAG {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9163 as libc::c_int,
            b"Processing instruction handler not invoked\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_realloc_long_attribute_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
            b"test_alloc_realloc_long_attribute_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9167 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [<!ENTITY foo \'This entity will be substituted as an attribute value, and is   calculated to be exactly long enough that the terminating NUL   that the library adds internally will trigger the string pool togrow. GHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\'>]>\n<doc a=\'&foo;\'></doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9202 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9204 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_attribute_whitespace() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_alloc_attribute_whitespace\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9208 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc a=\' \'></doc>\x00" as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9223 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9225 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_attribute_predefined_entity() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 39], &[libc::c_char; 39]>(
            b"test_alloc_attribute_predefined_entity\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9229 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc a=\'&amp;\'></doc>\x00" as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 15 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9244 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9246 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that a character reference at the end of a suitably long
 * default value for an attribute can trigger pool growth, and recovers
 * if the allocator fails on it.
 */

unsafe extern "C" fn test_alloc_long_attr_default_with_char_ref() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 43], &[libc::c_char; 43]>(
            b"test_alloc_long_attr_default_with_char_ref\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9254 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [<!ATTLIST doc a CDATA \'ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHI&#x31;\'>]>\n<doc/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9289 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9291 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that a long character reference substitution triggers a pool
 * expansion correctly for an attribute value.
 */

unsafe extern "C" fn test_alloc_long_attr_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_long_attr_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9298 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE test [<!ENTITY foo \'\nABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\'>]>\n<test a=\'&foo;\'/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 25 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9333 as libc::c_int,
            b"Parse succeeded despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9335 as libc::c_int,
            b"Parse failed at maximum allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test that an error in a nested parameter entity substitution is
 * handled correctly.  It seems unlikely that the code path being
 * exercised can be reached purely by carefully crafted XML, but an
 * allocation error in the right place will definitely do it.
 */

unsafe extern "C" fn test_alloc_nested_entities() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
            b"test_alloc_nested_entities\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9344 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'http://example.org/one.ent\'>\n<doc />\x00" as *const u8
            as *const libc::c_char;
    let mut test_data: ExtFaults = {
        let mut init =
                ext_faults{parse_text:
                               b"<!ENTITY % pe1 \'ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\'>\n<!ENTITY % pe2 \'%pe1;\'>\n%pe2;\x00"
                                   as *const u8 as *const libc::c_char,
                           fail_text:
                               b"Memory Fail not faulted\x00" as *const u8 as
                                   *const libc::c_char,
                           encoding: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                           error: ::c2rust_out::expat_h::XML_ERROR_NO_MEMORY,};
        init
    };
    /* Causes an allocation error in a nested storeEntityValue() */
    allocation_count = 12 as libc::c_int as crate::stdlib::intptr_t;
    ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
        g_parser,
        &mut test_data as *mut ExtFaults as *mut libc::c_void,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
        g_parser,
        ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
    );
    ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
        g_parser,
        Some(
            external_entity_faulter
                as unsafe extern "C" fn(
                    _: crate::expat_h::XML_Parser,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                    _: *const crate::expat_external_h::XML_Char,
                ) -> libc::c_int,
        ),
    );
    _expect_failure(
        text,
        ::c2rust_out::expat_h::XML_ERROR_EXTERNAL_ENTITY_HANDLING,
        b"Entity allocation failure not noted\x00" as *const u8 as *const libc::c_char,
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9377 as libc::c_int,
    );
}

unsafe extern "C" fn test_alloc_realloc_param_entity_newline() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
            b"test_alloc_realloc_param_entity_newline\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9381 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc SYSTEM \'http://example.org/\'>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    let mut dtd_text: [libc::c_char; 1048] =
        *::std::mem::transmute::<&[u8; 1048],
                                 &mut [libc::c_char; 1048]>(b"<!ENTITY % pe \'<!ATTLIST doc att CDATA \"This default value is carefully crafted so that the carriage    return right at the end of the entity string causes an internal string pool to have to grow.  This allows us to test the alloc  failure path from that point. OPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDE\">\n\'>%pe;\n\x00");
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 5 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            dtd_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9421 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9423 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_realloc_ce_extends_pe() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_alloc_realloc_ce_extends_pe\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9427 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<!DOCTYPE doc SYSTEM \'http://example.org/\'>\n<doc/>\x00"
        as *const u8 as *const libc::c_char;
    let mut dtd_text: [libc::c_char; 1056] =
        *::std::mem::transmute::<&[u8; 1056],
                                 &mut [libc::c_char; 1056]>(b"<!ENTITY % pe \'<!ATTLIST doc att CDATA \"This default value is carefully crafted so that the character   entity at the end causes an internal string pool to have to     grow.  This allows us to test the allocation failure path from  that point onwards. EFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFG&#x51;\">\n\'>%pe;\n\x00");
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 5 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            dtd_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9467 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9469 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_realloc_attributes() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_alloc_realloc_attributes\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9473 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ATTLIST doc\n    a1  (a|b|c)   \'a\'\n    a2  (foo|bar) #IMPLIED\n    a3  NMTOKEN   #IMPLIED\n    a4  NMTOKENS  #IMPLIED\n    a5  ID        #IMPLIED\n    a6  IDREF     #IMPLIED\n    a7  IDREFS    #IMPLIED\n    a8  ENTITY    #IMPLIED\n    a9  ENTITIES  #IMPLIED\n    a10 CDATA     #IMPLIED\n  >]>\n<doc>wombat</doc>\n\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 5 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9502 as libc::c_int,
            b"Parse succeeded despite failing reallocator\x00" as *const u8 as *const libc::c_char,
        );
    }
    if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9504 as libc::c_int,
            b"Parse failed at maximum reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_long_doc_name() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_alloc_long_doc_name\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9508 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<LongRootElementNameThatWillCauseTheNextAllocationToExpandTheStringPoolForTheDTDQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ a=\'1\'/>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9541 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9543 as libc::c_int,
            b"Parsing failed even at max reallocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_long_base() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"test_alloc_long_base\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9547 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY e SYSTEM \'foo\'>\n]>\n<doc>&e;</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut entity_text: [libc::c_char; 12] =
        *::std::mem::transmute::<&[u8; 12], &mut [libc::c_char; 12]>(b"Hello world\x00");
    let mut base: *const crate::expat_external_h::XML_Char =
        b"LongBaseURI/that/will/overflow/an/internal/buffer/and/cause/it/to/have/to/grow/PQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/\x00"
            as *const u8 as *const libc::c_char;
    /* clang-format on */
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 25 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            entity_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if ::c2rust_out::src::lib::xmlparse::XML_SetBase(g_parser, base) as libc::c_uint
            == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
                g_parser,
                ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
            );
        } else {
            if _XML_Parse_SINGLE_BYTES(
                g_parser,
                text,
                ::c2rust_out::stdlib::strlen(text) as libc::c_int,
                ::c2rust_out::expat_h::XML_TRUE,
            ) as libc::c_uint
                != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
            {
                break;
            }
            /* See comment in test_alloc_parse_xdecl() */
            alloc_teardown();
            alloc_setup();
        }
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9593 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9595 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_long_public_id() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_alloc_long_public_id\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9599 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY e PUBLIC \'LongPublicIDThatShouldResultInAnInternalStringPoolGrowingAtASpecificMomentKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB\' \'bar\'>\n]>\n<doc>&e;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut entity_text: [libc::c_char; 12] =
        *::std::mem::transmute::<&[u8; 12], &mut [libc::c_char; 12]>(b"Hello world\x00");
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            entity_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9640 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9642 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_long_entity_value() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"test_alloc_long_entity_value\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9646 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ENTITY e1 \'Long entity value that should provoke a string pool to grow while setting up to parse the external entity below. xyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB\'>\n  <!ENTITY e2 SYSTEM \'bar\'>\n]>\n<doc>&e2;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut entity_text: [libc::c_char; 12] =
        *::std::mem::transmute::<&[u8; 12], &mut [libc::c_char; 12]>(b"Hello world\x00");
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            entity_text.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_alloc
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9688 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9690 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_alloc_long_notation() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_alloc_long_notation\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9694 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!NOTATION note SYSTEM \'ALongNotationNameThatShouldProvokeStringPoolGrowthWhileCallingAnExternalEntityParserUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB\'>\n  <!ENTITY e1 SYSTEM \'foo\' NDATA ALongNotationNameThatShouldProvokeStringPoolGrowthWhileCallingAnExternalEntityParserUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB>\n  <!ENTITY e2 SYSTEM \'bar\'>\n]>\n<doc>&e2;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut options: [ExtOption; 3] = [
        {
            let mut init = ExtOption {
                system_id: b"foo\x00" as *const u8 as *const libc::c_char,
                parse_text: b"Entity Foo\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: b"bar\x00" as *const u8 as *const libc::c_char,
                parse_text: b"Entity Bar\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_alloc_parse_xdecl() */
        alloc_teardown();
        alloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9757 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9759 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn nsalloc_setup() {
    let mut memsuite: ::c2rust_out::expat_h::XML_Memory_Handling_Suite = {
        let mut init = ::c2rust_out::expat_h::XML_Memory_Handling_Suite {
            malloc_fcn: Some(
                duff_allocator
                    as unsafe extern "C" fn(_: crate::stddef_h::size_t) -> *mut libc::c_void,
            ),
            realloc_fcn: Some(
                duff_reallocator
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: crate::stddef_h::size_t,
                    ) -> *mut libc::c_void,
            ),
            free_fcn: Some(::libc::free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        };
        init
    };
    let mut ns_sep: [crate::expat_external_h::XML_Char; 2] = [
        ' ' as i32 as crate::expat_external_h::XML_Char,
        '\u{0}' as i32 as crate::expat_external_h::XML_Char,
    ];
    /* Ensure the parser creation will go through */
    allocation_count = ALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
    reallocation_count = REALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
    g_parser = ::c2rust_out::src::lib::xmlparse::XML_ParserCreate_MM(
        ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        &mut memsuite as *mut _ as *const ::c2rust_out::expat_h::XML_Memory_Handling_Suite,
        ns_sep.as_mut_ptr(),
    );
    if g_parser.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9773 as libc::c_int,
            b"Parser not created\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn nsalloc_teardown() {
    basic_teardown();
}
/* Test the effects of allocation failure in simple namespace parsing.
 * Based on test_ns_default_with_empty_uri()
 */

unsafe extern "C" fn test_nsalloc_xmlns() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"test_nsalloc_xmlns\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9784 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<doc xmlns=\'http://example.org/\'>\n  <e xmlns=\'\'/>\n</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut i: libc::c_uint = 0;
    let max_alloc_count: libc::c_uint = 30 as libc::c_int as libc::c_uint;
    i = 0 as libc::c_int as libc::c_uint;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        /* Exercise more code paths with a default handler */
        ::c2rust_out::src::lib::xmlparse::XML_SetDefaultHandler(
            g_parser,
            Some(
                dummy_default_handler
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: libc::c_int,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* Resetting the parser is insufficient, because some memory
         * allocations are cached within the parser.  Instead we use
         * the teardown and setup routines to ensure that we have the
         * right sort of parser back in our hands.
         */
        nsalloc_teardown();
        nsalloc_setup();
        i = i.wrapping_add(1)
    }
    if i == 0 as libc::c_int as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9807 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9809 as libc::c_int,
            b"Parsing failed even at maximum allocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Test XML_ParseBuffer interface with namespace and a dicky allocator */

unsafe extern "C" fn test_nsalloc_parse_buffer() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_nsalloc_parse_buffer\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9814 as libc::c_int,
    );
    let mut text: *const libc::c_char = b"<doc>Hello</doc>\x00" as *const u8 as *const libc::c_char;
    let mut buffer: *mut libc::c_void = 0 as *mut libc::c_void;
    /* Try a parse before the start of the world */
    /* (Exercises new code path) */
    allocation_count = 0 as libc::c_int as crate::stdlib::intptr_t;
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9822 as libc::c_int,
            b"Pre-init XML_ParseBuffer not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NO_MEMORY as libc::c_int as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9824 as libc::c_int,
            b"Pre-init XML_ParseBuffer faulted for wrong reason\x00" as *const u8
                as *const libc::c_char,
        );
    }
    /* Now with actual memory allocation */
    allocation_count = ALLOC_ALWAYS_SUCCEED as crate::stdlib::intptr_t;
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        0 as libc::c_int,
        ::c2rust_out::expat_h::XML_FALSE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9829 as libc::c_int,
        );
    }
    /* Check that resuming an unsuspended parser is faulted */
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9833 as libc::c_int,
            b"Resuming unsuspended parser not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NOT_SUSPENDED as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9835 as libc::c_int,
        );
    }
    /* Get the parser into suspended state */
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        Some(
            clearing_aborting_character_handler
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: *const crate::expat_external_h::XML_Char,
                    _: libc::c_int,
                ) -> (),
        ),
    );
    resumable = ::c2rust_out::expat_h::XML_TRUE as crate::expat_h::XML_Bool;
    buffer = ::c2rust_out::src::lib::xmlparse::XML_GetBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
    );
    if buffer.is_null() {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9842 as libc::c_int,
            b"Could not acquire parse buffer\x00" as *const u8 as *const libc::c_char,
        );
    }
    if !buffer.is_null() {
    } else {
        ::c2rust_out::stdlib::__assert_fail(
            b"buffer != NULL\x00" as *const u8 as *const libc::c_char,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9843 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
                b"void test_nsalloc_parse_buffer(void)\x00",
            ))
            .as_ptr(),
        );
    }
    ::c2rust_out::stdlib::memcpy(
        buffer,
        text as *const libc::c_void,
        ::c2rust_out::stdlib::strlen(text),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_SUSPENDED_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9847 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_NONE as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9849 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9852 as libc::c_int,
            b"Suspended XML_ParseBuffer not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_SUSPENDED as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9854 as libc::c_int,
        );
    }
    if !::c2rust_out::src::lib::xmlparse::XML_GetBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
    )
    .is_null()
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9856 as libc::c_int,
            b"Suspended XML_GetBuffer not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    /* Get it going again and complete the world */
    ::c2rust_out::src::lib::xmlparse::XML_SetCharacterDataHandler(
        g_parser,
        ::std::mem::transmute::<libc::intptr_t, crate::expat_h::XML_CharacterDataHandler>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        ),
    );
    if ::c2rust_out::src::lib::xmlparse::XML_ResumeParser(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_OK_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9861 as libc::c_int,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_ParseBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9864 as libc::c_int,
            b"Post-finishing XML_ParseBuffer not faulted\x00" as *const u8 as *const libc::c_char,
        );
    }
    if ::c2rust_out::src::lib::xmlparse::XML_GetErrorCode(g_parser) as libc::c_uint
        != ::c2rust_out::expat_h::XML_ERROR_FINISHED as libc::c_int as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9866 as libc::c_int,
        );
    }
    if !::c2rust_out::src::lib::xmlparse::XML_GetBuffer(
        g_parser,
        ::c2rust_out::stdlib::strlen(text) as libc::c_int,
    )
    .is_null()
    {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9868 as libc::c_int,
            b"Post-finishing XML_GetBuffer not faulted\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Check handling of long prefix names (pool growth) */

unsafe extern "C" fn test_nsalloc_long_prefix() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"test_nsalloc_long_prefix\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9873 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:foo xmlns:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ=\'http://example.org/\'></ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:foo>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9942 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            9944 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Check handling of long uri names (pool growth) */

unsafe extern "C" fn test_nsalloc_long_uri() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"test_nsalloc_long_uri\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        9949 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/\' bar:a=\'12\'\nxmlns:bar=\'http://example.org/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/\'></foo:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10002 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10004 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test handling of long attribute names with prefixes */

unsafe extern "C" fn test_nsalloc_long_attr() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"test_nsalloc_long_attr\x00"))
            .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10009 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' bar:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ=\'12\'\nxmlns:bar=\'http://example.org/\'></foo:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10045 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10047 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test handling of an attribute name with a long namespace prefix */

unsafe extern "C" fn test_nsalloc_long_attr_prefix() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_nsalloc_long_attr_prefix\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10052 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:a=\'12\'\nxmlns:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ=\'http://example.org/\'></foo:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut elemstr: [*const crate::expat_external_h::XML_Char; 2] =
        [b"http://example.org/ e foo\x00" as *const u8 as *const libc::c_char,
         b"http://example.org/ a ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ\x00"
             as *const u8 as *const libc::c_char];
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetReturnNSTriplet(
            g_parser,
            ::c2rust_out::expat_h::XML_TRUE,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            elemstr.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
            g_parser,
            Some(
                triplet_start_checker
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
            Some(
                triplet_end_checker
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10131 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10133 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test attribute handling in the face of a dodgy reallocator */

unsafe extern "C" fn test_nsalloc_realloc_attributes() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"test_nsalloc_realloc_attributes\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10138 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:e xmlns:foo=\'http://example.org/\' bar:a=\'12\'\n       xmlns:bar=\'http://example.org/\'></foo:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10155 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10157 as libc::c_int,
            b"Parsing failed at max reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test long element names with namespaces under a failing allocator */

unsafe extern "C" fn test_nsalloc_long_element() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_nsalloc_long_element\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10162 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<foo:thisisalongenoughelementnametotriggerareallocation\n xmlns:foo=\'http://example.org/\' bar:a=\'12\'\n xmlns:bar=\'http://example.org/\'></foo:thisisalongenoughelementnametotriggerareallocation>\x00"
            as *const u8 as *const libc::c_char;
    let mut elemstr: [*const crate::expat_external_h::XML_Char; 2] = [
        b"http://example.org/ thisisalongenoughelementnametotriggerareallocation foo\x00"
            as *const u8 as *const libc::c_char,
        b"http://example.org/ a bar\x00" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 30 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetReturnNSTriplet(
            g_parser,
            ::c2rust_out::expat_h::XML_TRUE,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            elemstr.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetElementHandler(
            g_parser,
            Some(
                triplet_start_checker
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *mut *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
            Some(
                triplet_end_checker
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> (),
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10188 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10190 as libc::c_int,
            b"Parsing failed at max reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test the effects of reallocation failure when reassigning a
 * binding.
 *
 * XML_ParserReset does not free the BINDING structures used by a
 * parser, but instead adds them to an internal free list to be reused
 * as necessary.  Likewise the URI buffers allocated for the binding
 * aren't freed, but kept attached to their existing binding.  If the
 * new binding has a longer URI, it will need reallocation.  This test
 * provokes that reallocation, and tests the control path if it fails.
 */

unsafe extern "C" fn test_nsalloc_realloc_binding_uri() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_nsalloc_realloc_binding_uri\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10204 as libc::c_int,
    );
    let mut first: *const libc::c_char =
        b"<doc xmlns=\'http://example.org/\'>\n  <e xmlns=\'\' />\n</doc>\x00" as *const u8
            as *const libc::c_char;
    let mut second: *const libc::c_char =
        b"<doc xmlns=\'http://example.org/long/enough/URI/to/reallocate/\'>\n  <e xmlns=\'\' />\n</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_uint = 0;
    let max_realloc_count: libc::c_uint = 10 as libc::c_int as libc::c_uint;
    /* First, do a full parse that will leave bindings around */
    if _XML_Parse_SINGLE_BYTES(
        g_parser,
        first,
        ::c2rust_out::stdlib::strlen(first) as libc::c_int,
        ::c2rust_out::expat_h::XML_TRUE,
    ) as libc::c_uint
        == ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
    {
        _xml_failure(
            g_parser,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10218 as libc::c_int,
        );
    }
    /* Now repeat with a longer URI and a duff reallocator */
    i = 0 as libc::c_int as libc::c_uint;
    while i < max_realloc_count {
        ::c2rust_out::src::lib::xmlparse::XML_ParserReset(
            g_parser,
            ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
        );
        reallocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            second,
            ::c2rust_out::stdlib::strlen(second) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        i = i.wrapping_add(1)
    }
    if i == 0 as libc::c_int as libc::c_uint {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10229 as libc::c_int,
            b"Parsing worked despite failing reallocation\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10231 as libc::c_int,
            b"Parsing failed at max reallocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Check handling of long prefix names (pool growth) */

unsafe extern "C" fn test_nsalloc_realloc_long_prefix() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_nsalloc_realloc_long_prefix\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10236 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:foo xmlns:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ=\'http://example.org/\'></ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:foo>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 12 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10305 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10307 as libc::c_int,
            b"Parsing failed even at max reallocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Check handling of even long prefix names (different code path) */

unsafe extern "C" fn test_nsalloc_realloc_longer_prefix() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 35], &[libc::c_char; 35]>(
            b"test_nsalloc_realloc_longer_prefix\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10312 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZQ:foo xmlns:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZQ=\'http://example.org/\'></ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZQ:foo>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 12 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10381 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10383 as libc::c_int,
            b"Parsing failed even at max reallocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_nsalloc_long_namespace() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"test_nsalloc_long_namespace\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10387 as libc::c_int,
    );
    let mut text1: *const libc::c_char =
        b"<ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:e xmlns:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ=\'http://example.org/\'>\n\x00"
            as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"<ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:f ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:attr=\'foo\'/>\n</ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text1,
            ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
            ::c2rust_out::expat_h::XML_FALSE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
            && _XML_Parse_SINGLE_BYTES(
                g_parser,
                text2,
                ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
                ::c2rust_out::expat_h::XML_TRUE,
            ) as libc::c_uint
                != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10495 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10497 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Using a slightly shorter namespace name provokes allocations in
 * slightly different places in the code.
 */

unsafe extern "C" fn test_nsalloc_less_long_namespace() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_nsalloc_less_long_namespace\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10504 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678:e xmlns:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678=\'http://example.org/\'>\n<ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678:f ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678:att=\'foo\'/>\n</ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678:e>\x00"
            as *const u8 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 40 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10568 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10570 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_nsalloc_long_context() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"test_nsalloc_long_context\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10574 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ATTLIST doc baz ID #REQUIRED>\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKL\' baz=\'2\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut options: [ExtOption; 3] = [
        {
            let mut init = ExtOption {
                system_id: b"foo\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<!ELEMENT e EMPTY>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: b"bar\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<e/>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 70 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10620 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10622 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* This function is void; it will throw a fail() on error, so if it
 * returns normally it must have succeeded.
 */

unsafe extern "C" fn context_realloc_test(mut text: *const libc::c_char) {
    let mut options: [ExtOption; 3] = [
        {
            let mut init = ExtOption {
                system_id: b"foo\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<!ELEMENT e EMPTY>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: b"bar\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<e/>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 6 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10649 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10651 as libc::c_int,
            b"Parsing failed even at max reallocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_nsalloc_realloc_long_context() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_nsalloc_realloc_long_context\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10654 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKL\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    context_realloc_test(text);
}

unsafe extern "C" fn test_nsalloc_realloc_long_context_2() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_nsalloc_realloc_long_context_2\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10685 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJK\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    context_realloc_test(text);
}

unsafe extern "C" fn test_nsalloc_realloc_long_context_3() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_nsalloc_realloc_long_context_3\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10716 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGH\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    context_realloc_test(text);
}

unsafe extern "C" fn test_nsalloc_realloc_long_context_4() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_nsalloc_realloc_long_context_4\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10747 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    context_realloc_test(text);
}

unsafe extern "C" fn test_nsalloc_realloc_long_context_5() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_nsalloc_realloc_long_context_5\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10778 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABC\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    context_realloc_test(text);
}

unsafe extern "C" fn test_nsalloc_realloc_long_context_6() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_nsalloc_realloc_long_context_6\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10809 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    context_realloc_test(text);
}

unsafe extern "C" fn test_nsalloc_realloc_long_context_7() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 36], &[libc::c_char; 36]>(
            b"test_nsalloc_realloc_long_context_7\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10839 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLM\'>\n&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    context_realloc_test(text);
}

unsafe extern "C" fn test_nsalloc_realloc_long_ge_name() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_nsalloc_realloc_long_ge_name\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10870 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP SYSTEM \'bar\'>\n]>\n<doc xmlns=\'http://example.org/baz\'>\n&ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut options: [ExtOption; 3] = [
        {
            let mut init = ExtOption {
                system_id: b"foo\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<!ELEMENT el EMPTY>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: b"bar\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<el/>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 10 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10932 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            10934 as libc::c_int,
            b"Parsing failed even at max reallocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/* Test that when a namespace is passed through the context mechanism
 * to an external entity parser, the parsers handle reallocation
 * failures correctly.  The prefix is exactly the right length to
 * provoke particular uncommon code paths.
 */

unsafe extern "C" fn test_nsalloc_realloc_long_context_in_dtd() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
            b"test_nsalloc_realloc_long_context_in_dtd\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        10943 as libc::c_int,
    );
    let mut text1: *const libc::c_char =
        b"<!DOCTYPE ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP:doc [\n  <!ENTITY First SYSTEM \'foo/First\'>\n]>\n<ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP:doc xmlns:ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP=\'foo/Second\'>&First;\x00"
            as *const u8 as *const libc::c_char;
    let mut text2: *const libc::c_char =
        b"</ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP:doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut options: [ExtOption; 2] = [
        {
            let mut init = ExtOption {
                system_id: b"foo/First\x00" as *const u8 as *const libc::c_char,
                parse_text: b"Hello world\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_realloc_count: libc::c_int = 20 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_realloc_count {
        reallocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text1,
            ::c2rust_out::stdlib::strlen(text1) as libc::c_int,
            ::c2rust_out::expat_h::XML_FALSE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
            && _XML_Parse_SINGLE_BYTES(
                g_parser,
                text2,
                ::c2rust_out::stdlib::strlen(text2) as libc::c_int,
                ::c2rust_out::expat_h::XML_TRUE,
            ) as libc::c_uint
                != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11040 as libc::c_int,
            b"Parsing worked despite failing reallocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_realloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11042 as libc::c_int,
            b"Parsing failed even at max reallocation count\x00" as *const u8
                as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_nsalloc_long_default_in_ext() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"test_nsalloc_long_default_in_ext\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        11046 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc [\n  <!ATTLIST e a1 CDATA \'ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\'>\n  <!ENTITY x SYSTEM \'foo\'>\n]>\n<doc>&x;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut options: [ExtOption; 2] = [
        {
            let mut init = ExtOption {
                system_id: b"foo\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<e/>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 50 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11089 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11091 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn test_nsalloc_long_systemid_in_ext() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 34], &[libc::c_char; 34]>(
            b"test_nsalloc_long_systemid_in_ext\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        11095 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE doc SYSTEM \'foo\' [\n  <!ENTITY en SYSTEM \'ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/\'>\n]>\n<doc>&en;</doc>\x00"
            as *const u8 as *const libc::c_char;
    let mut options: [ExtOption; 3] = [
        {
            let mut init = ExtOption {
                system_id: b"foo\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<!ELEMENT e EMPTY>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init =
                 ExtOption{system_id:
                               b"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/\x00"
                                   as *const u8 as *const libc::c_char,
                           parse_text:
                               b"<e/>\x00" as *const u8 as
                                   *const libc::c_char,};
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 55 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11158 as libc::c_int,
            b"Parsing worked despite failing allocations\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11160 as libc::c_int,
            b"Parsing failed even at max allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/* Test the effects of allocation failure on parsing an element in a
 * namespace.  Based on test_nsalloc_long_context.
 */

unsafe extern "C" fn test_nsalloc_prefixed_element() {
    ::c2rust_out::src::tests::minicheck::_check_set_test_info(
        (*::std::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"test_nsalloc_prefixed_element\x00",
        ))
        .as_ptr(),
        b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00" as *const u8
            as *const libc::c_char,
        11167 as libc::c_int,
    );
    let mut text: *const libc::c_char =
        b"<!DOCTYPE pfx:element SYSTEM \'foo\' [\n  <!ATTLIST pfx:element baz ID #REQUIRED>\n  <!ENTITY en SYSTEM \'bar\'>\n]>\n<pfx:element xmlns:pfx=\'http://example.org/\' baz=\'2\'>\n&en;</pfx:element>\x00"
            as *const u8 as *const libc::c_char;
    let mut options: [ExtOption; 3] = [
        {
            let mut init = ExtOption {
                system_id: b"foo\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<!ELEMENT e EMPTY>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: b"bar\x00" as *const u8 as *const libc::c_char,
                parse_text: b"<e/>\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ExtOption {
                system_id: ::c2rust_out::stddef_h::NULL as *const crate::expat_external_h::XML_Char,
                parse_text: ::c2rust_out::stddef_h::NULL as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let max_alloc_count: libc::c_int = 70 as libc::c_int;
    i = 0 as libc::c_int;
    while i < max_alloc_count {
        allocation_count = i as crate::stdlib::intptr_t;
        ::c2rust_out::src::lib::xmlparse::XML_SetUserData(
            g_parser,
            options.as_mut_ptr() as *mut libc::c_void,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetParamEntityParsing(
            g_parser,
            ::c2rust_out::expat_h::XML_PARAM_ENTITY_PARSING_ALWAYS,
        );
        ::c2rust_out::src::lib::xmlparse::XML_SetExternalEntityRefHandler(
            g_parser,
            Some(
                external_entity_optioner
                    as unsafe extern "C" fn(
                        _: crate::expat_h::XML_Parser,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                        _: *const crate::expat_external_h::XML_Char,
                    ) -> libc::c_int,
            ),
        );
        if _XML_Parse_SINGLE_BYTES(
            g_parser,
            text,
            ::c2rust_out::stdlib::strlen(text) as libc::c_int,
            ::c2rust_out::expat_h::XML_TRUE,
        ) as libc::c_uint
            != ::c2rust_out::expat_h::XML_STATUS_ERROR_0 as libc::c_uint
        {
            break;
        }
        /* See comment in test_nsalloc_xmlns() */
        nsalloc_teardown();
        nsalloc_setup();
        i += 1
    }
    if i == 0 as libc::c_int {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11194 as libc::c_int,
            b"Success despite failing allocator\x00" as *const u8 as *const libc::c_char,
        );
    } else if i == max_alloc_count {
        ::c2rust_out::src::tests::minicheck::_fail_unless(
            0 as libc::c_int,
            b"/home/sjcrane/projects/c2rust/libexpat/upstream/expat/tests/runtests.c\x00"
                as *const u8 as *const libc::c_char,
            11196 as libc::c_int,
            b"Failed even at full allocation count\x00" as *const u8 as *const libc::c_char,
        );
    };
}

unsafe extern "C" fn make_suite() -> *mut ::c2rust_out::src::tests::minicheck::Suite {
    let mut s: *mut ::c2rust_out::src::tests::minicheck::Suite =
        ::c2rust_out::src::tests::minicheck::suite_create(
            b"basic\x00" as *const u8 as *const libc::c_char,
        ) as *mut ::c2rust_out::src::tests::minicheck::Suite;
    let mut tc_basic: *mut ::c2rust_out::src::tests::minicheck::TCase =
        ::c2rust_out::src::tests::minicheck::tcase_create(
            b"basic tests\x00" as *const u8 as *const libc::c_char,
        ) as *mut ::c2rust_out::src::tests::minicheck::TCase;
    let mut tc_namespace: *mut ::c2rust_out::src::tests::minicheck::TCase =
        ::c2rust_out::src::tests::minicheck::tcase_create(
            b"XML namespaces\x00" as *const u8 as *const libc::c_char,
        ) as *mut ::c2rust_out::src::tests::minicheck::TCase;
    let mut tc_misc: *mut ::c2rust_out::src::tests::minicheck::TCase =
        ::c2rust_out::src::tests::minicheck::tcase_create(
            b"miscellaneous tests\x00" as *const u8 as *const libc::c_char,
        ) as *mut ::c2rust_out::src::tests::minicheck::TCase;
    let mut tc_alloc: *mut ::c2rust_out::src::tests::minicheck::TCase =
        ::c2rust_out::src::tests::minicheck::tcase_create(
            b"allocation tests\x00" as *const u8 as *const libc::c_char,
        ) as *mut ::c2rust_out::src::tests::minicheck::TCase;
    let mut tc_nsalloc: *mut ::c2rust_out::src::tests::minicheck::TCase =
        ::c2rust_out::src::tests::minicheck::tcase_create(
            b"namespace allocation tests\x00" as *const u8 as *const libc::c_char,
        ) as *mut ::c2rust_out::src::tests::minicheck::TCase;
    ::c2rust_out::src::tests::minicheck::suite_add_tcase(
        s as *mut ::c2rust_out::src::tests::minicheck::Suite,
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_checked_fixture(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(basic_setup as unsafe extern "C" fn() -> ()),
        Some(basic_teardown as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nul_byte as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_u0000_char as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_siphash_self as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_siphash_spec as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bom_utf8 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bom_utf16_be as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bom_utf16_le as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nobom_utf16_le as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_illegal_utf8 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf8_auto_align as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_le_epilog_newline as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_not_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_latin1_umlauts as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_long_utf8_character as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_long_latin1_attribute as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_long_ascii_attribute as unsafe extern "C" fn() -> ()),
    );
    /* Regression test for SF bug #491986. */
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_danish_latin1 as unsafe extern "C" fn() -> ()),
    );
    /* Regression test for SF bug #514281. */
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_french_charref_hexidecimal as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_french_charref_decimal as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_french_latin1 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_french_utf8 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf8_false_rejection as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_line_number_after_parse as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_column_number_after_parse as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_line_and_column_numbers_inside_handlers as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_line_number_after_error as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_column_number_after_error as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_really_long_lines as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_really_long_encoded_lines as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_end_element_events as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_attr_whitespace_normalization as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_xmldecl_misplaced as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_xmldecl_invalid as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_xmldecl_missing_attr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_xmldecl_missing_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_internal_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unrecognised_encoding_internal_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_wfc_undeclared_entity_unread_external_subset as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_wfc_undeclared_entity_no_external_subset as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_wfc_undeclared_entity_standalone as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_wfc_undeclared_entity_with_external_subset as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_not_standalone_handler_reject as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_not_standalone_handler_accept as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(
            test_wfc_undeclared_entity_with_external_subset_standalone
                as unsafe extern "C" fn() -> (),
        ),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_entity_with_external_subset_unless_standalone as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_wfc_no_recursive_entity_refs as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_set_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_no_handler as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_set_bom as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_bad_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_bad_encoding_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_invalid_parse as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_invalid_suspended_parse as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_dtd_default_handling as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_dtd_attr_handling as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_empty_ns_without_namespaces as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_in_attribute_default_without_namespaces as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_stop_parser_between_char_data_calls as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_suspend_parser_between_char_data_calls as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_repeated_stop_parser_between_char_data_calls as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_good_cdata_ascii as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_good_cdata_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_good_cdata_utf16_le as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_long_cdata_utf16 as unsafe extern "C" fn() -> ()),
    );
    /* FIXME workaround -DXML_MIN_SIZE + ASan (issue #332) */
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_multichar_cdata_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_bad_surrogate_pair as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_cdata as unsafe extern "C" fn() -> ()),
    );
    /* FIXME workaround -DXML_MIN_SIZE + ASan (issue #332) */
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_cdata_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_stop_parser_between_cdata_calls as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_suspend_parser_between_cdata_calls as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_memory_allocation as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_default_current as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_dtd_elements as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_set_foreign_dtd as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_foreign_dtd_not_standalone as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_invalid_foreign_dtd as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_foreign_dtd_with_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_foreign_dtd_without_external_subset as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_empty_foreign_dtd as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_set_base as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_attributes as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_reset_in_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_resume_invalid_parse as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_resume_resuspended as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_cdata_default as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_subordinate_reset as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_subordinate_suspend as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_subordinate_xdecl_suspend as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_subordinate_xdecl_abort as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_explicit_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_trailing_cr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_trailing_cr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_trailing_rsqb as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_trailing_rsqb as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_good_cdata as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_user_parameters as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_ref_parameter as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_empty_parse as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_get_buffer_1 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_get_buffer_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_byte_info_at_end as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_byte_info_at_error as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_byte_info_at_cdata as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_predefined_entities as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_invalid_tag_in_dtd as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_not_predefined_entities as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ignore_section as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ignore_section_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ignore_section_utf16_be as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_ignore_section as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_external_entity_values as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_not_standalone as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_value_abort as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_public_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_attribute_enum_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_predefined_entity_redefinition as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_dtd_stop_processing as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_public_notation_no_sysid as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nested_groups as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_group_choice as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_standalone_parameter_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_skipped_parameter_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_recursive_external_parameter_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_undefined_ext_entity_in_external_dtd as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_suspend_xdecl as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_abort_epilog as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_abort_epilog_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_suspend_epilog as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_suspend_in_sole_empty_tag as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unfinished_epilog as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_partial_char_in_epilog as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_hash_collision as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_suspend_resume_internal_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_resume_entity_with_syntax_error as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_suspend_resume_parameter_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_restart_on_error as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_reject_lt_in_attribute_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_reject_unfinished_param_in_att_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_trailing_cr_in_att_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_standalone_internal_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_skipped_external_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_skipped_null_loaded_ext_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_skipped_unloaded_ext_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_param_entity_with_trailing_cr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_invalid_character_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_invalid_character_entity_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_invalid_character_entity_3 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_invalid_character_entity_4 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_pi_handled_in_default as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_comment_handled_in_default as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_pi_yml as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_pi_xnl as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_pi_xmm as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_pi as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_be_pi as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_be_comment as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_le_comment as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_missing_encoding_conversion_fn as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_failing_encoding_conversion_fn as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_success as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_bad_name as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_bad_name_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_long_name_1 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_long_name_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_invalid_unknown_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_ascii_encoding_ok as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_ascii_encoding_fail as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_invalid_length as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_invalid_topbit as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_invalid_surrogate as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_invalid_high as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_invalid_attr_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_latin1_utf16le_bom as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_latin1_utf16be_bom as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_latin1_utf16le_bom2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_latin1_utf16be_bom2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_utf16_be as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_utf16_le as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_utf16_unknown as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ext_entity_utf8_non_bom as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf8_in_cdata_section as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf8_in_cdata_section_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_trailing_spaces_in_elements as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_attribute as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_second_attr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_attr_after_solidus as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_utf16_pe as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_attr_desc_keyword as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_attr_desc_keyword_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_doctype_utf16 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_doctype_plus as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_doctype_star as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_doctype_query as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_unknown_encoding_bad_ignore as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_entity_in_utf16_be_attr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_entity_in_utf16_le_attr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_entity_public_utf16_be as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_entity_public_utf16_le as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_short_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_short_doctype_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_short_doctype_3 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_long_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_entity_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_entity_3 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_entity_4 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_bad_notation as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_default_doctype_handler as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_basic as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_empty_element_abort as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::suite_add_tcase(
        s as *mut ::c2rust_out::src::tests::minicheck::Suite,
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_checked_fixture(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(namespace_setup as unsafe extern "C" fn() -> ()),
        Some(namespace_teardown as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_return_ns_triplet as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_tagname_overwrite as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_tagname_overwrite_triplet as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_start_ns_clears_start_element as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_default_ns_from_ext_subset_and_ext_ge as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_prefix_with_empty_uri_1 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_prefix_with_empty_uri_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_prefix_with_empty_uri_3 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_prefix_with_empty_uri_4 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_unbound_prefix as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_default_with_empty_uri as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_duplicate_attrs_diff_prefixes as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_duplicate_hashes as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_unbound_prefix_on_attribute as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_unbound_prefix_on_element as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_parser_reset as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_long_element as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_mixed_prefix_atts as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_extend_uri_buffer as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_reserved_attributes as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_reserved_attributes_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_extremely_long_prefix as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_unknown_encoding_success as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_double_colon as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_double_colon_element as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_bad_attr_leafname as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_bad_element_leafname as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_utf16_leafname as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_utf16_element_leafname as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_utf16_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_invalid_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_namespace as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_ns_double_colon_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::suite_add_tcase(
        s as *mut ::c2rust_out::src::tests::minicheck::Suite,
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_checked_fixture(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        ::std::mem::transmute::<libc::intptr_t, crate::minicheck_h::tcase_setup_function>(
            ::c2rust_out::stddef_h::NULL as libc::intptr_t,
        ),
        Some(basic_teardown as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_alloc_create_parser as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_alloc_create_parser_with_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_null_parser as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_error_string as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_version as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_features as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_attribute_leak as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_utf16le as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_stop_during_end_handler_issue_240_1 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_misc_stop_during_end_handler_issue_240_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_misc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(
            test_misc_deny_internal_entity_closing_doctype_issue_317
                as unsafe extern "C" fn() -> (),
        ),
    );
    ::c2rust_out::src::tests::minicheck::suite_add_tcase(
        s as *mut ::c2rust_out::src::tests::minicheck::Suite,
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_checked_fixture(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(alloc_setup as unsafe extern "C" fn() -> ()),
        Some(alloc_teardown as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_xdecl as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_xdecl_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_pi as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_pi_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_pi_3 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_comment as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_comment_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_create_external_parser as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_run_external_parser as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_dtd_copy_default_atts as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_external_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_ext_entity_set_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_internal_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_dtd_default_handling as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_explicit_encoding as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_set_base as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_buffer as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_ext_entity_realloc_buffer as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_many_attributes as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_public_entity_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_subst_public_entity_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_public_doctype as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_parse_public_doctype_long_name as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_set_foreign_dtd as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_attribute_enum_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_attribute_enum_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_implied_attribute as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_default_attribute as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_notation as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_public_notation as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_system_notation as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_nested_groups as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_nested_groups as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_large_group as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_group_choice as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_pi_in_epilog as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_comment_in_epilog as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_long_attribute_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_attribute_whitespace as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_attribute_predefined_entity as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_long_attr_default_with_char_ref as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_long_attr_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_nested_entities as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_param_entity_newline as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_ce_extends_pe as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_realloc_attributes as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_long_doc_name as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_long_base as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_long_public_id as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_long_entity_value as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_alloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_alloc_long_notation as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::suite_add_tcase(
        s as *mut ::c2rust_out::src::tests::minicheck::Suite,
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_checked_fixture(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(nsalloc_setup as unsafe extern "C" fn() -> ()),
        Some(nsalloc_teardown as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_xmlns as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_parse_buffer as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_prefix as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_uri as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_attr as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_attr_prefix as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_attributes as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_element as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_binding_uri as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_prefix as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_longer_prefix as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_namespace as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_less_long_namespace as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_context as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context_2 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context_3 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context_4 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context_5 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context_6 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context_7 as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_ge_name as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_realloc_long_context_in_dtd as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_default_in_ext as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_long_systemid_in_ext as unsafe extern "C" fn() -> ()),
    );
    ::c2rust_out::src::tests::minicheck::tcase_add_test(
        tc_nsalloc as *mut ::c2rust_out::src::tests::minicheck::TCase,
        Some(test_nsalloc_prefixed_element as unsafe extern "C" fn() -> ()),
    );
    return s;
}

unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut nf: libc::c_int = 0;
    let mut verbosity: libc::c_int = crate::minicheck_h::CK_NORMAL;
    let mut s: *mut ::c2rust_out::src::tests::minicheck::Suite = make_suite();
    let mut sr: *mut ::c2rust_out::src::tests::minicheck::SRunner =
        ::c2rust_out::src::tests::minicheck::srunner_create(
            s as *mut ::c2rust_out::src::tests::minicheck::Suite,
        ) as *mut ::c2rust_out::src::tests::minicheck::SRunner;
    /* run the tests for internal helper functions */
    testhelper_is_whitespace_normalized();
    i = 1 as libc::c_int;
    while i < argc {
        let mut opt: *mut libc::c_char = *argv.offset(i as isize);
        if ::libc::strcmp(opt, b"-v\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
            || ::libc::strcmp(opt, b"--verbose\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            verbosity = ::c2rust_out::src::tests::minicheck::CK_VERBOSE
        } else if ::libc::strcmp(opt, b"-q\x00" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
            || ::libc::strcmp(opt, b"--quiet\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            verbosity = crate::minicheck_h::CK_SILENT
        } else {
            ::c2rust_out::stdlib::fprintf(
                crate::stdlib::stderr as *mut ::c2rust_out::stdlib::_IO_FILE,
                b"runtests: unknown option \'%s\'\n\x00" as *const u8 as *const libc::c_char,
                opt,
            );
            return 2 as libc::c_int;
        }
        i += 1
    }
    if verbosity != crate::minicheck_h::CK_SILENT {
        ::libc::printf(
            b"Expat version: %s\n\x00" as *const u8 as *const libc::c_char,
            ::c2rust_out::src::lib::xmlparse::XML_ExpatVersion(),
        );
    }
    ::c2rust_out::src::tests::minicheck::srunner_run_all(
        sr as *mut ::c2rust_out::src::tests::minicheck::SRunner,
        verbosity,
    );
    nf = ::c2rust_out::src::tests::minicheck::srunner_ntests_failed(
        sr as *mut ::c2rust_out::src::tests::minicheck::SRunner,
    );
    ::c2rust_out::src::tests::minicheck::srunner_free(
        sr as *mut ::c2rust_out::src::tests::minicheck::SRunner,
    );
    return if nf == 0 as libc::c_int {
        ::libc::EXIT_SUCCESS
    } else {
        ::libc::EXIT_FAILURE
    };
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            ::std::ffi::CString::new(arg)
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0(
            (args.len() - 1) as libc::c_int,
            args.as_mut_ptr() as *mut *mut libc::c_char,
        ) as i32)
    }
}
